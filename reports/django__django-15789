[{"repo": "django/django", "instance_id": "django__django-15789", "base_commit": "d4d5427571b4bf3a21c902276c2a00215c2a37cc", "patch": "diff --git a/django/utils/html.py b/django/utils/html.py\n--- a/django/utils/html.py\n+++ b/django/utils/html.py\n@@ -59,7 +59,7 @@ def escapejs(value):\n }\n \n \n-def json_script(value, element_id=None):\n+def json_script(value, element_id=None, encoder=None):\n     \"\"\"\n     Escape all the HTML/XML special characters with their unicode escapes, so\n     value is safe to be output anywhere except for inside a tag attribute. Wrap\n@@ -67,7 +67,9 @@ def json_script(value, element_id=None):\n     \"\"\"\n     from django.core.serializers.json import DjangoJSONEncoder\n \n-    json_str = json.dumps(value, cls=DjangoJSONEncoder).translate(_json_script_escapes)\n+    json_str = json.dumps(value, cls=encoder or DjangoJSONEncoder).translate(\n+        _json_script_escapes\n+    )\n     if element_id:\n         template = '<script id=\"{}\" type=\"application/json\">{}</script>'\n         args = (element_id, mark_safe(json_str))\n", "test_patch": "diff --git a/tests/utils_tests/test_html.py b/tests/utils_tests/test_html.py\n--- a/tests/utils_tests/test_html.py\n+++ b/tests/utils_tests/test_html.py\n@@ -1,6 +1,7 @@\n import os\n from datetime import datetime\n \n+from django.core.serializers.json import DjangoJSONEncoder\n from django.test import SimpleTestCase\n from django.utils.functional import lazystr\n from django.utils.html import (\n@@ -211,6 +212,16 @@ def test_json_script(self):\n             with self.subTest(arg=arg):\n                 self.assertEqual(json_script(arg, \"test_id\"), expected)\n \n+    def test_json_script_custom_encoder(self):\n+        class CustomDjangoJSONEncoder(DjangoJSONEncoder):\n+            def encode(self, o):\n+                return '{\"hello\": \"world\"}'\n+\n+        self.assertHTMLEqual(\n+            json_script({}, encoder=CustomDjangoJSONEncoder),\n+            '<script type=\"application/json\">{\"hello\": \"world\"}</script>',\n+        )\n+\n     def test_json_script_without_id(self):\n         self.assertHTMLEqual(\n             json_script({\"key\": \"value\"}),\n", "problem_statement": "Add an encoder parameter to django.utils.html.json_script().\nDescription\n\t\nI have a use case where I want to customize the JSON encoding of some values to output to the template layer. It looks like django.utils.html.json_script is a good utility for that, however the JSON encoder is hardcoded to DjangoJSONEncoder. I think it would be nice to be able to pass a custom encoder class.\nBy the way, django.utils.html.json_script is not documented (only its template filter counterpart is), would it be a good thing to add to the docs?\n", "hints_text": "Sounds good, and yes, we should document django.utils.html.json_script().\n\u200bPR I'll also add docs for json_script() soon\n\u200bPR", "created_at": "2022-06-23T08:59:04Z", "version": "4.2", "FAIL_TO_PASS": "[\"test_json_script_custom_encoder (utils_tests.test_html.TestUtilsHtml)\"]", "PASS_TO_PASS": "[\"test_conditional_escape (utils_tests.test_html.TestUtilsHtml)\", \"test_escape (utils_tests.test_html.TestUtilsHtml)\", \"test_escapejs (utils_tests.test_html.TestUtilsHtml)\", \"test_format_html (utils_tests.test_html.TestUtilsHtml)\", \"test_html_safe (utils_tests.test_html.TestUtilsHtml)\", \"test_html_safe_defines_html_error (utils_tests.test_html.TestUtilsHtml)\", \"test_html_safe_doesnt_define_str (utils_tests.test_html.TestUtilsHtml)\", \"test_html_safe_subclass (utils_tests.test_html.TestUtilsHtml)\", \"test_json_script (utils_tests.test_html.TestUtilsHtml)\", \"test_json_script_without_id (utils_tests.test_html.TestUtilsHtml)\", \"test_linebreaks (utils_tests.test_html.TestUtilsHtml)\", \"test_smart_urlquote (utils_tests.test_html.TestUtilsHtml)\", \"test_strip_spaces_between_tags (utils_tests.test_html.TestUtilsHtml)\", \"test_strip_tags (utils_tests.test_html.TestUtilsHtml)\", \"test_strip_tags_files (utils_tests.test_html.TestUtilsHtml)\", \"test_urlize (utils_tests.test_html.TestUtilsHtml)\", \"test_urlize_unchanged_inputs (utils_tests.test_html.TestUtilsHtml)\"]", "environment_setup_commit": "0fbdb9784da915fce5dcc1fe82bac9b4785749e5"}, "On branch main\nChanges not staged for commit:\n  (use \"git add <file>...\" to update what will be committed)\n  (use \"git restore <file>...\" to discard changes in working directory)\n\tmodified:   django/utils/html.py\n\nno changes added to commit (use \"git add\" and/or \"git commit -a\")\ncommit d4d5427571b4bf3a21c902276c2a00215c2a37cc\nAuthor: Mehrdad <mhrddmoradii@gmail.com>\nDate:   Fri Jun 24 14:46:34 2022 -0400\n\n    Refs #33697 -- Used django.utils.http.parse_header_parameters() for parsing boundary streams.\n    \n    This also removes unused parse_header() and _parse_header_params()\n    helpers in django.http.multipartparser.\n\ndiff --git a/django/http/multipartparser.py b/django/http/multipartparser.py\nindex 73ef074744..b3e0925a42 100644\n--- a/django/http/multipartparser.py\n+++ b/django/http/multipartparser.py\n@@ -8,7 +8,6 @@ import base64\n import binascii\n import collections\n import html\n-from urllib.parse import unquote\n \n from django.conf import settings\n from django.core.exceptions import (\n@@ -675,8 +674,9 @@ def parse_boundary_stream(stream, max_header_size):\n         # This terminology (\"main value\" and \"dictionary of\n         # parameters\") is from the Python docs.\n         try:\n-            main_value_pair, params = parse_header(line)\n+            main_value_pair, params = parse_header_parameters(line.decode())\n             name, value = main_value_pair.split(\":\", 1)\n+            params = {k: v.encode() for k, v in params.items()}\n         except ValueError:  # Invalid header.\n             continue\n \n@@ -703,50 +703,3 @@ class Parser:\n         for sub_stream in boundarystream:\n             # Iterate over each part\n             yield parse_boundary_stream(sub_stream, 1024)\n-\n-\n-def parse_header(line):\n-    \"\"\"\n-    Parse the header into a key-value.\n-\n-    Input (line): bytes, output: str for key/name, bytes for values which\n-    will be decoded later.\n-    \"\"\"\n-    plist = _parse_header_params(b\";\" + line)\n-    key = plist.pop(0).lower().decode(\"ascii\")\n-    pdict = {}\n-    for p in plist:\n-        i = p.find(b\"=\")\n-        if i >= 0:\n-            has_encoding = False\n-            name = p[:i].strip().lower().decode(\"ascii\")\n-            if name.endswith(\"*\"):\n-                # Lang/encoding embedded in the value (like \"filename*=UTF-8''file.ext\")\n-                # https://tools.ietf.org/html/rfc2231#section-4\n-                name = name[:-1]\n-                if p.count(b\"'\") == 2:\n-                    has_encoding = True\n-            value = p[i + 1 :].strip()\n-            if len(value) >= 2 and value[:1] == value[-1:] == b'\"':\n-                value = value[1:-1]\n-                value = value.replace(b\"\\\\\\\\\", b\"\\\\\").replace(b'\\\\\"', b'\"')\n-            if has_encoding:\n-                encoding, lang, value = value.split(b\"'\")\n-                value = unquote(value.decode(), encoding=encoding.decode())\n-            pdict[name] = value\n-    return key, pdict\n-\n-\n-def _parse_header_params(s):\n-    plist = []\n-    while s[:1] == b\";\":\n-        s = s[1:]\n-        end = s.find(b\";\")\n-        while end > 0 and (s.count(b'\"', 0, end) - s.count(b'\\\\\"', 0, end)) % 2:\n-            end = s.find(b\";\", end + 1)\n-        if end < 0:\n-            end = len(s)\n-        f = s[:end]\n-        plist.append(f.strip())\n-        s = s[end:]\n-    return plist\ndiff --git a/django/utils/http.py b/django/utils/http.py\nindex 6e2091bf52..51fdc4b149 100644\n--- a/django/utils/http.py\n+++ b/django/utils/http.py\n@@ -11,6 +11,7 @@ from urllib.parse import (\n     _splitnetloc,\n     _splitparams,\n     scheme_chars,\n+    unquote,\n )\n from urllib.parse import urlencode as original_urlencode\n from urllib.parse import uses_params\n@@ -387,15 +388,25 @@ def parse_header_parameters(line):\n     Return the main content-type and a dictionary of options.\n     \"\"\"\n     parts = _parseparam(\";\" + line)\n-    key = parts.__next__()\n+    key = parts.__next__().lower()\n     pdict = {}\n     for p in parts:\n         i = p.find(\"=\")\n         if i >= 0:\n+            has_encoding = False\n             name = p[:i].strip().lower()\n+            if name.endswith(\"*\"):\n+                # Lang/encoding embedded in the value (like \"filename*=UTF-8''file.ext\")\n+                # https://tools.ietf.org/html/rfc2231#section-4\n+                name = name[:-1]\n+                if p.count(\"'\") == 2:\n+                    has_encoding = True\n             value = p[i + 1 :].strip()\n             if len(value) >= 2 and value[0] == value[-1] == '\"':\n                 value = value[1:-1]\n                 value = value.replace(\"\\\\\\\\\", \"\\\\\").replace('\\\\\"', '\"')\n+            if has_encoding:\n+                encoding, lang, value = value.split(\"'\")\n+                value = unquote(value, encoding=encoding)\n             pdict[name] = value\n     return key, pdict\ndiff --git a/tests/file_uploads/tests.py b/tests/file_uploads/tests.py\nindex 44c54d908e..c6d76aa4c9 100644\n--- a/tests/file_uploads/tests.py\n+++ b/tests/file_uploads/tests.py\n@@ -17,7 +17,6 @@ from django.http.multipartparser import (\n     MultiPartParser,\n     MultiPartParserError,\n     Parser,\n-    parse_header,\n )\n from django.test import SimpleTestCase, TestCase, client, override_settings\n \n@@ -906,47 +905,3 @@ class MultiParserTests(SimpleTestCase):\n         for file_name in CANDIDATE_INVALID_FILE_NAMES:\n             with self.subTest(file_name=file_name):\n                 self.assertIsNone(parser.sanitize_file_name(file_name))\n-\n-    def test_rfc2231_parsing(self):\n-        test_data = (\n-            (\n-                b\"Content-Type: application/x-stuff; \"\n-                b\"title*=us-ascii'en-us'This%20is%20%2A%2A%2Afun%2A%2A%2A\",\n-                \"This is ***fun***\",\n-            ),\n-            (\n-                b\"Content-Type: application/x-stuff; title*=UTF-8''foo-%c3%a4.html\",\n-                \"foo-\u00e4.html\",\n-            ),\n-            (\n-                b\"Content-Type: application/x-stuff; title*=iso-8859-1''foo-%E4.html\",\n-                \"foo-\u00e4.html\",\n-            ),\n-        )\n-        for raw_line, expected_title in test_data:\n-            parsed = parse_header(raw_line)\n-            self.assertEqual(parsed[1][\"title\"], expected_title)\n-\n-    def test_rfc2231_wrong_title(self):\n-        \"\"\"\n-        Test wrongly formatted RFC 2231 headers (missing double single quotes).\n-        Parsing should not crash (#24209).\n-        \"\"\"\n-        test_data = (\n-            (\n-                b\"Content-Type: application/x-stuff; \"\n-                b\"title*='This%20is%20%2A%2A%2Afun%2A%2A%2A\",\n-                b\"'This%20is%20%2A%2A%2Afun%2A%2A%2A\",\n-            ),\n-            (b\"Content-Type: application/x-stuff; title*='foo.html\", b\"'foo.html\"),\n-            (b\"Content-Type: application/x-stuff; title*=bar.html\", b\"bar.html\"),\n-        )\n-        for raw_line, expected_title in test_data:\n-            parsed = parse_header(raw_line)\n-            self.assertEqual(parsed[1][\"title\"], expected_title)\n-\n-    def test_parse_header_with_double_quotes_and_semicolon(self):\n-        self.assertEqual(\n-            parse_header(b'form-data; name=\"files\"; filename=\"fo\\\\\"o;bar\"'),\n-            (\"form-data\", {\"name\": b\"files\", \"filename\": b'fo\"o;bar'}),\n-        )\ndiff --git a/tests/utils_tests/test_http.py b/tests/utils_tests/test_http.py\nindex 2ba617dfc9..b2754b4ddb 100644\n--- a/tests/utils_tests/test_http.py\n+++ b/tests/utils_tests/test_http.py\n@@ -472,3 +472,41 @@ class ParseHeaderParameterTests(unittest.TestCase):\n         for header, expected in tests:\n             with self.subTest(header=header):\n                 self.assertEqual(parse_header_parameters(header), expected)\n+\n+    def test_rfc2231_parsing(self):\n+        test_data = (\n+            (\n+                \"Content-Type: application/x-stuff; \"\n+                \"title*=us-ascii'en-us'This%20is%20%2A%2A%2Afun%2A%2A%2A\",\n+                \"This is ***fun***\",\n+            ),\n+            (\n+                \"Content-Type: application/x-stuff; title*=UTF-8''foo-%c3%a4.html\",\n+                \"foo-\u00e4.html\",\n+            ),\n+            (\n+                \"Content-Type: application/x-stuff; title*=iso-8859-1''foo-%E4.html\",\n+                \"foo-\u00e4.html\",\n+            ),\n+        )\n+        for raw_line, expected_title in test_data:\n+            parsed = parse_header_parameters(raw_line)\n+            self.assertEqual(parsed[1][\"title\"], expected_title)\n+\n+    def test_rfc2231_wrong_title(self):\n+        \"\"\"\n+        Test wrongly formatted RFC 2231 headers (missing double single quotes).\n+        Parsing should not crash (#24209).\n+        \"\"\"\n+        test_data = (\n+            (\n+                \"Content-Type: application/x-stuff; \"\n+                \"title*='This%20is%20%2A%2A%2Afun%2A%2A%2A\",\n+                \"'This%20is%20%2A%2A%2Afun%2A%2A%2A\",\n+            ),\n+            (\"Content-Type: application/x-stuff; title*='foo.html\", \"'foo.html\"),\n+            (\"Content-Type: application/x-stuff; title*=bar.html\", \"bar.html\"),\n+        )\n+        for raw_line, expected_title in test_data:\n+            parsed = parse_header_parameters(raw_line)\n+            self.assertEqual(parsed[1][\"title\"], expected_title)\ndiff --git a/django/utils/html.py b/django/utils/html.py\nindex d0bc97be80..007602a14a 100644\n--- a/django/utils/html.py\n+++ b/django/utils/html.py\n@@ -59,7 +59,7 @@ _json_script_escapes = {\n }\n \n \n-def json_script(value, element_id=None):\n+def json_script(value, element_id=None, encoder=None):\n     \"\"\"\n     Escape all the HTML/XML special characters with their unicode escapes, so\n     value is safe to be output anywhere except for inside a tag attribute. Wrap\n@@ -67,7 +67,9 @@ def json_script(value, element_id=None):\n     \"\"\"\n     from django.core.serializers.json import DjangoJSONEncoder\n \n-    json_str = json.dumps(value, cls=DjangoJSONEncoder).translate(_json_script_escapes)\n+    json_str = json.dumps(value, cls=encoder or DjangoJSONEncoder).translate(\n+        _json_script_escapes\n+    )\n     if element_id:\n         template = '<script id=\"{}\" type=\"application/json\">{}</script>'\n         args = (element_id, mark_safe(json_str))\nObtaining file:///testbed\n  Installing build dependencies: started\n  Installing build dependencies: finished with status 'done'\n  Checking if build backend supports build_editable: started\n  Checking if build backend supports build_editable: finished with status 'done'\n  Getting requirements to build editable: started\n  Getting requirements to build editable: finished with status 'done'\n  Preparing editable metadata (pyproject.toml): started\n  Preparing editable metadata (pyproject.toml): finished with status 'done'\nRequirement already satisfied: asgiref>=3.5.2 in /opt/miniconda3/envs/testbed/lib/python3.9/site-packages (from Django==4.2.dev20220628074247) (3.8.1)\nRequirement already satisfied: sqlparse>=0.2.2 in /opt/miniconda3/envs/testbed/lib/python3.9/site-packages (from Django==4.2.dev20220628074247) (0.5.1)\nRequirement already satisfied: typing-extensions>=4 in /opt/miniconda3/envs/testbed/lib/python3.9/site-packages (from asgiref>=3.5.2->Django==4.2.dev20220628074247) (4.12.2)\nBuilding wheels for collected packages: Django\n  Building editable for Django (pyproject.toml): started\n  Building editable for Django (pyproject.toml): finished with status 'done'\n  Created wheel for Django: filename=Django-4.2.dev20220628074247-0.editable-py3-none-any.whl size=27102 sha256=a32074b574fb4f3f5d1519915fe89f81b63eef8f15b86277d991f7ce6fac6418\n  Stored in directory: /tmp/pip-ephem-wheel-cache-7tykir55/wheels/7d/66/67/70d1ee2124ccf21d601c352e25cdca10f611f7c8b3f9ffb9e4\nSuccessfully built Django\nInstalling collected packages: Django\n  Attempting uninstall: Django\n    Found existing installation: Django 4.2.dev20220628074247\n    Uninstalling Django-4.2.dev20220628074247:\n      Successfully uninstalled Django-4.2.dev20220628074247\nSuccessfully installed Django-4.2.dev20220628074247\nTesting against Django installed in '/testbed/django'\nImporting application utils_tests\nFound 18 test(s).\nSkipping setup of unused database(s): default, other.\nSystem check identified no issues (0 silenced).\n", {}]