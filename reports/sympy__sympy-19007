[{"repo": "sympy/sympy", "instance_id": "sympy__sympy-19007", "base_commit": "f9e030b57623bebdc2efa7f297c1b5ede08fcebf", "patch": "diff --git a/sympy/matrices/expressions/blockmatrix.py b/sympy/matrices/expressions/blockmatrix.py\n--- a/sympy/matrices/expressions/blockmatrix.py\n+++ b/sympy/matrices/expressions/blockmatrix.py\n@@ -7,7 +7,7 @@\n from sympy.utilities import sift\n from sympy.utilities.misc import filldedent\n \n-from sympy.matrices.expressions.matexpr import MatrixExpr, ZeroMatrix, Identity\n+from sympy.matrices.expressions.matexpr import MatrixExpr, ZeroMatrix, Identity, MatrixElement\n from sympy.matrices.expressions.matmul import MatMul\n from sympy.matrices.expressions.matadd import MatAdd\n from sympy.matrices.expressions.matpow import MatPow\n@@ -234,16 +234,24 @@ def transpose(self):\n \n     def _entry(self, i, j, **kwargs):\n         # Find row entry\n+        orig_i, orig_j = i, j\n         for row_block, numrows in enumerate(self.rowblocksizes):\n-            if (i < numrows) != False:\n+            cmp = i < numrows\n+            if cmp == True:\n                 break\n-            else:\n+            elif cmp == False:\n                 i -= numrows\n+            elif row_block < self.blockshape[0] - 1:\n+                # Can't tell which block and it's not the last one, return unevaluated\n+                return MatrixElement(self, orig_i, orig_j)\n         for col_block, numcols in enumerate(self.colblocksizes):\n-            if (j < numcols) != False:\n+            cmp = j < numcols\n+            if cmp == True:\n                 break\n-            else:\n+            elif cmp == False:\n                 j -= numcols\n+            elif col_block < self.blockshape[1] - 1:\n+                return MatrixElement(self, orig_i, orig_j)\n         return self.blocks[row_block, col_block][i, j]\n \n     @property\n", "test_patch": "diff --git a/sympy/matrices/expressions/tests/test_blockmatrix.py b/sympy/matrices/expressions/tests/test_blockmatrix.py\n--- a/sympy/matrices/expressions/tests/test_blockmatrix.py\n+++ b/sympy/matrices/expressions/tests/test_blockmatrix.py\n@@ -192,7 +192,6 @@ def test_BlockDiagMatrix():\n def test_blockcut():\n     A = MatrixSymbol('A', n, m)\n     B = blockcut(A, (n/2, n/2), (m/2, m/2))\n-    assert A[i, j] == B[i, j]\n     assert B == BlockMatrix([[A[:n/2, :m/2], A[:n/2, m/2:]],\n                              [A[n/2:, :m/2], A[n/2:, m/2:]]])\n \ndiff --git a/sympy/matrices/expressions/tests/test_indexing.py b/sympy/matrices/expressions/tests/test_indexing.py\n--- a/sympy/matrices/expressions/tests/test_indexing.py\n+++ b/sympy/matrices/expressions/tests/test_indexing.py\n@@ -1,7 +1,7 @@\n from sympy import (symbols, MatrixSymbol, MatPow, BlockMatrix, KroneckerDelta,\n         Identity, ZeroMatrix, ImmutableMatrix, eye, Sum, Dummy, trace,\n         Symbol)\n-from sympy.testing.pytest import raises\n+from sympy.testing.pytest import raises, XFAIL\n from sympy.matrices.expressions.matexpr import MatrixElement, MatrixExpr\n \n k, l, m, n = symbols('k l m n', integer=True)\n@@ -83,6 +83,72 @@ def test_block_index():\n     assert BI.as_explicit().equals(eye(6))\n \n \n+def test_block_index_symbolic():\n+    # Note that these matrices may be zero-sized and indices may be negative, which causes\n+    # all naive simplifications given in the comments to be invalid\n+    A1 = MatrixSymbol('A1', n, k)\n+    A2 = MatrixSymbol('A2', n, l)\n+    A3 = MatrixSymbol('A3', m, k)\n+    A4 = MatrixSymbol('A4', m, l)\n+    A = BlockMatrix([[A1, A2], [A3, A4]])\n+    assert A[0, 0] == MatrixElement(A, 0, 0)  # Cannot be A1[0, 0]\n+    assert A[n - 1, k - 1] == A1[n - 1, k - 1]\n+    assert A[n, k] == A4[0, 0]\n+    assert A[n + m - 1, 0] == MatrixElement(A, n + m - 1, 0)  # Cannot be A3[m - 1, 0]\n+    assert A[0, k + l - 1] == MatrixElement(A, 0, k + l - 1)  # Cannot be A2[0, l - 1]\n+    assert A[n + m - 1, k + l - 1] == MatrixElement(A, n + m - 1, k + l - 1)  # Cannot be A4[m - 1, l - 1]\n+    assert A[i, j] == MatrixElement(A, i, j)\n+    assert A[n + i, k + j] == MatrixElement(A, n + i, k + j)  # Cannot be A4[i, j]\n+    assert A[n - i - 1, k - j - 1] == MatrixElement(A, n - i - 1, k - j - 1)  # Cannot be A1[n - i - 1, k - j - 1]\n+\n+\n+def test_block_index_symbolic_nonzero():\n+    # All invalid simplifications from test_block_index_symbolic() that become valid if all\n+    # matrices have nonzero size and all indices are nonnegative\n+    k, l, m, n = symbols('k l m n', integer=True, positive=True)\n+    i, j = symbols('i j', integer=True, nonnegative=True)\n+    A1 = MatrixSymbol('A1', n, k)\n+    A2 = MatrixSymbol('A2', n, l)\n+    A3 = MatrixSymbol('A3', m, k)\n+    A4 = MatrixSymbol('A4', m, l)\n+    A = BlockMatrix([[A1, A2], [A3, A4]])\n+    assert A[0, 0] == A1[0, 0]\n+    assert A[n + m - 1, 0] == A3[m - 1, 0]\n+    assert A[0, k + l - 1] == A2[0, l - 1]\n+    assert A[n + m - 1, k + l - 1] == A4[m - 1, l - 1]\n+    assert A[i, j] == MatrixElement(A, i, j)\n+    assert A[n + i, k + j] == A4[i, j]\n+    assert A[n - i - 1, k - j - 1] == A1[n - i - 1, k - j - 1]\n+    assert A[2 * n, 2 * k] == A4[n, k]\n+\n+\n+def test_block_index_large():\n+    n, m, k = symbols('n m k', integer=True, positive=True)\n+    i = symbols('i', integer=True, nonnegative=True)\n+    A1 = MatrixSymbol('A1', n, n)\n+    A2 = MatrixSymbol('A2', n, m)\n+    A3 = MatrixSymbol('A3', n, k)\n+    A4 = MatrixSymbol('A4', m, n)\n+    A5 = MatrixSymbol('A5', m, m)\n+    A6 = MatrixSymbol('A6', m, k)\n+    A7 = MatrixSymbol('A7', k, n)\n+    A8 = MatrixSymbol('A8', k, m)\n+    A9 = MatrixSymbol('A9', k, k)\n+    A = BlockMatrix([[A1, A2, A3], [A4, A5, A6], [A7, A8, A9]])\n+    assert A[n + i, n + i] == MatrixElement(A, n + i, n + i)\n+\n+\n+@XFAIL\n+def test_block_index_symbolic_fail():\n+    # To make this work, symbolic matrix dimensions would need to be somehow assumed nonnegative\n+    # even if the symbols aren't specified as such.  Then 2 * n < n would correctly evaluate to\n+    # False in BlockMatrix._entry()\n+    A1 = MatrixSymbol('A1', n, 1)\n+    A2 = MatrixSymbol('A2', m, 1)\n+    A = BlockMatrix([[A1], [A2]])\n+    assert A[2 * n, 0] == A2[n, 0]\n+\n+\n def test_slicing():\n     A.as_explicit()[0, :]  # does not raise an error\n \n", "problem_statement": "Wrong matrix element fetched from BlockMatrix\nGiven this code:\r\n```\r\nfrom sympy import *\r\nn, i = symbols('n, i', integer=True)\r\nA = MatrixSymbol('A', 1, 1)\r\nB = MatrixSymbol('B', n, 1)\r\nC = BlockMatrix([[A], [B]])\r\nprint('C is')\r\npprint(C)\r\nprint('C[i, 0] is')\r\npprint(C[i, 0])\r\n```\r\nI get this output:\r\n```\r\nC is\r\n\u23a1A\u23a4\r\n\u23a2 \u23a5\r\n\u23a3B\u23a6\r\nC[i, 0] is\r\n(A)[i, 0]\r\n```\r\n`(A)[i, 0]` is the wrong here. `C[i, 0]` should not be simplified as that element may come from either `A` or `B`.\n", "hints_text": "I was aware of the problem that the coordinates were loosely handled even if the matrix had symbolic dimensions\r\nI also think that `C[3, 0]` should be undefined because there is no guarantee that n is sufficiently large to contain elements.\n`C[3, 0]` should just stay unevaluated, since it might be valid (I assume that's what you mean by 'undefined'). It should be possible to handle some cases properly, for example `C[n, 0]` should return `B[n - 1, 0]`.\r\n\r\nIf I get some time I might have a go at it, seems to be a nice first PR.\r\n\r\n**EDIT:** Sorry that's not even true. If `n` is zero, then `C[n, 0]` is not `B[n - 1, 0]`.", "created_at": "2020-03-29T13:47:11Z", "version": "1.6", "FAIL_TO_PASS": "[\"test_block_index_symbolic\", \"test_block_index_symbolic_nonzero\", \"test_block_index_large\"]", "PASS_TO_PASS": "[\"test_bc_matmul\", \"test_bc_matadd\", \"test_bc_transpose\", \"test_bc_dist_diag\", \"test_block_plus_ident\", \"test_BlockMatrix\", \"test_block_collapse_explicit_matrices\", \"test_issue_17624\", \"test_issue_18618\", \"test_BlockMatrix_trace\", \"test_BlockMatrix_Determinant\", \"test_squareBlockMatrix\", \"test_BlockDiagMatrix\", \"test_blockcut\", \"test_reblock_2x2\", \"test_deblock\", \"test_symbolic_indexing\", \"test_add_index\", \"test_mul_index\", \"test_pow_index\", \"test_transpose_index\", \"test_Identity_index\", \"test_block_index\", \"test_slicing\", \"test_errors\", \"test_matrix_expression_to_indices\"]", "environment_setup_commit": "28b41c73c12b70d6ad9f6e45109a80649c4456da"}, "On branch master\nChanges not staged for commit:\n  (use \"git add <file>...\" to update what will be committed)\n  (use \"git restore <file>...\" to discard changes in working directory)\n\tmodified:   sympy/matrices/expressions/blockmatrix.py\n\nno changes added to commit (use \"git add\" and/or \"git commit -a\")\ncommit f9e030b57623bebdc2efa7f297c1b5ede08fcebf\nMerge: 3f305ce157 56e1a44c92\nAuthor: Chris Smith <smichr@gmail.com>\nDate:   Sat Mar 28 11:49:53 2020 -0500\n\n    Merge pull request #18990 from oscarbenjamin/pr_xfail_hanging_test\n    \n    test(series): XFAIL test that sometimes hangs\n\ndiff --git a/sympy/matrices/expressions/blockmatrix.py b/sympy/matrices/expressions/blockmatrix.py\nindex b821c42845..8ae120bb9d 100644\n--- a/sympy/matrices/expressions/blockmatrix.py\n+++ b/sympy/matrices/expressions/blockmatrix.py\n@@ -7,7 +7,7 @@\n from sympy.utilities import sift\n from sympy.utilities.misc import filldedent\n \n-from sympy.matrices.expressions.matexpr import MatrixExpr, ZeroMatrix, Identity\n+from sympy.matrices.expressions.matexpr import MatrixExpr, ZeroMatrix, Identity, MatrixElement\n from sympy.matrices.expressions.matmul import MatMul\n from sympy.matrices.expressions.matadd import MatAdd\n from sympy.matrices.expressions.matpow import MatPow\n@@ -234,16 +234,24 @@ def transpose(self):\n \n     def _entry(self, i, j, **kwargs):\n         # Find row entry\n+        orig_i, orig_j = i, j\n         for row_block, numrows in enumerate(self.rowblocksizes):\n-            if (i < numrows) != False:\n+            cmp = i < numrows\n+            if cmp == True:\n                 break\n-            else:\n+            elif cmp == False:\n                 i -= numrows\n+            elif row_block < self.blockshape[0] - 1:\n+                # Can't tell which block and it's not the last one, return unevaluated\n+                return MatrixElement(self, orig_i, orig_j)\n         for col_block, numcols in enumerate(self.colblocksizes):\n-            if (j < numcols) != False:\n+            cmp = j < numcols\n+            if cmp == True:\n                 break\n-            else:\n+            elif cmp == False:\n                 j -= numcols\n+            elif col_block < self.blockshape[1] - 1:\n+                return MatrixElement(self, orig_i, orig_j)\n         return self.blocks[row_block, col_block][i, j]\n \n     @property\nObtaining file:///testbed\n  Preparing metadata (setup.py): started\n  Preparing metadata (setup.py): finished with status 'done'\nRequirement already satisfied: mpmath>=0.19 in /opt/miniconda3/envs/testbed/lib/python3.9/site-packages (from sympy==1.6.dev0) (1.3.0)\nInstalling collected packages: sympy\n  Attempting uninstall: sympy\n    Found existing installation: sympy 1.6.dev0\n    Uninstalling sympy-1.6.dev0:\n      Successfully uninstalled sympy-1.6.dev0\n  Running setup.py develop for sympy\nSuccessfully installed sympy\n============================= test process starts ==============================\nexecutable:         /opt/miniconda3/envs/testbed/bin/python  (3.9.20-final-0) [CPython]\narchitecture:       64-bit\ncache:              no\nground types:       python \nnumpy:              None\nrandom seed:        55662157\nhash randomization: off\n\nsympy/matrices/expressions/tests/test_blockmatrix.py[17] \ntest_bc_matmul ok\ntest_bc_matadd ok\ntest_bc_transpose ok\ntest_bc_dist_diag ok\ntest_block_plus_ident ok\ntest_BlockMatrix ok\ntest_block_collapse_explicit_matrices ok\ntest_issue_17624 ok\ntest_issue_18618 ok\ntest_BlockMatrix_trace ok\ntest_BlockMatrix_Determinant ok\ntest_squareBlockMatrix ok\ntest_BlockDiagMatrix ok\ntest_blockcut ok\ntest_reblock_2x2 ok\ntest_deblock ok\ntest_block_collapse_type ok                                                 [OK]\n\nsympy/matrices/expressions/tests/test_indexing.py[15] \ntest_symbolic_indexing ok\ntest_add_index ok\ntest_mul_index ok\ntest_pow_index ok\ntest_transpose_index ok\ntest_Identity_index ok\ntest_block_index ok\ntest_block_index_symbolic ok\ntest_block_index_symbolic_nonzero ok\ntest_block_index_large ok\ntest_block_index_symbolic_fail f\ntest_slicing ok\ntest_errors ok\ntest_matrix_expression_to_indices ok\ntest_matrix_expression_from_index_summation ok                              [OK]\n\n\n======== tests finished: 31 passed, 1 expected to fail, in 0.66 seconds ========\n", {"test_bc_matmul": "PASSED", "test_bc_matadd": "PASSED", "test_bc_transpose": "PASSED", "test_bc_dist_diag": "PASSED", "test_block_plus_ident": "PASSED", "test_BlockMatrix": "PASSED", "test_block_collapse_explicit_matrices": "PASSED", "test_issue_17624": "PASSED", "test_issue_18618": "PASSED", "test_BlockMatrix_trace": "PASSED", "test_BlockMatrix_Determinant": "PASSED", "test_squareBlockMatrix": "PASSED", "test_BlockDiagMatrix": "PASSED", "test_blockcut": "PASSED", "test_reblock_2x2": "PASSED", "test_deblock": "PASSED", "test_symbolic_indexing": "PASSED", "test_add_index": "PASSED", "test_mul_index": "PASSED", "test_pow_index": "PASSED", "test_transpose_index": "PASSED", "test_Identity_index": "PASSED", "test_block_index": "PASSED", "test_block_index_symbolic": "PASSED", "test_block_index_symbolic_nonzero": "PASSED", "test_block_index_large": "PASSED", "test_slicing": "PASSED", "test_errors": "PASSED", "test_matrix_expression_to_indices": "PASSED"}]