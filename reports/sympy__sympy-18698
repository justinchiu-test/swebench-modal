[{"repo": "sympy/sympy", "instance_id": "sympy__sympy-18698", "base_commit": "3dff1b98a78f28c953ae2140b69356b8391e399c", "patch": "diff --git a/sympy/polys/polytools.py b/sympy/polys/polytools.py\n--- a/sympy/polys/polytools.py\n+++ b/sympy/polys/polytools.py\n@@ -2,7 +2,8 @@\n \n from __future__ import print_function, division\n \n-from functools import wraps\n+from functools import wraps, reduce\n+from operator import mul\n \n from sympy.core import (\n     S, Basic, Expr, I, Integer, Add, Mul, Dummy, Tuple\n@@ -5905,10 +5906,7 @@ def _symbolic_factor_list(expr, opt, method):\n         if arg.is_Number:\n             coeff *= arg\n             continue\n-        if arg.is_Mul:\n-            args.extend(arg.args)\n-            continue\n-        if arg.is_Pow:\n+        elif arg.is_Pow:\n             base, exp = arg.args\n             if base.is_Number and exp.is_Number:\n                 coeff *= arg\n@@ -5949,6 +5947,9 @@ def _symbolic_factor_list(expr, opt, method):\n                         other.append((f, k))\n \n                 factors.append((_factors_product(other), exp))\n+    if method == 'sqf':\n+        factors = [(reduce(mul, (f for f, _ in factors if _ == k)), k)\n+                   for k in set(i for _, i in factors)]\n \n     return coeff, factors\n \n", "test_patch": "diff --git a/sympy/polys/tests/test_polytools.py b/sympy/polys/tests/test_polytools.py\n--- a/sympy/polys/tests/test_polytools.py\n+++ b/sympy/polys/tests/test_polytools.py\n@@ -3273,7 +3273,7 @@ def test_to_rational_coeffs():\n def test_factor_terms():\n     # issue 7067\n     assert factor_list(x*(x + y)) == (1, [(x, 1), (x + y, 1)])\n-    assert sqf_list(x*(x + y)) == (1, [(x, 1), (x + y, 1)])\n+    assert sqf_list(x*(x + y)) == (1, [(x**2 + x*y, 1)])\n \n \n def test_as_list():\n@@ -3333,3 +3333,8 @@ def test_issue_17988():\n def test_issue_18205():\n     assert cancel((2 + I)*(3 - I)) == 7 + I\n     assert cancel((2 + I)*(2 - I)) == 5\n+\n+def test_issue_8695():\n+    p = (x**2 + 1) * (x - 1)**2 * (x - 2)**3 * (x - 3)**3\n+    result = (1, [(x**2 + 1, 1), (x - 1, 2), (x**2 - 5*x + 6, 3)])\n+    assert sqf_list(p) == result\n", "problem_statement": "sqf and sqf_list output is not consistant\nThe example below is wrong in the sense that we should have (x*_2 - 5_x + 6, 3) and not 2 factors of multiplicity 3.\n\n```\n>  sqf_list(  (x**2 + 1)  * (x - 1)**2 * (x - 2)**3 * (x - 3)**3  )\n\n>  (1, [(x**2 + 1, 1), (x - 1, 2), (x - 3, 3), (x - 2, 3)])\n```\n\nwhereas below is correct --- one factor of multiplicity 2\n\n```\n>  sqf_list( x**5 - 2*x**4 - 2*x**3 + 4*x**2 + x - 2 )\n\n>  (1, [(x - 2, 1), (x**2 - 1, 2)])\n```\n\n", "hints_text": "I guess correct can be either the first or the second. But we should stick to it.\n\nThis [SO post](https://stackoverflow.com/questions/57536689/sympys-sqf-and-sqf-list-give-different-results-once-i-use-poly-or-as-pol) highlights another problem, too:\r\n\r\n```python\r\n>>> v = (x1 + 2) ** 2 * (x2 + 4) ** 5\r\n>>> sqf(v)\r\n(x1 + 2)**2*(x2 + 4)**5\r\n>>> sqf(v.expand())\r\n(x1 + 2)**2  <-- where is the x2 factor?\r\n```\nThe documentation is incomplete. The docstrings for low level methods in `sqfreetools` show that they are for univariate polynomials only but that is missing from `polytools`. The docstrings should be amended.\r\n\r\nThe issue in OP is valid. The `Poly` method works as expected:\r\n```\r\n>>> Poly((x**2 + 1)*(x - 1)**2*(x - 2)**3*(x - 3)**3, x).sqf_list()\r\n(1, [(Poly(x**2 + 1, x, domain='ZZ'), 1), (Poly(x - 1, x, domain='ZZ'), 2), (Poly(x**2 - 5*x + 6, x, domain='ZZ'), 3)])\r\n```\r\nThe two factors of multiplicity 3 are combined as they should be.\r\n\r\nThe `sqf_list` function fails to do that.\r\n```\r\n>>> sqf_list((x**2 + 1)*(x - 1)**2*(x - 2)**3*(x - 3)**3, x)\r\n(1, [(x**2 + 1, 1), (x - 1, 2), (x - 3, 3), (x - 2, 3)])\r\n```\r\nIt should scan the generic factor list and combine factors of same multiplicity before returning the list.\r\nhttps://github.com/sympy/sympy/blob/e4259125f63727b76d0a0c4743ba1cd8d433d3ea/sympy/polys/polytools.py#L6218\nHi, I am new to the sympy community and was looking to contribute to the project. I wanted to ask @akritas what's wrong in having 2 factors of multiplicity 3? Also, if the second issue (on SO) is still open, then I would like to work on it, @jksuom can you guide me from where I should start? \n\n\nSent from my iPad\n\n> On 15 Dec 2019, at 5:24 PM, Akhil Rajput <notifications@github.com> wrote:\n> \n> \ufeff\n> Hi, I am new to the sympy community and was looking to contribute to the project. I wanted to ask @akritas what's wrong in having 2 factors of multiplicity 3?\n> \nHi, \n\nThe square free algorithm should pull out all factors of _same_ degree and present them as one product of given multiplicity (in this case one factor with roots of multiplicity 3).\n> Also, if the second issue (on SO) is still open, then I would like to work on it, @jksuom can you guide me from where I should start?\n> \n> \u2014\n> You are receiving this because you were mentioned.\n> Reply to this email directly, view it on GitHub, or unsubscribe.\n\nI would start with the docstrings. The squarefree methods are intended for univariate polynomials. The generator should be given as an input parameter. It may be omitted if there is no danger of confusion (only one symbol in the expression). Otherwise the result may be indeterminate as shown by the [example above](https://github.com/sympy/sympy/issues/8695#issuecomment-522278244).\n@jksuom, I'm still unclear. There is already an option to pass generators as an argument to sqf_list(). Should the function automatically find the generators present in the expression? Please guide me what should I do. \nIf there is only one symbol in the expression, then the function can find the generator automatically. Otherwise I think that exactly one symbol should be given as the generator.\r\n\r\nMoreover, I would like to change the implementations of `sqf_list()` and related functions so that they would be based on the corresponding `Poly` methods. Then they would start by converting the input expression into `p = Poly(f, *gens, **args)` and check that `p` has exactly one generator. Then `p.sqf_list()` etc, would be called.\nThen what will happen in case of multiple generators? Just confirming, generators here refer to symbols/variables.\n> generators here refer to symbols/variables.\r\n\r\nYes.\r\n> Then what will happen in case of multiple generators?\r\n\r\nI think that ValueError could be raised. It seems that some kind of result is currently returned but there is no documentation, and I don't know of any reasonable use where the ordinary factorization would not suffice.\n> If there is only one symbol in the expression, then the function can find the generator automatically. Otherwise I think that exactly one symbol should be given as the generator.\r\n> \r\n> Moreover, I would like to change the implementations of `sqf_list()` and related functions so that they would be based on the corresponding `Poly` methods. Then they would start by converting the input expression into `p = Poly(f, *gens, **args)` and check that `p` has exactly one generator. Then `p.sqf_list()` etc, would be called.\r\n\r\n@jksuom  In the helper function __symbolic_factor_list_ of sqf_list, the expression is already being converted to polynomial and then corresponding _sqf_list_ function is called. So, I should just ensure if the number of generators passed is one?\n> I should just ensure if the number of generators passed is one?\r\n\r\nIf there is exactly one generator passed, then it is possible to call `_generic_factor_list` with the given arguments. However, it is necessary to post-process the result. In the example above, it returns\r\n\r\n    (1, [(x**2 + 1, 1), (x - 1, 2), (x - 3, 3), (x - 2, 3)])\r\n\r\nwhile `sqf_list` should return only one polynomial for each power. Therefore the two threefold factors `x - 3` and `x - 2` should be combined to give a single `(x**2 - 5*x + 6, 3)`.\r\n\r\nIt is probably quite common that no generators are given, in particular, when the expression looks like a univariate polynomial. This should be acceptable but more work is then necessary to find the number of generators. I think that it is best to convert the expression to a `Poly` object to see the generators. If there is only one, then the `sqf_list` method can be called, otherwise a `ValueError` should be raised.\r\n\r\nIt is possible that the latter procedure will be more efficient even if a single generator is given.\n@jksuom I have created a PR (#18307)for the issue. I haven't done anything for multiple generator case as it was ambiguous. It would be great if you could review it. Thank you. \n@jksuom what can be done in case if the expression given is a constant (without any generators)? For example:  `sqf_list(1)`. We won't be able to construct a polynomial and PolificationFailed error will be raised.\nI think that the error can be raised. It is typical of many polynomial functions that they don't work with constant expressions.", "created_at": "2020-02-21T05:46:56Z", "version": "1.6", "FAIL_TO_PASS": "[\"test_factor_terms\"]", "PASS_TO_PASS": "[\"test_Poly_mixed_operations\", \"test_Poly_from_dict\", \"test_Poly_from_list\", \"test_Poly_from_poly\", \"test_Poly_from_expr\", \"test_Poly__new__\", \"test_Poly__args\", \"test_Poly__gens\", \"test_Poly_zero\", \"test_Poly_one\", \"test_Poly__unify\", \"test_Poly_free_symbols\", \"test_PurePoly_free_symbols\", \"test_Poly__eq__\", \"test_PurePoly__eq__\", \"test_PurePoly_Poly\", \"test_Poly_get_domain\", \"test_Poly_set_domain\", \"test_Poly_get_modulus\", \"test_Poly_set_modulus\", \"test_Poly_add_ground\", \"test_Poly_sub_ground\", \"test_Poly_mul_ground\", \"test_Poly_quo_ground\", \"test_Poly_exquo_ground\", \"test_Poly_abs\", \"test_Poly_neg\", \"test_Poly_add\", \"test_Poly_sub\", \"test_Poly_mul\", \"test_issue_13079\", \"test_Poly_sqr\", \"test_Poly_pow\", \"test_Poly_divmod\", \"test_Poly_eq_ne\", \"test_Poly_nonzero\", \"test_Poly_properties\", \"test_Poly_is_irreducible\", \"test_Poly_subs\", \"test_Poly_replace\", \"test_Poly_reorder\", \"test_Poly_ltrim\", \"test_Poly_has_only_gens\", \"test_Poly_to_ring\", \"test_Poly_to_field\", \"test_Poly_to_exact\", \"test_Poly_retract\", \"test_Poly_slice\", \"test_Poly_coeffs\", \"test_Poly_monoms\", \"test_Poly_terms\", \"test_Poly_all_coeffs\", \"test_Poly_all_monoms\", \"test_Poly_all_terms\", \"test_Poly_termwise\", \"test_Poly_length\", \"test_Poly_as_dict\", \"test_Poly_as_expr\", \"test_Poly_lift\", \"test_Poly_deflate\", \"test_Poly_inject\", \"test_Poly_eject\", \"test_Poly_exclude\", \"test_Poly__gen_to_level\", \"test_Poly_degree\", \"test_Poly_degree_list\", \"test_Poly_total_degree\", \"test_Poly_homogenize\", \"test_Poly_homogeneous_order\", \"test_Poly_LC\", \"test_Poly_TC\", \"test_Poly_EC\", \"test_Poly_coeff\", \"test_Poly_nth\", \"test_Poly_LM\", \"test_Poly_LM_custom_order\", \"test_Poly_EM\", \"test_Poly_LT\", \"test_Poly_ET\", \"test_Poly_max_norm\", \"test_Poly_l1_norm\", \"test_Poly_clear_denoms\", \"test_Poly_rat_clear_denoms\", \"test_Poly_integrate\", \"test_Poly_diff\", \"test_issue_9585\", \"test_Poly_eval\", \"test_Poly___call__\", \"test_parallel_poly_from_expr\", \"test_pdiv\", \"test_div\", \"test_issue_7864\", \"test_gcdex\", \"test_revert\", \"test_subresultants\", \"test_resultant\", \"test_discriminant\", \"test_dispersion\", \"test_gcd_list\", \"test_lcm_list\", \"test_gcd\", \"test_gcd_numbers_vs_polys\", \"test_terms_gcd\", \"test_trunc\", \"test_monic\", \"test_content\", \"test_primitive\", \"test_compose\", \"test_shift\", \"test_transform\", \"test_sturm\", \"test_gff\", \"test_norm\", \"test_sqf_norm\", \"test_sqf\", \"test_factor\", \"test_factor_large\", \"test_factor_noeval\", \"test_intervals\", \"test_refine_root\", \"test_count_roots\", \"test_Poly_root\", \"test_real_roots\", \"test_all_roots\", \"test_nroots\", \"test_ground_roots\", \"test_nth_power_roots_poly\", \"test_torational_factor_list\", \"test_cancel\", \"test_reduced\", \"test_groebner\", \"test_fglm\", \"test_is_zero_dimensional\", \"test_GroebnerBasis\", \"test_poly\", \"test_keep_coeff\", \"test_poly_matching_consistency\", \"test_noncommutative\", \"test_to_rational_coeffs\", \"test_as_list\", \"test_issue_11198\", \"test_Poly_precision\", \"test_issue_12400\", \"test_issue_14364\", \"test_issue_15669\", \"test_issue_17988\", \"test_issue_18205\"]", "environment_setup_commit": "28b41c73c12b70d6ad9f6e45109a80649c4456da"}, "On branch master\nChanges not staged for commit:\n  (use \"git add <file>...\" to update what will be committed)\n  (use \"git restore <file>...\" to discard changes in working directory)\n\tmodified:   sympy/polys/polytools.py\n\nno changes added to commit (use \"git add\" and/or \"git commit -a\")\ncommit 3dff1b98a78f28c953ae2140b69356b8391e399c\nMerge: 70bf1f88ff 0bbbc7738f\nAuthor: S.Y. Lee <sylee957@gmail.com>\nDate:   Fri Feb 21 12:04:16 2020 +0900\n\n    Merge pull request #18690 from mohitacecode/issue_18666_2\n    \n    migrate all the eigen-related test to test_eigen.py\n\ndiff --git a/sympy/polys/polytools.py b/sympy/polys/polytools.py\nindex c9e77a901f..68b69d1a24 100644\n--- a/sympy/polys/polytools.py\n+++ b/sympy/polys/polytools.py\n@@ -2,7 +2,8 @@\n \n from __future__ import print_function, division\n \n-from functools import wraps\n+from functools import wraps, reduce\n+from operator import mul\n \n from sympy.core import (\n     S, Basic, Expr, I, Integer, Add, Mul, Dummy, Tuple\n@@ -5905,10 +5906,7 @@ def _symbolic_factor_list(expr, opt, method):\n         if arg.is_Number:\n             coeff *= arg\n             continue\n-        if arg.is_Mul:\n-            args.extend(arg.args)\n-            continue\n-        if arg.is_Pow:\n+        elif arg.is_Pow:\n             base, exp = arg.args\n             if base.is_Number and exp.is_Number:\n                 coeff *= arg\n@@ -5949,6 +5947,9 @@ def _symbolic_factor_list(expr, opt, method):\n                         other.append((f, k))\n \n                 factors.append((_factors_product(other), exp))\n+    if method == 'sqf':\n+        factors = [(reduce(mul, (f for f, _ in factors if _ == k)), k)\n+                   for k in set(i for _, i in factors)]\n \n     return coeff, factors\n \nObtaining file:///testbed\n  Preparing metadata (setup.py): started\n  Preparing metadata (setup.py): finished with status 'done'\nRequirement already satisfied: mpmath>=0.19 in /opt/miniconda3/envs/testbed/lib/python3.9/site-packages (from sympy==1.6.dev0) (1.3.0)\nInstalling collected packages: sympy\n  Attempting uninstall: sympy\n    Found existing installation: sympy 1.6.dev0\n    Uninstalling sympy-1.6.dev0:\n      Successfully uninstalled sympy-1.6.dev0\n  Running setup.py develop for sympy\nSuccessfully installed sympy\n============================= test process starts ==============================\nexecutable:         /opt/miniconda3/envs/testbed/bin/python  (3.9.20-final-0) [CPython]\narchitecture:       64-bit\ncache:              no\nground types:       python \nnumpy:              None\nrandom seed:        56551756\nhash randomization: off\n\nsympy/polys/tests/test_polytools.py[150] \ntest_Poly_mixed_operations ok\ntest_Poly_from_dict ok\ntest_Poly_from_list ok\ntest_Poly_from_poly ok\ntest_Poly_from_expr ok\ntest_Poly__new__ ok\ntest_Poly__args ok\ntest_Poly__gens ok\ntest_Poly_zero ok\ntest_Poly_one ok\ntest_Poly__unify ok\ntest_Poly_free_symbols ok\ntest_PurePoly_free_symbols ok\ntest_Poly__eq__ ok\ntest_PurePoly__eq__ ok\ntest_PurePoly_Poly ok\ntest_Poly_get_domain ok\ntest_Poly_set_domain ok\ntest_Poly_get_modulus ok\ntest_Poly_set_modulus ok\ntest_Poly_add_ground ok\ntest_Poly_sub_ground ok\ntest_Poly_mul_ground ok\ntest_Poly_quo_ground ok\ntest_Poly_exquo_ground ok\ntest_Poly_abs ok\ntest_Poly_neg ok\ntest_Poly_add ok\ntest_Poly_sub ok\ntest_Poly_mul ok\ntest_issue_13079 ok\ntest_Poly_sqr ok\ntest_Poly_pow ok\ntest_Poly_divmod ok\ntest_Poly_eq_ne ok\ntest_Poly_nonzero ok\ntest_Poly_properties ok\ntest_Poly_is_irreducible ok\ntest_Poly_subs ok\ntest_Poly_replace ok\ntest_Poly_reorder ok\ntest_Poly_ltrim ok\ntest_Poly_has_only_gens ok\ntest_Poly_to_ring ok\ntest_Poly_to_field ok\ntest_Poly_to_exact ok\ntest_Poly_retract ok\ntest_Poly_slice ok\ntest_Poly_coeffs ok\ntest_Poly_monoms ok\ntest_Poly_terms ok\ntest_Poly_all_coeffs ok\ntest_Poly_all_monoms ok\ntest_Poly_all_terms ok\ntest_Poly_termwise ok\ntest_Poly_length ok\ntest_Poly_as_dict ok\ntest_Poly_as_expr ok\ntest_Poly_lift ok\ntest_Poly_deflate ok\ntest_Poly_inject ok\ntest_Poly_eject ok\ntest_Poly_exclude ok\ntest_Poly__gen_to_level ok\ntest_Poly_degree ok\ntest_Poly_degree_list ok\ntest_Poly_total_degree ok\ntest_Poly_homogenize ok\ntest_Poly_homogeneous_order ok\ntest_Poly_LC ok\ntest_Poly_TC ok\ntest_Poly_EC ok\ntest_Poly_coeff ok\ntest_Poly_nth ok\ntest_Poly_LM ok\ntest_Poly_LM_custom_order ok\ntest_Poly_EM ok\ntest_Poly_LT ok\ntest_Poly_ET ok\ntest_Poly_max_norm ok\ntest_Poly_l1_norm ok\ntest_Poly_clear_denoms ok\ntest_Poly_rat_clear_denoms ok\ntest_Poly_integrate ok\ntest_Poly_diff ok\ntest_issue_9585 ok\ntest_Poly_eval ok\ntest_Poly___call__ ok\ntest_parallel_poly_from_expr ok\ntest_pdiv ok\ntest_div ok\ntest_issue_7864 ok\ntest_gcdex ok\ntest_revert ok\ntest_subresultants ok\ntest_resultant ok\ntest_discriminant ok\ntest_dispersion ok\ntest_gcd_list ok\ntest_lcm_list ok\ntest_gcd ok\ntest_gcd_numbers_vs_polys ok\ntest_terms_gcd ok\ntest_trunc ok\ntest_monic ok\ntest_content ok\ntest_primitive ok\ntest_compose ok\ntest_shift ok\ntest_transform ok\ntest_sturm ok\ntest_gff ok\ntest_norm ok\ntest_sqf_norm ok\ntest_sqf ok\ntest_factor ok\ntest_factor_large ok\ntest_factor_noeval ok\ntest_intervals ok\ntest_refine_root ok\ntest_count_roots ok\ntest_Poly_root ok\ntest_real_roots ok\ntest_all_roots ok\ntest_nroots ok\ntest_ground_roots ok\ntest_nth_power_roots_poly ok\ntest_torational_factor_list ok\ntest_cancel ok\ntest_reduced ok\ntest_groebner ok\ntest_fglm ok\ntest_is_zero_dimensional ok\ntest_GroebnerBasis ok\ntest_poly ok\ntest_keep_coeff ok\ntest_poly_matching_consistency ok\ntest_issue_5786 f\ntest_noncommutative ok\ntest_to_rational_coeffs ok\ntest_factor_terms ok\ntest_as_list ok\ntest_issue_11198 ok\ntest_Poly_precision ok\ntest_issue_12400 ok\ntest_issue_14364 ok\ntest_issue_15669 ok\ntest_issue_17988 ok\ntest_issue_18205 ok\ntest_issue_8695 ok                                                          [OK]\n\n\n======= tests finished: 149 passed, 1 expected to fail, in 10.89 seconds =======\n", {"test_Poly_mixed_operations": "PASSED", "test_Poly_from_dict": "PASSED", "test_Poly_from_list": "PASSED", "test_Poly_from_poly": "PASSED", "test_Poly_from_expr": "PASSED", "test_Poly__new__": "PASSED", "test_Poly__args": "PASSED", "test_Poly__gens": "PASSED", "test_Poly_zero": "PASSED", "test_Poly_one": "PASSED", "test_Poly__unify": "PASSED", "test_Poly_free_symbols": "PASSED", "test_PurePoly_free_symbols": "PASSED", "test_Poly__eq__": "PASSED", "test_PurePoly__eq__": "PASSED", "test_PurePoly_Poly": "PASSED", "test_Poly_get_domain": "PASSED", "test_Poly_set_domain": "PASSED", "test_Poly_get_modulus": "PASSED", "test_Poly_set_modulus": "PASSED", "test_Poly_add_ground": "PASSED", "test_Poly_sub_ground": "PASSED", "test_Poly_mul_ground": "PASSED", "test_Poly_quo_ground": "PASSED", "test_Poly_exquo_ground": "PASSED", "test_Poly_abs": "PASSED", "test_Poly_neg": "PASSED", "test_Poly_add": "PASSED", "test_Poly_sub": "PASSED", "test_Poly_mul": "PASSED", "test_issue_13079": "PASSED", "test_Poly_sqr": "PASSED", "test_Poly_pow": "PASSED", "test_Poly_divmod": "PASSED", "test_Poly_eq_ne": "PASSED", "test_Poly_nonzero": "PASSED", "test_Poly_properties": "PASSED", "test_Poly_is_irreducible": "PASSED", "test_Poly_subs": "PASSED", "test_Poly_replace": "PASSED", "test_Poly_reorder": "PASSED", "test_Poly_ltrim": "PASSED", "test_Poly_has_only_gens": "PASSED", "test_Poly_to_ring": "PASSED", "test_Poly_to_field": "PASSED", "test_Poly_to_exact": "PASSED", "test_Poly_retract": "PASSED", "test_Poly_slice": "PASSED", "test_Poly_coeffs": "PASSED", "test_Poly_monoms": "PASSED", "test_Poly_terms": "PASSED", "test_Poly_all_coeffs": "PASSED", "test_Poly_all_monoms": "PASSED", "test_Poly_all_terms": "PASSED", "test_Poly_termwise": "PASSED", "test_Poly_length": "PASSED", "test_Poly_as_dict": "PASSED", "test_Poly_as_expr": "PASSED", "test_Poly_lift": "PASSED", "test_Poly_deflate": "PASSED", "test_Poly_inject": "PASSED", "test_Poly_eject": "PASSED", "test_Poly_exclude": "PASSED", "test_Poly__gen_to_level": "PASSED", "test_Poly_degree": "PASSED", "test_Poly_degree_list": "PASSED", "test_Poly_total_degree": "PASSED", "test_Poly_homogenize": "PASSED", "test_Poly_homogeneous_order": "PASSED", "test_Poly_LC": "PASSED", "test_Poly_TC": "PASSED", "test_Poly_EC": "PASSED", "test_Poly_coeff": "PASSED", "test_Poly_nth": "PASSED", "test_Poly_LM": "PASSED", "test_Poly_LM_custom_order": "PASSED", "test_Poly_EM": "PASSED", "test_Poly_LT": "PASSED", "test_Poly_ET": "PASSED", "test_Poly_max_norm": "PASSED", "test_Poly_l1_norm": "PASSED", "test_Poly_clear_denoms": "PASSED", "test_Poly_rat_clear_denoms": "PASSED", "test_Poly_integrate": "PASSED", "test_Poly_diff": "PASSED", "test_issue_9585": "PASSED", "test_Poly_eval": "PASSED", "test_Poly___call__": "PASSED", "test_parallel_poly_from_expr": "PASSED", "test_pdiv": "PASSED", "test_div": "PASSED", "test_issue_7864": "PASSED", "test_gcdex": "PASSED", "test_revert": "PASSED", "test_subresultants": "PASSED", "test_resultant": "PASSED", "test_discriminant": "PASSED", "test_dispersion": "PASSED", "test_gcd_list": "PASSED", "test_lcm_list": "PASSED", "test_gcd": "PASSED", "test_gcd_numbers_vs_polys": "PASSED", "test_terms_gcd": "PASSED", "test_trunc": "PASSED", "test_monic": "PASSED", "test_content": "PASSED", "test_primitive": "PASSED", "test_compose": "PASSED", "test_shift": "PASSED", "test_transform": "PASSED", "test_sturm": "PASSED", "test_gff": "PASSED", "test_norm": "PASSED", "test_sqf_norm": "PASSED", "test_sqf": "PASSED", "test_factor": "PASSED", "test_factor_large": "PASSED", "test_factor_noeval": "PASSED", "test_intervals": "PASSED", "test_refine_root": "PASSED", "test_count_roots": "PASSED", "test_Poly_root": "PASSED", "test_real_roots": "PASSED", "test_all_roots": "PASSED", "test_nroots": "PASSED", "test_ground_roots": "PASSED", "test_nth_power_roots_poly": "PASSED", "test_torational_factor_list": "PASSED", "test_cancel": "PASSED", "test_reduced": "PASSED", "test_groebner": "PASSED", "test_fglm": "PASSED", "test_is_zero_dimensional": "PASSED", "test_GroebnerBasis": "PASSED", "test_poly": "PASSED", "test_keep_coeff": "PASSED", "test_poly_matching_consistency": "PASSED", "test_noncommutative": "PASSED", "test_to_rational_coeffs": "PASSED", "test_factor_terms": "PASSED", "test_as_list": "PASSED", "test_issue_11198": "PASSED", "test_Poly_precision": "PASSED", "test_issue_12400": "PASSED", "test_issue_14364": "PASSED", "test_issue_15669": "PASSED", "test_issue_17988": "PASSED", "test_issue_18205": "PASSED"}]