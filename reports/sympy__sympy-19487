[{"repo": "sympy/sympy", "instance_id": "sympy__sympy-19487", "base_commit": "25fbcce5b1a4c7e3956e6062930f4a44ce95a632", "patch": "diff --git a/sympy/functions/elementary/complexes.py b/sympy/functions/elementary/complexes.py\n--- a/sympy/functions/elementary/complexes.py\n+++ b/sympy/functions/elementary/complexes.py\n@@ -394,6 +394,9 @@ def _eval_rewrite_as_Heaviside(self, arg, **kwargs):\n         if arg.is_extended_real:\n             return Heaviside(arg, H0=S(1)/2) * 2 - 1\n \n+    def _eval_rewrite_as_Abs(self, arg, **kwargs):\n+        return Piecewise((0, Eq(arg, 0)), (arg / Abs(arg), True))\n+\n     def _eval_simplify(self, **kwargs):\n         return self.func(self.args[0].factor())  # XXX include doit?\n \n", "test_patch": "diff --git a/sympy/core/tests/test_subs.py b/sympy/core/tests/test_subs.py\n--- a/sympy/core/tests/test_subs.py\n+++ b/sympy/core/tests/test_subs.py\n@@ -855,3 +855,10 @@ def test_issue_17823():\n def test_issue_19326():\n     x, y = [i(t) for i in map(Function, 'xy')]\n     assert (x*y).subs({x: 1 + x, y: x}) == (1 + x)*x\n+\n+def test_issue_19558():\n+    e = (7*x*cos(x) - 12*log(x)**3)*(-log(x)**4 + 2*sin(x) + 1)**2/ \\\n+    (2*(x*cos(x) - 2*log(x)**3)*(3*log(x)**4 - 7*sin(x) + 3)**2)\n+\n+    assert e.subs(x, oo) == AccumBounds(-oo, oo)\n+    assert (sin(x) + cos(x)).subs(x, oo) == AccumBounds(-2, 2)\ndiff --git a/sympy/functions/elementary/tests/test_complexes.py b/sympy/functions/elementary/tests/test_complexes.py\n--- a/sympy/functions/elementary/tests/test_complexes.py\n+++ b/sympy/functions/elementary/tests/test_complexes.py\n@@ -4,7 +4,7 @@\n     pi, Rational, re, S, sign, sin, sqrt, Symbol, symbols, transpose,\n     zoo, exp_polar, Piecewise, Interval, comp, Integral, Matrix,\n     ImmutableMatrix, SparseMatrix, ImmutableSparseMatrix, MatrixSymbol,\n-    FunctionMatrix, Lambda, Derivative)\n+    FunctionMatrix, Lambda, Derivative, Eq)\n from sympy.core.expr import unchanged\n from sympy.core.function import ArgumentIndexError\n from sympy.testing.pytest import XFAIL, raises\n@@ -296,11 +296,14 @@ def test_sign():\n     assert sign(Symbol('x', real=True, zero=False)).is_nonpositive is None\n \n     x, y = Symbol('x', real=True), Symbol('y')\n+    f = Function('f')\n     assert sign(x).rewrite(Piecewise) == \\\n         Piecewise((1, x > 0), (-1, x < 0), (0, True))\n     assert sign(y).rewrite(Piecewise) == sign(y)\n     assert sign(x).rewrite(Heaviside) == 2*Heaviside(x, H0=S(1)/2) - 1\n     assert sign(y).rewrite(Heaviside) == sign(y)\n+    assert sign(y).rewrite(Abs) == Piecewise((0, Eq(y, 0)), (y/Abs(y), True))\n+    assert sign(f(y)).rewrite(Abs) == Piecewise((0, Eq(f(y), 0)), (f(y)/Abs(f(y)), True))\n \n     # evaluate what can be evaluated\n     assert sign(exp_polar(I*pi)*pi) is S.NegativeOne\n", "problem_statement": "Rewrite sign as abs\nIn sympy the `sign` function is defined as\r\n```\r\n    sign(z)  :=  z / Abs(z)\r\n```\r\nfor all complex non-zero `z`. There should be a way to rewrite the sign in terms of `Abs` e.g.:\r\n```\r\n>>> sign(x).rewrite(Abs)                                                                                                                   \r\n x \r\n\u2500\u2500\u2500\r\n\u2502x\u2502\r\n```\r\nI'm not sure how the possibility of `x` being zero should be handled currently we have\r\n```\r\n>>> sign(0)                                                                                                                               \r\n0\r\n>>> 0 / Abs(0)                                                                                                                            \r\nnan\r\n```\r\nMaybe `sign(0)` should be `nan` as well. Otherwise maybe rewrite as Abs would have to be careful about the possibility of the arg being zero (that would make the rewrite fail in most cases).\n", "hints_text": "Getting nan for `sign(0)` would be pretty [non-intuitive](https://en.wikipedia.org/wiki/Sign_function) for any mathematical programmer given it's non-derivative definition.\r\n\r\nIf a rewrite request cannot be fulfilled under all conditions and the request was not for Piecewise, I think the rewrite should return None.\nActually I think it's fine if the rewrite doesn't always work. At least something like this could rewrite:\r\n```julia\r\nIn [2]: sign(1+I).rewrite(Abs)                                                                                                                 \r\nOut[2]: sign(1 + \u2148)\r\n```\nYou can use piecewise like\r\n```\r\nPiecewise(\r\n    (0, Eq(x, 0)),\r\n    (x / Abs(x), Ne(x, 0))\r\n)\r\n```\nOriginally this question comes from SO:\r\nhttps://stackoverflow.com/questions/61676438/integrating-and-deriving-absolute-functions-sympy/61681347#61681347\r\n\r\nThe original question was about `diff(Abs(x))`:\r\n```\r\nIn [2]: x = Symbol('x', real=True)                                                                                                             \r\n\r\nIn [3]: Abs(x).diff(x)                                                                                                                         \r\nOut[3]: sign(x)\r\n```\r\nMaybe the result from `diff` should be a `Piecewise` or at least an `ExprCondPair` guarding against `x=0`.\nThe problem is that real-valued functions like abs, re, im, arg,... are not holomorphic and have no complex derivative. See also https://github.com/sympy/sympy/issues/8502.\n@jksuom could we add conditions in the `Derivative` class of the functions module which would check if the expression is an instance of a non-holomorphic function, in such a case it could raise an error or in the case of `Abs` simply  check the domain. I believe all the classes in `sympy/functions/elementary/complexes.py` could be checked.\nWould it be possible to add an `_eval_derivative` method raising an error to those functions?\nWhen would it raise?\nIf the function is non-holomorphic, there is no derivative to be returned.\nThere is a reasonable derivative of `Abs` when defined over the reals though e.g.:\r\n```julia\r\nIn [1]: x = Symbol('x', real=True)                                                                                                \r\n\r\nIn [2]: Abs(x).diff(x)                                                                                                            \r\nOut[2]: sign(x)\r\n```\nMaybe there should be two functions, one defined on reals and the other on complexes.\n> Would it be possible to add an `_eval_derivative` method raising an error to those functions?\r\n\r\nIn the `Derivative` class in `sympy.function`?\r\n\r\n\r\n\r\n> When would it raise?\r\n\r\nAs suggested, if the function is non-holomorphic or in the case of `Abs()` it could be a check on the domain of the argument.\r\n\r\n\r\n> Maybe there should be two functions, one defined on reals and the other on complexes.\r\n\r\nI am not sure if there are any non-holomorphic functions on Real numbers. In my opinion only the `Abs()` function would fall in this case. Hence I think this could be done using one function only.\n```\r\ndef _eval_derivative(self, expr):\r\n    if isinstance(expr,[re, im, sign, arg, conjugate]):\r\n\traise TypeError(\"Derivative not possible for Non-Holomorphic functions\")\r\n    if isinstance(expr,Abs):\r\n\tif Abs.arg[0].free_symbols.is_complex:\r\n\t    raises TypeError(\"There is a complex argument which makes Abs non-holomorphic\")\r\n```\r\nThis is something I was thinking but I am not sure about it as `Derivative` class already has a method with the same name. I also think that appropriate changes also need to be made in the `fdiff()` method of the `Abs` class.\r\n@jksuom I wanted to know if there are more non-holomorphic functions in sympy/functions/elementary/complexes.py to which an error can be raised.\nThose functions in complexes.py have a `_eval_derivative` method. Maybe that would be the proper place for raising an error if that is desired.\nAre there any other examples of functions that raise when differentiated?\r\n\r\nI just tried\r\n```julia\r\nIn [83]: n = Symbol('n', integer=True, positive=True)                                                                             \r\n\r\nIn [84]: totient(n).diff(n)                                                                                                       \r\nOut[84]: \r\nd             \r\n\u2500\u2500(totient(n))\r\ndn \r\n```\n@oscarbenjamin I am not sure if this is a situation when it should raise, for example: if `n` here is a prime number the derivative wrt `n` would hence be `1` . Although in sympy \r\n```\r\n>>> x = Symbol('x', real=True, prime=True)\r\n>>> totient(x).evalf()\r\n\u03d5(x)\r\n```\r\nis the output and not `x-1`.Maybe this kind of functionality can be added.\r\n@jksuom I think your way is correct and wanted to ask if the error to be raised is appropriately `TypeError`?\nI don't think that the totient function should be differentiable. I was just trying to think of functions where it might be an error to differentiate them.\r\n\r\nI think it's better to leave the derivative of Abs unevaluated. You might have something like `Abs(f(x))` where `f` can be substituted for something reasonable later.\n@dhruvmendiratta6 Yes, I think that `TypeError` would be the appropriate choice. Note, however, that raising errors would probably break some tests. It may be desirable to add some try-except blocks to handle those properly.\nWhat about something like this:\r\n```julia\r\nIn [21]: x = Symbol('x', real=True)                                                                                               \r\n\r\nIn [22]: f = Function('f')                                                                                                        \r\n\r\nIn [23]: e = Derivative(Abs(f(x)), x)                                                                                             \r\n\r\nIn [24]: e                                                                                                                        \r\nOut[24]: \r\nd         \r\n\u2500\u2500(\u2502f(x)\u2502)\r\ndx        \r\n\r\nIn [25]: e.subs(f, cosh)                                                                                                          \r\nOut[25]: \r\nd          \r\n\u2500\u2500(cosh(x))\r\ndx         \r\n\r\nIn [26]: e.subs(f, cosh).doit()                                                                                                   \r\nOut[26]: sinh(x)\r\n```\n@jksuom @oscarbenjamin \r\nAny suggestion on how this can be done?\r\nI think changes need to be made here\r\nhttps://github.com/sympy/sympy/blob/7c11a00d4ace555e8be084d69c4da4e6f4975f64/sympy/functions/elementary/complexes.py#L605-L608\r\nto leave the derivative of `Abs` unevaluated. I tried changing this to \r\n```\r\ndef _eval_derivative(self, x):\r\n        if self.args[0].is_extended_real or self.args[0].is_imaginary:\r\n            return Derivative(self.args[0], x, evaluate=True) \\\r\n                * Derivative(self, x, evaluate=False)\r\n```\r\nwhich gives\r\n```\r\n>>> x = Symbol('x', real = True)\r\n>>> Abs(x**3).diff(x)\r\nx**2*Derivative(Abs(x), x) + 2*x*Abs(x)\r\n```\r\nBut then I can't figure out how to evaluate when the need arises.The above result,which I think is wrong, occurs even when no changes are made.\nI think rewrite in general can't avoid having situations where things are only defined correctly in the limit, unless we return a Piecewise. For example, `sinc(x).rewrite(sin)`.\n```py\r\n>>> pprint(sinc(x).rewrite(sin))\r\n\u23a7sin(x)\r\n\u23aa\u2500\u2500\u2500\u2500\u2500\u2500  for x \u2260 0\r\n\u23a8  x\r\n\u23aa\r\n\u23a9  1     otherwise\r\n```\nI made `_eval_rewrite_as_Abs()` for the `sign` class which gives the following:\r\n```\r\n>>> sign(x).rewrite(Abs)\r\nPiecewise((0, Eq(x, 0)), (x/Abs(x), True))\r\n```\r\nAlthough as discussed earlier raising an error in `_eval_derivative()` causes some tests to break :\r\n```\r\nFile \"c:\\users\\mendiratta\\sympy\\sympy\\functions\\elementary\\tests\\test_complexes.py\", line 414, in test_Abs\r\n    assert Abs(x).diff(x) == -sign(x)\r\n File \"c:\\users\\mendiratta\\sympy\\sympy\\functions\\elementary\\tests\\test_complexes.py\", line 833, in test_derivatives_issue_4757\r\n    assert Abs(f(x)).diff(x).subs(f(x), 1 + I*x).doit() == x/sqrt(1 + x**2)\r\n File \"c:\\users\\mendiratta\\sympy\\sympy\\functions\\elementary\\tests\\test_complexes.py\", line 969, in test_issue_15893\r\n    assert eq.doit() == sign(f(x))\r\n```\r\nThe first two are understood but in the third one both `f` and `x` are real and still are caught by the newly raised error which doesn't make sense as I raised a `TypeError` only if the argument is not real.", "created_at": "2020-06-04T09:25:34Z", "version": "1.7", "FAIL_TO_PASS": "[\"test_sign\"]", "PASS_TO_PASS": "[\"test_subs\", \"test_subs_Matrix\", \"test_subs_AccumBounds\", \"test_trigonometric\", \"test_powers\", \"test_logexppow\", \"test_bug\", \"test_subbug1\", \"test_subbug2\", \"test_dict_set\", \"test_dict_ambigous\", \"test_deriv_sub_bug3\", \"test_equality_subs1\", \"test_equality_subs2\", \"test_issue_3742\", \"test_subs_dict1\", \"test_mul\", \"test_subs_simple\", \"test_subs_constants\", \"test_subs_commutative\", \"test_subs_noncommutative\", \"test_subs_basic_funcs\", \"test_subs_wild\", \"test_subs_mixed\", \"test_division\", \"test_add\", \"test_subs_issue_4009\", \"test_functions_subs\", \"test_derivative_subs\", \"test_derivative_subs2\", \"test_derivative_subs3\", \"test_issue_5284\", \"test_subs_iter\", \"test_subs_dict\", \"test_no_arith_subs_on_floats\", \"test_issue_5651\", \"test_issue_6075\", \"test_issue_6079\", \"test_issue_4680\", \"test_issue_6158\", \"test_Function_subs\", \"test_simultaneous_subs\", \"test_issue_6419_6421\", \"test_issue_6559\", \"test_issue_5261\", \"test_issue_6923\", \"test_2arg_hack\", \"test_noncommutative_subs\", \"test_issue_2877\", \"test_issue_5910\", \"test_issue_5217\", \"test_issue_10829\", \"test_pow_eval_subs_no_cache\", \"test_RootOf_issue_10092\", \"test_issue_8886\", \"test_issue_12657\", \"test_recurse_Application_args\", \"test_Subs_subs\", \"test_issue_13333\", \"test_issue_15234\", \"test_issue_6976\", \"test_issue_11746\", \"test_issue_17823\", \"test_issue_19326\", \"test_re\", \"test_im\", \"test_as_real_imag\", \"test_Abs\", \"test_Abs_rewrite\", \"test_Abs_real\", \"test_Abs_properties\", \"test_abs\", \"test_arg\", \"test_arg_rewrite\", \"test_adjoint\", \"test_conjugate\", \"test_conjugate_transpose\", \"test_transpose\", \"test_polarify\", \"test_unpolarify\", \"test_issue_4035\", \"test_issue_3206\", \"test_issue_4754_derivative_conjugate\", \"test_derivatives_issue_4757\", \"test_issue_11413\", \"test_periodic_argument\", \"test_principal_branch\", \"test_issue_14216\", \"test_issue_14238\", \"test_zero_assumptions\"]", "environment_setup_commit": "cffd4e0f86fefd4802349a9f9b19ed70934ea354"}, "On branch master\nChanges not staged for commit:\n  (use \"git add <file>...\" to update what will be committed)\n  (use \"git restore <file>...\" to discard changes in working directory)\n\tmodified:   sympy/functions/elementary/complexes.py\n\nno changes added to commit (use \"git add\" and/or \"git commit -a\")\ncommit 25fbcce5b1a4c7e3956e6062930f4a44ce95a632\nMerge: 46469d714a 892b92a352\nAuthor: Chris Smith <smichr@gmail.com>\nDate:   Wed Jun 3 19:17:23 2020 -0500\n\n    Merge pull request #19483 from mohitshah3111999/pythonLover\n    \n    formatted docstring of sympy.geometry.curve according to documentation\n\ndiff --git a/sympy/functions/elementary/complexes.py b/sympy/functions/elementary/complexes.py\nindex 7fda45982b..27eefa7e7e 100644\n--- a/sympy/functions/elementary/complexes.py\n+++ b/sympy/functions/elementary/complexes.py\n@@ -394,6 +394,9 @@ def _eval_rewrite_as_Heaviside(self, arg, **kwargs):\n         if arg.is_extended_real:\n             return Heaviside(arg, H0=S(1)/2) * 2 - 1\n \n+    def _eval_rewrite_as_Abs(self, arg, **kwargs):\n+        return Piecewise((0, Eq(arg, 0)), (arg / Abs(arg), True))\n+\n     def _eval_simplify(self, **kwargs):\n         return self.func(self.args[0].factor())  # XXX include doit?\n \nObtaining file:///testbed\n  Preparing metadata (setup.py): started\n  Preparing metadata (setup.py): finished with status 'done'\nRequirement already satisfied: mpmath>=0.19 in /opt/miniconda3/envs/testbed/lib/python3.9/site-packages (from sympy==1.7.dev0) (1.3.0)\nInstalling collected packages: sympy\n  Attempting uninstall: sympy\n    Found existing installation: sympy 1.7.dev0\n    Uninstalling sympy-1.7.dev0:\n      Successfully uninstalled sympy-1.7.dev0\n  Running setup.py develop for sympy\nSuccessfully installed sympy\n============================= test process starts ==============================\nexecutable:         /opt/miniconda3/envs/testbed/bin/python  (3.9.20-final-0) [CPython]\narchitecture:       64-bit\ncache:              no\nground types:       python \nnumpy:              None\nrandom seed:        75745227\nhash randomization: off\n\nsympy/core/tests/test_subs.py[66] \ntest_subs ok\ntest_subs_Matrix ok\ntest_subs_AccumBounds ok\ntest_trigonometric ok\ntest_powers ok\ntest_logexppow ok\ntest_bug ok\ntest_subbug1 ok\ntest_subbug2 ok\ntest_dict_set ok\ntest_dict_ambigous ok\ntest_deriv_sub_bug3 ok\ntest_equality_subs1 ok\ntest_equality_subs2 ok\ntest_issue_3742 ok\ntest_subs_dict1 ok\ntest_mul ok\ntest_subs_simple ok\ntest_subs_constants ok\ntest_subs_commutative ok\ntest_subs_noncommutative ok\ntest_subs_basic_funcs ok\ntest_subs_wild ok\ntest_subs_mixed ok\ntest_division ok\ntest_add ok\ntest_subs_issue_4009 ok\ntest_functions_subs ok\ntest_derivative_subs ok\ntest_derivative_subs2 ok\ntest_derivative_subs3 ok\ntest_issue_5284 ok\ntest_subs_iter ok\ntest_subs_dict ok\ntest_no_arith_subs_on_floats ok\ntest_issue_5651 ok\ntest_issue_6075 ok\ntest_issue_6079 ok\ntest_issue_4680 ok\ntest_issue_6158 ok\ntest_Function_subs ok\ntest_simultaneous_subs ok\ntest_issue_6419_6421 ok\ntest_issue_6559 ok\ntest_issue_5261 ok\ntest_issue_6923 ok\ntest_2arg_hack ok\ntest_mul2 f\ntest_noncommutative_subs ok\ntest_issue_2877 ok\ntest_issue_5910 ok\ntest_issue_5217 ok\ntest_issue_10829 ok\ntest_pow_eval_subs_no_cache ok\ntest_RootOf_issue_10092 ok\ntest_issue_8886 ok\ntest_issue_12657 ok\ntest_recurse_Application_args ok\ntest_Subs_subs ok\ntest_issue_13333 ok\ntest_issue_15234 ok\ntest_issue_6976 ok\ntest_issue_11746 ok\ntest_issue_17823 ok\ntest_issue_19326 ok\ntest_issue_19558 ok                                                         [OK]\n\nsympy/functions/elementary/tests/test_complexes.py[31] \ntest_re ok\ntest_im ok\ntest_sign ok\ntest_as_real_imag ok\ntest_sign_issue_3068 f\ntest_Abs ok\ntest_Abs_rewrite ok\ntest_Abs_real ok\ntest_Abs_properties ok\ntest_abs ok\ntest_arg ok\ntest_arg_rewrite ok\ntest_adjoint ok\ntest_conjugate ok\ntest_conjugate_transpose ok\ntest_transpose ok\ntest_polarify ok\ntest_unpolarify ok\ntest_issue_4035 ok\ntest_issue_3206 ok\ntest_issue_4754_derivative_conjugate ok\ntest_derivatives_issue_4757 ok\ntest_issue_11413 ok\ntest_periodic_argument ok\ntest_principal_branch_fail f\ntest_principal_branch ok\ntest_issue_6167_6151 f\ntest_issue_14216 ok\ntest_issue_14238 ok\ntest_zero_assumptions ok\ntest_issue_15893 ok                                                         [OK]\n\n\n======= tests finished: 93 passed, 4 expected to fail, in 11.48 seconds ========\n", {"test_subs": "PASSED", "test_subs_Matrix": "PASSED", "test_subs_AccumBounds": "PASSED", "test_trigonometric": "PASSED", "test_powers": "PASSED", "test_logexppow": "PASSED", "test_bug": "PASSED", "test_subbug1": "PASSED", "test_subbug2": "PASSED", "test_dict_set": "PASSED", "test_dict_ambigous": "PASSED", "test_deriv_sub_bug3": "PASSED", "test_equality_subs1": "PASSED", "test_equality_subs2": "PASSED", "test_issue_3742": "PASSED", "test_subs_dict1": "PASSED", "test_mul": "PASSED", "test_subs_simple": "PASSED", "test_subs_constants": "PASSED", "test_subs_commutative": "PASSED", "test_subs_noncommutative": "PASSED", "test_subs_basic_funcs": "PASSED", "test_subs_wild": "PASSED", "test_subs_mixed": "PASSED", "test_division": "PASSED", "test_add": "PASSED", "test_subs_issue_4009": "PASSED", "test_functions_subs": "PASSED", "test_derivative_subs": "PASSED", "test_derivative_subs2": "PASSED", "test_derivative_subs3": "PASSED", "test_issue_5284": "PASSED", "test_subs_iter": "PASSED", "test_subs_dict": "PASSED", "test_no_arith_subs_on_floats": "PASSED", "test_issue_5651": "PASSED", "test_issue_6075": "PASSED", "test_issue_6079": "PASSED", "test_issue_4680": "PASSED", "test_issue_6158": "PASSED", "test_Function_subs": "PASSED", "test_simultaneous_subs": "PASSED", "test_issue_6419_6421": "PASSED", "test_issue_6559": "PASSED", "test_issue_5261": "PASSED", "test_issue_6923": "PASSED", "test_2arg_hack": "PASSED", "test_noncommutative_subs": "PASSED", "test_issue_2877": "PASSED", "test_issue_5910": "PASSED", "test_issue_5217": "PASSED", "test_issue_10829": "PASSED", "test_pow_eval_subs_no_cache": "PASSED", "test_RootOf_issue_10092": "PASSED", "test_issue_8886": "PASSED", "test_issue_12657": "PASSED", "test_recurse_Application_args": "PASSED", "test_Subs_subs": "PASSED", "test_issue_13333": "PASSED", "test_issue_15234": "PASSED", "test_issue_6976": "PASSED", "test_issue_11746": "PASSED", "test_issue_17823": "PASSED", "test_issue_19326": "PASSED", "test_re": "PASSED", "test_im": "PASSED", "test_sign": "PASSED", "test_as_real_imag": "PASSED", "test_Abs": "PASSED", "test_Abs_rewrite": "PASSED", "test_Abs_real": "PASSED", "test_Abs_properties": "PASSED", "test_abs": "PASSED", "test_arg": "PASSED", "test_arg_rewrite": "PASSED", "test_adjoint": "PASSED", "test_conjugate": "PASSED", "test_conjugate_transpose": "PASSED", "test_transpose": "PASSED", "test_polarify": "PASSED", "test_unpolarify": "PASSED", "test_issue_4035": "PASSED", "test_issue_3206": "PASSED", "test_issue_4754_derivative_conjugate": "PASSED", "test_derivatives_issue_4757": "PASSED", "test_issue_11413": "PASSED", "test_periodic_argument": "PASSED", "test_principal_branch": "PASSED", "test_issue_14216": "PASSED", "test_issue_14238": "PASSED", "test_zero_assumptions": "PASSED"}]