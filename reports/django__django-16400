[{"repo": "django/django", "instance_id": "django__django-16400", "base_commit": "0bd2c0c9015b53c41394a1c0989afbfd94dc2830", "patch": "diff --git a/django/contrib/auth/management/__init__.py b/django/contrib/auth/management/__init__.py\n--- a/django/contrib/auth/management/__init__.py\n+++ b/django/contrib/auth/management/__init__.py\n@@ -95,11 +95,16 @@ def create_permissions(\n         .values_list(\"content_type\", \"codename\")\n     )\n \n-    perms = [\n-        Permission(codename=codename, name=name, content_type=ct)\n-        for ct, (codename, name) in searched_perms\n-        if (ct.pk, codename) not in all_perms\n-    ]\n+    perms = []\n+    for ct, (codename, name) in searched_perms:\n+        if (ct.pk, codename) not in all_perms:\n+            permission = Permission()\n+            permission._state.db = using\n+            permission.codename = codename\n+            permission.name = name\n+            permission.content_type = ct\n+            perms.append(permission)\n+\n     Permission.objects.using(using).bulk_create(perms)\n     if verbosity >= 2:\n         for perm in perms:\n", "test_patch": "diff --git a/tests/auth_tests/test_management.py b/tests/auth_tests/test_management.py\n--- a/tests/auth_tests/test_management.py\n+++ b/tests/auth_tests/test_management.py\n@@ -1485,3 +1485,22 @@ def test_permission_with_proxy_content_type_created(self):\n                 codename=codename,\n             ).exists()\n         )\n+\n+\n+class DefaultDBRouter:\n+    \"\"\"Route all writes to default.\"\"\"\n+\n+    def db_for_write(self, model, **hints):\n+        return \"default\"\n+\n+\n+@override_settings(DATABASE_ROUTERS=[DefaultDBRouter()])\n+class CreatePermissionsMultipleDatabasesTests(TestCase):\n+    databases = {\"default\", \"other\"}\n+\n+    def test_set_permissions_fk_to_using_parameter(self):\n+        Permission.objects.using(\"other\").delete()\n+        with self.assertNumQueries(6, using=\"other\") as captured_queries:\n+            create_permissions(apps.get_app_config(\"auth\"), verbosity=0, using=\"other\")\n+        self.assertIn(\"INSERT INTO\", captured_queries[-1][\"sql\"].upper())\n+        self.assertGreater(Permission.objects.using(\"other\").count(), 0)\n", "problem_statement": "migrate management command does not respect database parameter when adding Permissions.\nDescription\n\t \n\t\t(last modified by Vasanth)\n\t \nWhen invoking migrate with a database parameter, the migration runs successfully. However, there seems to be a DB read request that runs after the migration. This call does not respect the db param and invokes the db router .\nWhen naming the db as a parameter, all DB calls in the context of the migrate command are expected to use the database specified.\nI came across this as I am currently using a thread-local variable to get the active DB with a custom DB router for a multi-tenant service .\nMinimal example \nSetup the custom middleware and custom DB Router as show below. Then run any DB migration. We see that \"read {}\" is being printed before the exception message.\nIdeally none of this code must be called as the DB was specified during management command.\nfrom threading import local\nfrom django.conf import settings\nlocal_state = local()\nclass InvalidTenantException(Exception):\n\tpass\nclass TenantSubdomainMiddleware:\n\tdef __init__(self, get_response):\n\t\tself.get_response = get_response\n\tdef __call__(self, request):\n\t\t## Get Subdomain\n\t\thost = request.get_host().split(\":\")[0]\n\t\tlocal_state.subdomain = (\n\t\t\t# We assume single level of subdomain : app.service.com \n\t\t\t# HOST_IP : used to for local dev. \n\t\t\thost if host in settings.HOST_IP else host.split(\".\")[0]\n\t\t)\n\t\tresponse = self.get_response(request)\n\t\treturn response\nclass TenantDatabaseRouter:\n\tdef _default_db(self):\n\t\tsubdomain = getattr(local_state, \"subdomain\", None)\n\t\tif subdomain is not None and subdomain in settings.TENANT_MAP:\n\t\t\tdb_name = settings.TENANT_MAP[local_state.subdomain]\n\t\t\treturn db_name\n\t\telse:\n\t\t\traise InvalidTenantException()\n\tdef db_for_read(self, model, **hints):\n\t\tprint(\"read\", hints)\n\t\treturn self._default_db()\n\tdef db_for_write(self, model, **hints):\n\t\tprint(\"write\", hints)\n\t\treturn self._default_db()\n\tdef allow_relation(self, obj1, obj2, **hints):\n\t\treturn None\n\tdef allow_migrate(self, db, app_label, model_name=None, **hints):\n\t\treturn None\n## settings.py\nMIDDLEWARE = [\n\t\"utils.tenant_db_router.TenantSubdomainMiddleware\",\n\t\"django.middleware.security.SecurityMiddleware\",\n\t...\n]\nTENANT_MAP = {\"localhost\":\"default\", \"tenant_1\":\"default\"}\nDATABASE_ROUTERS = [\"utils.tenant_db_router.TenantDatabaseRouter\"]\n", "hints_text": "Thanks for this report, it's related with adding missing permissions. I was able to fix this by setting _state.db, however I'm not convinced that it's the best solution: django/contrib/auth/management/__init__.py diff --git a/django/contrib/auth/management/__init__.py b/django/contrib/auth/management/__init__.py index 0b5a982617..27fe0df1d7 100644 a b def create_permissions( 9494 ) 9595 .values_list(\"content_type\", \"codename\") 9696 ) 97 98 perms = [ 99 Permission(codename=codename, name=name, content_type=ct) 100 for ct, (codename, name) in searched_perms 101 if (ct.pk, codename) not in all_perms 102 ] 97 perms = [] 98 for ct, (codename, name) in searched_perms: 99 if (ct.pk, codename) not in all_perms: 100 permission = Permission() 101 permission._state.db = using 102 permission.codename = codename 103 permission.name = name 104 permission.content_type = ct 105 perms.append(permission) 103106 Permission.objects.using(using).bulk_create(perms) 104107 if verbosity >= 2: 105108 for perm in perms: Partly related to #29843.\nThis patch resolves the problem at my end. I hope it can be added in the 4.1.4 since #29843 seems to be not actively worked on at the moment.\nAfter diving a bit deeper it turned out that the issue was with one of the libraries in my project which was not adapted for multi-DB. I've made a PR with changes on the django-admin-interface which resolved my issue.\nAryan, this ticket doesn't have submitted PR.\nReplying to Mariusz Felisiak: Thanks for this report, it's related with adding missing permissions. I was able to fix this by setting _state.db, however I'm not convinced that it's the best solution: django/contrib/auth/management/__init__.py diff --git a/django/contrib/auth/management/__init__.py b/django/contrib/auth/management/__init__.py index 0b5a982617..27fe0df1d7 100644 a b def create_permissions( 9494 ) 9595 .values_list(\"content_type\", \"codename\") 9696 ) 97 98 perms = [ 99 Permission(codename=codename, name=name, content_type=ct) 100 for ct, (codename, name) in searched_perms 101 if (ct.pk, codename) not in all_perms 102 ] 97 perms = [] 98 for ct, (codename, name) in searched_perms: 99 if (ct.pk, codename) not in all_perms: 100 permission = Permission() 101 permission._state.db = using 102 permission.codename = codename 103 permission.name = name 104 permission.content_type = ct 105 perms.append(permission) 103106 Permission.objects.using(using).bulk_create(perms) 104107 if verbosity >= 2: 105108 for perm in perms: Partly related to #29843. I think bulk_create already sets the _state.db to the value passed in .using(), right? Or is it in bulk_create that we require _state.db to be set earlier? In which case, we could perhaps change something inside of this method. Replying to Vasanth: After diving a bit deeper it turned out that the issue was with one of the libraries in my project which was not adapted for multi-DB. I've made a PR with changes on the django-admin-interface which resolved my issue. So would it be relevant to close the issue or is the bug really related to Django itself?\nReplying to David Wobrock: I think bulk_create already sets the _state.db to the value passed in .using(), right? Yes, but it's a different issue, strictly related with Permission and its content_type. get_content_type() is trying to find a content type using obj._state.db so when we create a Permission() without ._state.db it will first try to find a content type in the default db. So would it be relevant to close the issue or is the bug really related to Django itself? IMO we should fix this for permissions.\nReplying to Mariusz Felisiak: Replying to David Wobrock: I think bulk_create already sets the _state.db to the value passed in .using(), right? Yes, but it's a different issue, strictly related with Permission and its content_type. get_content_type() is trying to find a content type using obj._state.db so when we create a Permission() without ._state.db it will first try to find a content type in the default db. Okay, I understand the issue now, thanks for the details!! First thing, it makes me wonder why we require to have a DB attribute set, at a moment where we are not (yet) interacting with the DB. So we are currently checking, when setting the content_type FK, that the router allows this relation. I guess one option is to not do that for not-saved model instances. Would it make sense to defer this to when we start interacting with the DB? But it brings a whole other lot of changes and challenges, like changing a deep behaviour of FKs and multi-tenancy :/ Apart from that, if we don't want to set directly the internal attribute _state.db, I guess we would need a proper way to pass the db/using to the model instantiation. What would be the most Django-y way? Passing it through the model constructor => this has quite a large impact, as a keyword argument would possibly shadow existing field names: Permission(..., db=using). Quite risky in terms of backward compatibility I guess. Adding a method to Model? Something like: Permission(...).using(db), which could perhaps then be re-used in other places also. (EDIT: which wouldn't work, as the setting the FK happens before setting the DB alias.) What do you think ? :) Or am I missing other solutions?\nApart from that, if we don't want to set directly the internal attribute _state.db, I guess we would need a proper way to pass the db/using to the model instantiation. _state is \u200bdocumented so using it is not so bad. What would be the most Django-y way? Passing it through the model constructor => this has quite a large impact, as a keyword argument would possibly shadow existing field names: Permission(..., db=using). Quite risky in terms of backward compatibility I guess. Adding a method to Model? Something like: Permission(...).using(db), which could perhaps then be re-used in other places also. What do you think ? :) Or am I missing other solutions? Django doesn't support cross-db relationships and users were always responsible for assigning related objects from the same db. I don't think that we should add more logic to do this. The Permission-content_type issue is really an edge case in managing relations, as for me we don't need a generic solution for it.", "created_at": "2022-12-23T17:17:00Z", "version": "4.2", "FAIL_TO_PASS": "[\"test_set_permissions_fk_to_using_parameter (auth_tests.test_management.CreatePermissionsMultipleDatabasesTests)\"]", "PASS_TO_PASS": "[\"test_actual_implementation (auth_tests.test_management.GetDefaultUsernameTestCase)\", \"test_existing (auth_tests.test_management.GetDefaultUsernameTestCase)\", \"test_i18n (auth_tests.test_management.GetDefaultUsernameTestCase)\", \"test_simple (auth_tests.test_management.GetDefaultUsernameTestCase)\", \"test_with_database (auth_tests.test_management.GetDefaultUsernameTestCase)\", \"test_input_not_found (auth_tests.test_management.MockInputTests)\", \"changepassword --database should operate on the specified DB.\", \"`post_migrate` handler ordering isn't guaranteed. Simulate a case\", \"test_default_permissions (auth_tests.test_management.CreatePermissionsTests)\", \"A proxy model's permissions use its own content type rather than the\", \"#24075 - Permissions shouldn't be created or deleted if the ContentType\", \"test_createsuperuser_command_suggested_username_with_database_option (auth_tests.test_management.MultiDBCreatesuperuserTestCase)\", \"createsuperuser --database should operate on the specified DB.\", \"test_get_pass (auth_tests.test_management.ChangepasswordManagementCommandTestCase)\", \"test_get_pass_no_input (auth_tests.test_management.ChangepasswordManagementCommandTestCase)\", \"test_nonexistent_username (auth_tests.test_management.ChangepasswordManagementCommandTestCase)\", \"A CommandError should be raised if the user enters in passwords which\", \"The system username is used if --username isn't provided.\", \"Executing the changepassword management command should change joe's password\", \"#21627 -- Executing the changepassword management command should allow\", \"A CommandError should be thrown by handle() if the user enters in\", \"Check the operation of the createsuperuser management command\", \"Creation fails if --username is blank.\", \"test_blank_username_non_interactive (auth_tests.test_management.CreatesuperuserManagementCommandTestCase)\", \"createsuperuser uses a default username when one isn't provided.\", \"test_email_in_username (auth_tests.test_management.CreatesuperuserManagementCommandTestCase)\", \"test_environment_variable_m2m_non_interactive (auth_tests.test_management.CreatesuperuserManagementCommandTestCase)\", \"test_environment_variable_non_interactive (auth_tests.test_management.CreatesuperuserManagementCommandTestCase)\", \"Creation fails if the username already exists.\", \"Creation fails if the username already exists and a custom user model\", \"call_command() gets username='janet' and interactive=True.\", \"test_fields_with_fk (auth_tests.test_management.CreatesuperuserManagementCommandTestCase)\", \"test_fields_with_fk_interactive (auth_tests.test_management.CreatesuperuserManagementCommandTestCase)\", \"test_fields_with_fk_via_option_interactive (auth_tests.test_management.CreatesuperuserManagementCommandTestCase)\", \"test_fields_with_m2m (auth_tests.test_management.CreatesuperuserManagementCommandTestCase)\", \"test_fields_with_m2m_and_through (auth_tests.test_management.CreatesuperuserManagementCommandTestCase)\", \"test_fields_with_m2m_interactive (auth_tests.test_management.CreatesuperuserManagementCommandTestCase)\", \"test_fields_with_m2m_interactive_blank (auth_tests.test_management.CreatesuperuserManagementCommandTestCase)\", \"test_ignore_environment_variable_interactive (auth_tests.test_management.CreatesuperuserManagementCommandTestCase)\", \"test_ignore_environment_variable_non_interactive (auth_tests.test_management.CreatesuperuserManagementCommandTestCase)\", \"Creation fails if the username fails validation.\", \"test_keyboard_interrupt (auth_tests.test_management.CreatesuperuserManagementCommandTestCase)\", \"test_no_email_argument (auth_tests.test_management.CreatesuperuserManagementCommandTestCase)\", \"test_non_ascii_verbose_name (auth_tests.test_management.CreatesuperuserManagementCommandTestCase)\", \"You can pass a stdin object as an option and it should be\", \"Creation should fail if the password fails validation.\", \"Password validation can be bypassed by entering 'y' at the prompt.\", \"If the command is not called from a TTY, it should be skipped and a\", \"A superuser can be created when a custom user model is in use\", \"A Custom superuser won't be created when a required field isn't provided\", \"test_swappable_user_username_non_unique (auth_tests.test_management.CreatesuperuserManagementCommandTestCase)\", \"test_usermodel_without_password (auth_tests.test_management.CreatesuperuserManagementCommandTestCase)\", \"test_usermodel_without_password_interactive (auth_tests.test_management.CreatesuperuserManagementCommandTestCase)\", \"test_validate_fk (auth_tests.test_management.CreatesuperuserManagementCommandTestCase)\", \"test_validate_fk_environment_variable (auth_tests.test_management.CreatesuperuserManagementCommandTestCase)\", \"test_validate_fk_via_option_interactive (auth_tests.test_management.CreatesuperuserManagementCommandTestCase)\", \"test_validate_password_against_required_fields (auth_tests.test_management.CreatesuperuserManagementCommandTestCase)\", \"test_validate_password_against_required_fields_via_option (auth_tests.test_management.CreatesuperuserManagementCommandTestCase)\", \"test_validate_password_against_username (auth_tests.test_management.CreatesuperuserManagementCommandTestCase)\", \"test_validate_username (auth_tests.test_management.CreatesuperuserManagementCommandTestCase)\", \"Creation should fail if the user enters blank passwords.\", \"Creation should fail if the user enters mismatched passwords.\", \"test_verbosity_zero (auth_tests.test_management.CreatesuperuserManagementCommandTestCase)\"]", "environment_setup_commit": "0fbdb9784da915fce5dcc1fe82bac9b4785749e5"}, "On branch main\nChanges not staged for commit:\n  (use \"git add <file>...\" to update what will be committed)\n  (use \"git restore <file>...\" to discard changes in working directory)\n\tmodified:   django/contrib/auth/management/__init__.py\n\nno changes added to commit (use \"git add\" and/or \"git commit -a\")\ncommit 0bd2c0c9015b53c41394a1c0989afbfd94dc2830\nAuthor: Carlton Gibson <carlton.gibson@noumenal.es>\nDate:   Tue Dec 13 16:15:25 2022 +0100\n\n    Fixed #33735 -- Added async support to StreamingHttpResponse.\n    \n    Thanks to Florian Vazelle for initial exploratory work, and to Nick\n    Pope and Mariusz Felisiak for review.\n\ndiff --git a/django/core/handlers/asgi.py b/django/core/handlers/asgi.py\nindex b5372a1d49..f0125e7321 100644\n--- a/django/core/handlers/asgi.py\n+++ b/django/core/handlers/asgi.py\n@@ -19,6 +19,7 @@ from django.http import (\n     parse_cookie,\n )\n from django.urls import set_script_prefix\n+from django.utils.asyncio import aclosing\n from django.utils.functional import cached_property\n \n logger = logging.getLogger(\"django.request\")\n@@ -263,19 +264,22 @@ class ASGIHandler(base.BaseHandler):\n         )\n         # Streaming responses need to be pinned to their iterator.\n         if response.streaming:\n-            # Access `__iter__` and not `streaming_content` directly in case\n-            # it has been overridden in a subclass.\n-            for part in response:\n-                for chunk, _ in self.chunk_bytes(part):\n-                    await send(\n-                        {\n-                            \"type\": \"http.response.body\",\n-                            \"body\": chunk,\n-                            # Ignore \"more\" as there may be more parts; instead,\n-                            # use an empty final closing message with False.\n-                            \"more_body\": True,\n-                        }\n-                    )\n+            # - Consume via `__aiter__` and not `streaming_content` directly, to\n+            #   allow mapping of a sync iterator.\n+            # - Use aclosing() when consuming aiter.\n+            #   See https://github.com/python/cpython/commit/6e8dcda\n+            async with aclosing(response.__aiter__()) as content:\n+                async for part in content:\n+                    for chunk, _ in self.chunk_bytes(part):\n+                        await send(\n+                            {\n+                                \"type\": \"http.response.body\",\n+                                \"body\": chunk,\n+                                # Ignore \"more\" as there may be more parts; instead,\n+                                # use an empty final closing message with False.\n+                                \"more_body\": True,\n+                            }\n+                        )\n             # Final closing message.\n             await send({\"type\": \"http.response.body\"})\n         # Other responses just need chunking.\ndiff --git a/django/http/response.py b/django/http/response.py\nindex 3c281f3dd0..465a8553dc 100644\n--- a/django/http/response.py\n+++ b/django/http/response.py\n@@ -6,10 +6,13 @@ import os\n import re\n import sys\n import time\n+import warnings\n from email.header import Header\n from http.client import responses\n from urllib.parse import urlparse\n \n+from asgiref.sync import async_to_sync, sync_to_async\n+\n from django.conf import settings\n from django.core import signals, signing\n from django.core.exceptions import DisallowedRedirect\n@@ -476,7 +479,18 @@ class StreamingHttpResponse(HttpResponseBase):\n \n     @property\n     def streaming_content(self):\n-        return map(self.make_bytes, self._iterator)\n+        if self.is_async:\n+            # pull to lexical scope to capture fixed reference in case\n+            # streaming_content is set again later.\n+            _iterator = self._iterator\n+\n+            async def awrapper():\n+                async for part in _iterator:\n+                    yield self.make_bytes(part)\n+\n+            return awrapper()\n+        else:\n+            return map(self.make_bytes, self._iterator)\n \n     @streaming_content.setter\n     def streaming_content(self, value):\n@@ -484,12 +498,48 @@ class StreamingHttpResponse(HttpResponseBase):\n \n     def _set_streaming_content(self, value):\n         # Ensure we can never iterate on \"value\" more than once.\n-        self._iterator = iter(value)\n+        try:\n+            self._iterator = iter(value)\n+            self.is_async = False\n+        except TypeError:\n+            self._iterator = value.__aiter__()\n+            self.is_async = True\n         if hasattr(value, \"close\"):\n             self._resource_closers.append(value.close)\n \n     def __iter__(self):\n-        return self.streaming_content\n+        try:\n+            return iter(self.streaming_content)\n+        except TypeError:\n+            warnings.warn(\n+                \"StreamingHttpResponse must consume asynchronous iterators in order to \"\n+                \"serve them synchronously. Use a synchronous iterator instead.\",\n+                Warning,\n+            )\n+\n+            # async iterator. Consume in async_to_sync and map back.\n+            async def to_list(_iterator):\n+                as_list = []\n+                async for chunk in _iterator:\n+                    as_list.append(chunk)\n+                return as_list\n+\n+            return map(self.make_bytes, iter(async_to_sync(to_list)(self._iterator)))\n+\n+    async def __aiter__(self):\n+        try:\n+            async for part in self.streaming_content:\n+                yield part\n+        except TypeError:\n+            warnings.warn(\n+                \"StreamingHttpResponse must consume synchronous iterators in order to \"\n+                \"serve them asynchronously. Use an asynchronous iterator instead.\",\n+                Warning,\n+            )\n+            # sync iterator. Consume via sync_to_async and yield via async\n+            # generator.\n+            for part in await sync_to_async(list)(self.streaming_content):\n+                yield part\n \n     def getvalue(self):\n         return b\"\".join(self.streaming_content)\ndiff --git a/django/middleware/gzip.py b/django/middleware/gzip.py\nindex d91246c007..45be6ccb43 100644\n--- a/django/middleware/gzip.py\n+++ b/django/middleware/gzip.py\n@@ -31,12 +31,26 @@ class GZipMiddleware(MiddlewareMixin):\n             return response\n \n         if response.streaming:\n+            if response.is_async:\n+                # pull to lexical scope to capture fixed reference in case\n+                # streaming_content is set again later.\n+                orignal_iterator = response.streaming_content\n+\n+                async def gzip_wrapper():\n+                    async for chunk in orignal_iterator:\n+                        yield compress_string(\n+                            chunk,\n+                            max_random_bytes=self.max_random_bytes,\n+                        )\n+\n+                response.streaming_content = gzip_wrapper()\n+            else:\n+                response.streaming_content = compress_sequence(\n+                    response.streaming_content,\n+                    max_random_bytes=self.max_random_bytes,\n+                )\n             # Delete the `Content-Length` header for streaming content, because\n             # we won't know the compressed size until we stream it.\n-            response.streaming_content = compress_sequence(\n-                response.streaming_content,\n-                max_random_bytes=self.max_random_bytes,\n-            )\n             del response.headers[\"Content-Length\"]\n         else:\n             # Return the compressed content only if it's actually shorter.\ndiff --git a/django/utils/asyncio.py b/django/utils/asyncio.py\nindex 1e79f90c2c..eea2df48e2 100644\n--- a/django/utils/asyncio.py\n+++ b/django/utils/asyncio.py\n@@ -37,3 +37,28 @@ def async_unsafe(message):\n         return decorator(func)\n     else:\n         return decorator\n+\n+\n+try:\n+    from contextlib import aclosing\n+except ImportError:\n+    # TODO: Remove when dropping support for PY39.\n+    from contextlib import AbstractAsyncContextManager\n+\n+    # Backport of contextlib.aclosing() from Python 3.10. Copyright (C) Python\n+    # Software Foundation (see LICENSE.python).\n+    class aclosing(AbstractAsyncContextManager):\n+        \"\"\"\n+        Async context manager for safely finalizing an asynchronously\n+        cleaned-up resource such as an async generator, calling its\n+        ``aclose()`` method.\n+        \"\"\"\n+\n+        def __init__(self, thing):\n+            self.thing = thing\n+\n+        async def __aenter__(self):\n+            return self.thing\n+\n+        async def __aexit__(self, *exc_info):\n+            await self.thing.aclose()\ndiff --git a/docs/ref/request-response.txt b/docs/ref/request-response.txt\nindex 34a31c4936..ebcd9ee523 100644\n--- a/docs/ref/request-response.txt\n+++ b/docs/ref/request-response.txt\n@@ -1116,43 +1116,76 @@ parameter to the constructor method::\n .. class:: StreamingHttpResponse\n \n The :class:`StreamingHttpResponse` class is used to stream a response from\n-Django to the browser. You might want to do this if generating the response\n-takes too long or uses too much memory. For instance, it's useful for\n-:ref:`generating large CSV files <streaming-csv-files>`.\n+Django to the browser.\n \n-.. admonition:: Performance considerations\n+.. admonition:: Advanced usage\n \n-    Django is designed for short-lived requests. Streaming responses will tie\n-    a worker process for the entire duration of the response. This may result\n-    in poor performance.\n+    :class:`StreamingHttpResponse` is somewhat advanced, in that it is\n+    important to know whether you'll be serving your application synchronously\n+    under WSGI or asynchronously under ASGI, and adjust your usage\n+    appropriately.\n \n-    Generally speaking, you should perform expensive tasks outside of the\n-    request-response cycle, rather than resorting to a streamed response.\n+    Please read these notes with care.\n+\n+An example usage of :class:`StreamingHttpResponse` under WSGI is streaming\n+content when generating the response would take too long or uses too much\n+memory. For instance, it's useful for :ref:`generating large CSV files\n+<streaming-csv-files>`.\n+\n+There are performance considerations when doing this, though. Django, under\n+WSGI, is designed for short-lived requests. Streaming responses will tie a\n+worker process for the entire duration of the response. This may result in poor\n+performance.\n+\n+Generally speaking, you would perform expensive tasks outside of the\n+request-response cycle, rather than resorting to a streamed response.\n+\n+When serving under ASGI, however, a :class:`StreamingHttpResponse` need not\n+stop other requests from being served whilst waiting for I/O. This opens up\n+the possibility of long-lived requests for streaming content and implementing\n+patterns such as long-polling, and server-sent events.\n+\n+Even under ASGI note, :class:`StreamingHttpResponse` should only be used in\n+situations where it is absolutely required that the whole content isn't\n+iterated before transferring the data to the client. Because the content can't\n+be accessed, many middleware can't function normally. For example the ``ETag``\n+and ``Content-Length`` headers can't be generated for streaming responses.\n \n The :class:`StreamingHttpResponse` is not a subclass of :class:`HttpResponse`,\n because it features a slightly different API. However, it is almost identical,\n with the following notable differences:\n \n-* It should be given an iterator that yields bytestrings as content.\n+* It should be given an iterator that yields bytestrings as content. When\n+  serving under WSGI, this should be a sync iterator. When serving under ASGI,\n+  this is should an async iterator.\n \n * You cannot access its content, except by iterating the response object\n-  itself. This should only occur when the response is returned to the client.\n+  itself. This should only occur when the response is returned to the client:\n+  you should not iterate the response yourself.\n+\n+  Under WSGI the response will be iterated synchronously. Under ASGI the\n+  response will be iterated asynchronously. (This is why the iterator type must\n+  match the protocol you're using.)\n+\n+  To avoid a crash, an incorrect iterator type will be mapped to the correct\n+  type during iteration, and a warning will be raised, but in order to do this\n+  the iterator must be fully-consumed, which defeats the purpose of using a\n+  :class:`StreamingHttpResponse` at all.\n \n * It has no ``content`` attribute. Instead, it has a\n-  :attr:`~StreamingHttpResponse.streaming_content` attribute.\n+  :attr:`~StreamingHttpResponse.streaming_content` attribute. This can be used\n+  in middleware to wrap the response iterable, but should not be consumed.\n \n * You cannot use the file-like object ``tell()`` or ``write()`` methods.\n   Doing so will raise an exception.\n \n-:class:`StreamingHttpResponse` should only be used in situations where it is\n-absolutely required that the whole content isn't iterated before transferring\n-the data to the client. Because the content can't be accessed, many\n-middleware can't function normally. For example the ``ETag`` and\n-``Content-Length`` headers can't be generated for streaming responses.\n-\n The :class:`HttpResponseBase` base class is common between\n :class:`HttpResponse` and :class:`StreamingHttpResponse`.\n \n+.. versionchanged:: 4.2\n+\n+    Support for asynchronous iteration was added.\n+\n Attributes\n ----------\n \n@@ -1181,6 +1214,16 @@ Attributes\n \n     This is always ``True``.\n \n+.. attribute:: StreamingHttpResponse.is_async\n+\n+    .. versionadded:: 4.2\n+\n+    Boolean indicating whether :attr:`StreamingHttpResponse.streaming_content`\n+    is an asynchronous iterator or not.\n+\n+    This is useful for middleware needing to wrap\n+    :attr:`StreamingHttpResponse.streaming_content`.\n+\n ``FileResponse`` objects\n ========================\n \n@@ -1213,6 +1256,15 @@ a file open in binary mode like so::\n \n The file will be closed automatically, so don't open it with a context manager.\n \n+.. admonition:: Use under ASGI\n+\n+    Python's file API is synchronous. This means that the file must be fully\n+    consumed in order to be served under ASGI.\n+\n+    In order to stream a file asynchronously you need to use a third-party\n+    package that provides an asynchronous file API, such as `aiofiles\n+    <https://github.com/Tinche/aiofiles>`_.\n+\n Methods\n -------\n \ndiff --git a/docs/releases/4.2.txt b/docs/releases/4.2.txt\nindex 7979e2359b..9710e889ca 100644\n--- a/docs/releases/4.2.txt\n+++ b/docs/releases/4.2.txt\n@@ -286,7 +286,8 @@ Models\n Requests and Responses\n ~~~~~~~~~~~~~~~~~~~~~~\n \n-* ...\n+* :class:`~django.http.StreamingHttpResponse` now supports async iterators\n+  when Django is served via ASGI.\n \n Security\n ~~~~~~~~\ndiff --git a/docs/topics/http/middleware.txt b/docs/topics/http/middleware.txt\nindex e1a3e95ebc..f0db49abe5 100644\n--- a/docs/topics/http/middleware.txt\n+++ b/docs/topics/http/middleware.txt\n@@ -267,6 +267,16 @@ must test for streaming responses and adjust their behavior accordingly::\n             for chunk in content:\n                 yield alter_content(chunk)\n \n+:class:`~django.http.StreamingHttpResponse` allows both synchronous and\n+asynchronous iterators. The wrapping function must match. Check\n+:attr:`StreamingHttpResponse.is_async\n+<django.http.StreamingHttpResponse.is_async>` if your middleware needs to\n+support both types of iterator.\n+\n+..  versionchanged:: 4.2\n+\n+    Support for streaming responses with asynchronous iterators was added.\n+\n Exception handling\n ==================\n \ndiff --git a/tests/asgi/tests.py b/tests/asgi/tests.py\nindex 4e51c2d9fe..61d040b45b 100644\n--- a/tests/asgi/tests.py\n+++ b/tests/asgi/tests.py\n@@ -12,6 +12,7 @@ from django.db import close_old_connections\n from django.test import (\n     AsyncRequestFactory,\n     SimpleTestCase,\n+    ignore_warnings,\n     modify_settings,\n     override_settings,\n )\n@@ -58,6 +59,13 @@ class ASGITest(SimpleTestCase):\n         # Allow response.close() to finish.\n         await communicator.wait()\n \n+    # Python's file API is not async compatible. A third-party library such\n+    # as https://github.com/Tinche/aiofiles allows passing the file to\n+    # FileResponse as an async interator. With a sync iterator\n+    # StreamingHTTPResponse triggers a warning when iterating the file.\n+    # assertWarnsMessage is not async compatible, so ignore_warnings for the\n+    # test.\n+    @ignore_warnings(module=\"django.http.response\")\n     async def test_file_response(self):\n         \"\"\"\n         Makes sure that FileResponse works over ASGI.\n@@ -91,6 +99,8 @@ class ASGITest(SimpleTestCase):\n                     self.assertEqual(value, b\"text/plain\")\n                 else:\n                     raise\n+\n+        # Warning ignored here.\n         response_body = await communicator.receive_output()\n         self.assertEqual(response_body[\"type\"], \"http.response.body\")\n         self.assertEqual(response_body[\"body\"], test_file_contents)\n@@ -106,6 +116,7 @@ class ASGITest(SimpleTestCase):\n             \"django.contrib.staticfiles.finders.FileSystemFinder\",\n         ],\n     )\n+    @ignore_warnings(module=\"django.http.response\")\n     async def test_static_file_response(self):\n         application = ASGIStaticFilesHandler(get_asgi_application())\n         # Construct HTTP request.\ndiff --git a/tests/httpwrappers/tests.py b/tests/httpwrappers/tests.py\nindex e1920e2eda..fa2c8fd5d2 100644\n--- a/tests/httpwrappers/tests.py\n+++ b/tests/httpwrappers/tests.py\n@@ -720,6 +720,42 @@ class StreamingHttpResponseTests(SimpleTestCase):\n             '<StreamingHttpResponse status_code=200, \"text/html; charset=utf-8\">',\n         )\n \n+    async def test_async_streaming_response(self):\n+        async def async_iter():\n+            yield b\"hello\"\n+            yield b\"world\"\n+\n+        r = StreamingHttpResponse(async_iter())\n+\n+        chunks = []\n+        async for chunk in r:\n+            chunks.append(chunk)\n+        self.assertEqual(chunks, [b\"hello\", b\"world\"])\n+\n+    def test_async_streaming_response_warning(self):\n+        async def async_iter():\n+            yield b\"hello\"\n+            yield b\"world\"\n+\n+        r = StreamingHttpResponse(async_iter())\n+\n+        msg = (\n+            \"StreamingHttpResponse must consume asynchronous iterators in order to \"\n+            \"serve them synchronously. Use a synchronous iterator instead.\"\n+        )\n+        with self.assertWarnsMessage(Warning, msg):\n+            self.assertEqual(list(r), [b\"hello\", b\"world\"])\n+\n+    async def test_sync_streaming_response_warning(self):\n+        r = StreamingHttpResponse(iter([\"hello\", \"world\"]))\n+\n+        msg = (\n+            \"StreamingHttpResponse must consume synchronous iterators in order to \"\n+            \"serve them asynchronously. Use an asynchronous iterator instead.\"\n+        )\n+        with self.assertWarnsMessage(Warning, msg):\n+            self.assertEqual(b\"hello\", await r.__aiter__().__anext__())\n+\n \n class FileCloseTests(SimpleTestCase):\n     def setUp(self):\ndiff --git a/tests/middleware/tests.py b/tests/middleware/tests.py\nindex 1b8efe1a3e..e29d32ad74 100644\n--- a/tests/middleware/tests.py\n+++ b/tests/middleware/tests.py\n@@ -899,6 +899,28 @@ class GZipMiddlewareTest(SimpleTestCase):\n         self.assertEqual(r.get(\"Content-Encoding\"), \"gzip\")\n         self.assertFalse(r.has_header(\"Content-Length\"))\n \n+    async def test_compress_async_streaming_response(self):\n+        \"\"\"\n+        Compression is performed on responses with async streaming content.\n+        \"\"\"\n+\n+        async def get_stream_response(request):\n+            async def iterator():\n+                for chunk in self.sequence:\n+                    yield chunk\n+\n+            resp = StreamingHttpResponse(iterator())\n+            resp[\"Content-Type\"] = \"text/html; charset=UTF-8\"\n+            return resp\n+\n+        r = await GZipMiddleware(get_stream_response)(self.req)\n+        self.assertEqual(\n+            self.decompress(b\"\".join([chunk async for chunk in r])),\n+            b\"\".join(self.sequence),\n+        )\n+        self.assertEqual(r.get(\"Content-Encoding\"), \"gzip\")\n+        self.assertFalse(r.has_header(\"Content-Length\"))\n+\n     def test_compress_streaming_response_unicode(self):\n         \"\"\"\n         Compression is performed on responses with streaming Unicode content.\ndiff --git a/django/contrib/auth/management/__init__.py b/django/contrib/auth/management/__init__.py\nindex 0b5a982617..ad31a6e68f 100644\n--- a/django/contrib/auth/management/__init__.py\n+++ b/django/contrib/auth/management/__init__.py\n@@ -95,11 +95,16 @@ def create_permissions(\n         .values_list(\"content_type\", \"codename\")\n     )\n \n-    perms = [\n-        Permission(codename=codename, name=name, content_type=ct)\n-        for ct, (codename, name) in searched_perms\n-        if (ct.pk, codename) not in all_perms\n-    ]\n+    perms = []\n+    for ct, (codename, name) in searched_perms:\n+        if (ct.pk, codename) not in all_perms:\n+            permission = Permission()\n+            permission._state.db = using\n+            permission.codename = codename\n+            permission.name = name\n+            permission.content_type = ct\n+            perms.append(permission)\n+\n     Permission.objects.using(using).bulk_create(perms)\n     if verbosity >= 2:\n         for perm in perms:\nObtaining file:///testbed\n  Installing build dependencies: started\n  Installing build dependencies: finished with status 'done'\n  Checking if build backend supports build_editable: started\n  Checking if build backend supports build_editable: finished with status 'done'\n  Getting requirements to build editable: started\n  Getting requirements to build editable: finished with status 'done'\n  Preparing editable metadata (pyproject.toml): started\n  Preparing editable metadata (pyproject.toml): finished with status 'done'\nRequirement already satisfied: asgiref>=3.6.0 in /opt/miniconda3/envs/testbed/lib/python3.9/site-packages (from Django==4.2.dev20221222094112) (3.8.1)\nRequirement already satisfied: sqlparse>=0.2.2 in /opt/miniconda3/envs/testbed/lib/python3.9/site-packages (from Django==4.2.dev20221222094112) (0.5.1)\nRequirement already satisfied: typing-extensions>=4 in /opt/miniconda3/envs/testbed/lib/python3.9/site-packages (from asgiref>=3.6.0->Django==4.2.dev20221222094112) (4.12.2)\nBuilding wheels for collected packages: Django\n  Building editable for Django (pyproject.toml): started\n  Building editable for Django (pyproject.toml): finished with status 'done'\n  Created wheel for Django: filename=Django-4.2.dev20221222094112-0.editable-py3-none-any.whl size=27315 sha256=a2f9fb16c27bca9388587d3278d264657144d62a00e410826f10f3c91a04cc59\n  Stored in directory: /tmp/pip-ephem-wheel-cache-uc09e87i/wheels/7d/66/67/70d1ee2124ccf21d601c352e25cdca10f611f7c8b3f9ffb9e4\nSuccessfully built Django\nInstalling collected packages: Django\n  Attempting uninstall: Django\n    Found existing installation: Django 4.2.dev20221222094112\n    Uninstalling Django-4.2.dev20221222094112:\n      Successfully uninstalled Django-4.2.dev20221222094112\nSuccessfully installed Django-4.2.dev20221222094112\nTesting against Django installed in '/testbed/django'\nImporting application auth_tests\nFound 65 test(s).\nOperations to perform:\n  Synchronize unmigrated apps: auth, auth_tests, contenttypes, messages, sessions, staticfiles\n  Apply all migrations: admin, sites\nSynchronizing apps without migrations:\n  Creating tables...\n    Creating table django_content_type\n    Creating table auth_permission\n    Creating table auth_group\n    Creating table auth_user\n    Creating table django_session\n    Creating table auth_tests_customuser\n    Creating table auth_tests_customuserwithoutisactivefield\n    Creating table auth_tests_extensionuser\n    Creating table auth_tests_custompermissionsuser\n    Creating table auth_tests_customusernonuniqueusername\n    Creating table auth_tests_isactivetestuser1\n    Creating table auth_tests_minimaluser\n    Creating table auth_tests_nopassworduser\n    Creating table auth_tests_concrete\n    Creating table auth_tests_uuiduser\n    Creating table auth_tests_customemailfield\n    Creating table auth_tests_email\n    Creating table auth_tests_customuserwithfk\n    Creating table auth_tests_integerusernameuser\n    Creating table auth_tests_userwithdisabledlastloginfield\n    Creating table auth_tests_organization\n    Creating table auth_tests_customuserwithm2m\n    Creating table auth_tests_customuserwithm2mthrough\n    Creating table auth_tests_membership\n    Creating table auth_tests_customuserwithuniqueconstraint\n    Running deferred SQL...\nRunning migrations:\n  Applying admin.0001_initial... OK\n  Applying admin.0002_logentry_remove_auto_add... OK\n  Applying admin.0003_logentry_add_action_flag_choices... OK\n  Applying sites.0001_initial... OK\n  Applying sites.0002_alter_domain_unique... OK\nOperations to perform:\n  Synchronize unmigrated apps: auth, auth_tests, contenttypes, messages, sessions, staticfiles\n  Apply all migrations: admin, sites\nSynchronizing apps without migrations:\n  Creating tables...\n    Creating table django_content_type\n    Creating table auth_permission\n    Creating table auth_group\n    Creating table auth_user\n    Creating table django_session\n    Creating table auth_tests_customuser\n    Creating table auth_tests_customuserwithoutisactivefield\n    Creating table auth_tests_extensionuser\n    Creating table auth_tests_custompermissionsuser\n    Creating table auth_tests_customusernonuniqueusername\n    Creating table auth_tests_isactivetestuser1\n    Creating table auth_tests_minimaluser\n    Creating table auth_tests_nopassworduser\n    Creating table auth_tests_concrete\n    Creating table auth_tests_uuiduser\n    Creating table auth_tests_customemailfield\n    Creating table auth_tests_email\n    Creating table auth_tests_customuserwithfk\n    Creating table auth_tests_integerusernameuser\n    Creating table auth_tests_userwithdisabledlastloginfield\n    Creating table auth_tests_organization\n    Creating table auth_tests_customuserwithm2m\n    Creating table auth_tests_customuserwithm2mthrough\n    Creating table auth_tests_membership\n    Creating table auth_tests_customuserwithuniqueconstraint\n    Running deferred SQL...\nRunning migrations:\n  Applying admin.0001_initial... OK\n  Applying admin.0002_logentry_remove_auto_add... OK\n  Applying admin.0003_logentry_add_action_flag_choices... OK\n  Applying sites.0001_initial... OK\n  Applying sites.0002_alter_domain_unique... OK\nSystem check identified no issues (0 silenced).\n", {}]