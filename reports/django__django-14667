[{"repo": "django/django", "instance_id": "django__django-14667", "base_commit": "6a970a8b4600eb91be25f38caed0a52269d6303d", "patch": "diff --git a/django/db/models/sql/query.py b/django/db/models/sql/query.py\n--- a/django/db/models/sql/query.py\n+++ b/django/db/models/sql/query.py\n@@ -2086,7 +2086,12 @@ def add_deferred_loading(self, field_names):\n             self.deferred_loading = existing.union(field_names), True\n         else:\n             # Remove names from the set of any existing \"immediate load\" names.\n-            self.deferred_loading = existing.difference(field_names), False\n+            if new_existing := existing.difference(field_names):\n+                self.deferred_loading = new_existing, False\n+            else:\n+                self.clear_deferred_loading()\n+                if new_only := set(field_names).difference(existing):\n+                    self.deferred_loading = new_only, True\n \n     def add_immediate_loading(self, field_names):\n         \"\"\"\n", "test_patch": "diff --git a/tests/defer/tests.py b/tests/defer/tests.py\n--- a/tests/defer/tests.py\n+++ b/tests/defer/tests.py\n@@ -49,8 +49,16 @@ def test_defer_only_chaining(self):\n         qs = Primary.objects.all()\n         self.assert_delayed(qs.only(\"name\", \"value\").defer(\"name\")[0], 2)\n         self.assert_delayed(qs.defer(\"name\").only(\"value\", \"name\")[0], 2)\n+        self.assert_delayed(qs.defer('name').only('name').only('value')[0], 2)\n         self.assert_delayed(qs.defer(\"name\").only(\"value\")[0], 2)\n         self.assert_delayed(qs.only(\"name\").defer(\"value\")[0], 2)\n+        self.assert_delayed(qs.only('name').defer('name').defer('value')[0], 1)\n+        self.assert_delayed(qs.only('name').defer('name', 'value')[0], 1)\n+\n+    def test_defer_only_clear(self):\n+        qs = Primary.objects.all()\n+        self.assert_delayed(qs.only('name').defer('name')[0], 0)\n+        self.assert_delayed(qs.defer('name').only('name')[0], 0)\n \n     def test_defer_on_an_already_deferred_field(self):\n         qs = Primary.objects.all()\n", "problem_statement": "QuerySet.defer() doesn't clear deferred field when chaining with only().\nDescription\n\t\nConsidering a simple Company model with four fields: id, name, trade_number and country. If we evaluate a queryset containing a .defer() following a .only(), the generated sql query selects unexpected fields. For example: \nCompany.objects.only(\"name\").defer(\"name\")\nloads all the fields with the following query:\nSELECT \"company\".\"id\", \"company\".\"name\", \"company\".\"trade_number\", \"company\".\"country\" FROM \"company\"\nand \nCompany.objects.only(\"name\").defer(\"name\").defer(\"country\")\nalso loads all the fields with the same query:\nSELECT \"company\".\"id\", \"company\".\"name\", \"company\".\"trade_number\", \"company\".\"country\" FROM \"company\"\nIn those two cases, i would expect the sql query to be:\nSELECT \"company\".\"id\" FROM \"company\"\nIn the following example, we get the expected behavior:\nCompany.objects.only(\"name\", \"country\").defer(\"name\")\nonly loads \"id\" and \"country\" fields with the following query:\nSELECT \"company\".\"id\", \"company\".\"country\" FROM \"company\"\n", "hints_text": "Replying to Manuel Baclet: Considering a simple Company model with four fields: id, name, trade_number and country. If we evaluate a queryset containing a .defer() following a .only(), the generated sql query selects unexpected fields. For example: Company.objects.only(\"name\").defer(\"name\") loads all the fields with the following query: SELECT \"company\".\"id\", \"company\".\"name\", \"company\".\"trade_number\", \"company\".\"country\" FROM \"company\" This is an expected behavior, defer() removes fields from the list of fields specified by the only() method (i.e. list of fields that should not be deferred). In this example only() adds name to the list, defer() removes name from the list, so you have empty lists and all fields will be loaded. It is also \u200bdocumented: # Final result is that everything except \"headline\" is deferred. Entry.objects.only(\"headline\", \"body\").defer(\"body\") Company.objects.only(\"name\").defer(\"name\").defer(\"country\") also loads all the fields with the same query: SELECT \"company\".\"id\", \"company\".\"name\", \"company\".\"trade_number\", \"company\".\"country\" FROM \"company\" I agree you shouldn't get all field, but only pk, name, and trade_number: SELECT \"ticket_32704_company\".\"id\", \"ticket_32704_company\".\"name\", \"ticket_32704_company\".\"trade_number\" FROM \"ticket_32704_company\" this is due to the fact that defer() doesn't clear the list of deferred field when chaining with only(). I attached a proposed patch.\nDraft.\nAfter reading the documentation carefully, i cannot say that it is clearly stated that deferring all the fields used in a previous .only() call performs a reset of the deferred set. Moreover, in the .defer() \u200bsection, we have: You can make multiple calls to defer(). Each call adds new fields to the deferred set: and this seems to suggest that: calls to .defer() cannot remove items from the deferred set and evaluating qs.defer(\"some_field\") should never fetch the column \"some_field\" (since this should add \"some_field\" to the deferred set) the querysets qs.defer(\"field1\").defer(\"field2\") and qs.defer(\"field1\", \"field2\") should be equivalent IMHO, there is a mismatch between the doc and the actual implementation.\ncalls to .defer() cannot remove items from the deferred set and evaluating qs.defer(\"some_field\") should never fetch the column \"some_field\" (since this should add \"some_field\" to the deferred set) Feel-free to propose a docs clarification (see also #24048). the querysets qs.defer(\"field1\").defer(\"field2\") and qs.defer(\"field1\", \"field2\") should be equivalent That's why I accepted Company.objects.only(\"name\").defer(\"name\").defer(\"country\") as a bug.\nI think that what is described in the documentation is what users are expected and it is the implementation that should be fixed! With your patch proposal, i do not think that: Company.objects.only(\"name\").defer(\"name\").defer(\"country\") is equivalent to Company.objects.only(\"name\").defer(\"name\", \"country\")\nReplying to Manuel Baclet: I think that what is described in the documentation is what users are expected and it is the implementation that should be fixed! I don't agree, and there is no need to shout. As documented: \"The only() method is more or less the opposite of defer(). You call it with the fields that should not be deferred ...\", so .only('name').defer('name') should return all fields. You can start a discussion on DevelopersMailingList if you don't agree. With your patch proposal, i do not think that: Company.objects.only(\"name\").defer(\"name\").defer(\"country\") is equivalent to Company.objects.only(\"name\").defer(\"name\", \"country\") Did you check this? with proposed patch country is the only deferred fields in both cases. As far as I'm aware that's an intended behavior.\nWith the proposed patch, I think that: Company.objects.only(\"name\").defer(\"name\", \"country\") loads all fields whereas: Company.objects.only(\"name\").defer(\"name\").defer(\"country\") loads all fields except \"country\". Why is that? In the first case: existing.difference(field_names) == {\"name\"}.difference([\"name\", \"country\"]) == empty_set and we go into the if branch clearing all the deferred fields and we are done. In the second case: existing.difference(field_names) == {\"name\"}.difference([\"name\"]) == empty_set and we go into the if branch clearing all the deferred fields. Then we add \"country\" to the set of deferred fields.\nHey all, Replying to Mariusz Felisiak: Replying to Manuel Baclet: With your patch proposal, i do not think that: Company.objects.only(\"name\").defer(\"name\").defer(\"country\") is equivalent to Company.objects.only(\"name\").defer(\"name\", \"country\") Did you check this? with proposed patch country is the only deferred fields in both cases. As far as I'm aware that's an intended behavior. I believe Manuel is right. This happens because the set difference in one direction gives you the empty set that will clear out the deferred fields - but it is missing the fact that we might also be adding more defer fields than we had only fields in the first place, so that we actually switch from an .only() to a .defer() mode. See the corresponding PR that should fix this behaviour \u200bhttps://github.com/django/django/pull/14667", "created_at": "2021-07-19T21:08:03Z", "version": "4.0", "FAIL_TO_PASS": "[\"test_defer_only_chaining (defer.tests.DeferTests)\"]", "PASS_TO_PASS": "[\"test_custom_refresh_on_deferred_loading (defer.tests.TestDefer2)\", \"When an inherited model is fetched from the DB, its PK is also fetched.\", \"Ensure select_related together with only on a proxy model behaves\", \"test_eq (defer.tests.TestDefer2)\", \"test_refresh_not_loading_deferred_fields (defer.tests.TestDefer2)\", \"test_defer_baseclass_when_subclass_has_added_field (defer.tests.BigChildDeferTests)\", \"test_defer_subclass (defer.tests.BigChildDeferTests)\", \"test_defer_subclass_both (defer.tests.BigChildDeferTests)\", \"test_only_baseclass_when_subclass_has_added_field (defer.tests.BigChildDeferTests)\", \"test_only_subclass (defer.tests.BigChildDeferTests)\", \"test_defer (defer.tests.DeferTests)\", \"test_defer_baseclass_when_subclass_has_no_added_fields (defer.tests.DeferTests)\", \"test_defer_extra (defer.tests.DeferTests)\", \"test_defer_foreign_keys_are_deferred_and_not_traversed (defer.tests.DeferTests)\", \"test_defer_none_to_clear_deferred_set (defer.tests.DeferTests)\", \"test_defer_of_overridden_scalar (defer.tests.DeferTests)\", \"test_defer_on_an_already_deferred_field (defer.tests.DeferTests)\", \"test_defer_only_clear (defer.tests.DeferTests)\", \"test_defer_select_related_raises_invalid_query (defer.tests.DeferTests)\", \"test_defer_values_does_not_defer (defer.tests.DeferTests)\", \"test_defer_with_select_related (defer.tests.DeferTests)\", \"test_get (defer.tests.DeferTests)\", \"test_only (defer.tests.DeferTests)\", \"test_only_baseclass_when_subclass_has_no_added_fields (defer.tests.DeferTests)\", \"test_only_none_raises_error (defer.tests.DeferTests)\", \"test_only_select_related_raises_invalid_query (defer.tests.DeferTests)\", \"test_only_values_does_not_defer (defer.tests.DeferTests)\", \"test_only_with_select_related (defer.tests.DeferTests)\", \"test_saving_object_with_deferred_field (defer.tests.DeferTests)\"]", "environment_setup_commit": "475cffd1d64c690cdad16ede4d5e81985738ceb4"}, "On branch main\nChanges not staged for commit:\n  (use \"git add <file>...\" to update what will be committed)\n  (use \"git restore <file>...\" to discard changes in working directory)\n\tmodified:   django/db/models/sql/query.py\n\nno changes added to commit (use \"git add\" and/or \"git commit -a\")\ncommit 6a970a8b4600eb91be25f38caed0a52269d6303d\nAuthor: Keryn Knight <keryn@kerynknight.com>\nDate:   Tue Jul 20 10:59:21 2021 +0100\n\n    Fixed #32944 -- Avoided unnecessary WhereNode.add() calls.\n    \n    Co-authored-by: Mariusz Felisiak <felisiak.mariusz@gmail.com>\n\ndiff --git a/django/contrib/contenttypes/fields.py b/django/contrib/contenttypes/fields.py\nindex 4aa3ddaf98..35df584dbc 100644\n--- a/django/contrib/contenttypes/fields.py\n+++ b/django/contrib/contenttypes/fields.py\n@@ -14,6 +14,7 @@ from django.db.models.fields.related import (\n     ReverseManyToOneDescriptor, lazy_related_operation,\n )\n from django.db.models.query_utils import PathInfo\n+from django.db.models.sql import AND\n from django.utils.functional import cached_property\n \n \n@@ -468,10 +469,8 @@ class GenericRelation(ForeignObject):\n     def get_extra_restriction(self, where_class, alias, remote_alias):\n         field = self.remote_field.model._meta.get_field(self.content_type_field_name)\n         contenttype_pk = self.get_content_type().pk\n-        cond = where_class()\n         lookup = field.get_lookup('exact')(field.get_col(remote_alias), contenttype_pk)\n-        cond.add(lookup, 'AND')\n-        return cond\n+        return where_class([lookup], connector=AND)\n \n     def bulk_related_objects(self, objs, using=DEFAULT_DB_ALIAS):\n         \"\"\"\ndiff --git a/django/db/models/sql/query.py b/django/db/models/sql/query.py\nindex b3d92d786c..8837881579 100644\n--- a/django/db/models/sql/query.py\n+++ b/django/db/models/sql/query.py\n@@ -1265,9 +1265,7 @@ class Query(BaseExpression):\n             condition = filter_expr.resolve_expression(self, allow_joins=allow_joins)\n             if not isinstance(condition, Lookup):\n                 condition = self.build_lookup(['exact'], condition, True)\n-            clause = self.where_class()\n-            clause.add(condition, AND)\n-            return clause, []\n+            return self.where_class([condition], connector=AND), []\n         arg, value = filter_expr\n         if not arg:\n             raise FieldError(\"Cannot parse keyword query %r\" % arg)\n@@ -1286,11 +1284,9 @@ class Query(BaseExpression):\n         if check_filterable:\n             self.check_filterable(value)\n \n-        clause = self.where_class()\n         if reffed_expression:\n             condition = self.build_lookup(lookups, reffed_expression, value)\n-            clause.add(condition, AND)\n-            return clause, []\n+            return self.where_class([condition], connector=AND), []\n \n         opts = self.get_meta()\n         alias = self.get_initial_alias()\n@@ -1333,7 +1329,7 @@ class Query(BaseExpression):\n \n         condition = self.build_lookup(lookups, col, value)\n         lookup_type = condition.lookup_name\n-        clause.add(condition, AND)\n+        clause = self.where_class([condition], connector=AND)\n \n         require_outer = lookup_type == 'isnull' and condition.rhs is True and not current_negated\n         if current_negated and (lookup_type != 'isnull' or condition.rhs is False) and condition.rhs is not None:\ndiff --git a/django/db/models/sql/query.py b/django/db/models/sql/query.py\nindex 8837881579..af5f684943 100644\n--- a/django/db/models/sql/query.py\n+++ b/django/db/models/sql/query.py\n@@ -2086,7 +2086,12 @@ class Query(BaseExpression):\n             self.deferred_loading = existing.union(field_names), True\n         else:\n             # Remove names from the set of any existing \"immediate load\" names.\n-            self.deferred_loading = existing.difference(field_names), False\n+            if new_existing := existing.difference(field_names):\n+                self.deferred_loading = new_existing, False\n+            else:\n+                self.clear_deferred_loading()\n+                if new_only := set(field_names).difference(existing):\n+                    self.deferred_loading = new_only, True\n \n     def add_immediate_loading(self, field_names):\n         \"\"\"\nObtaining file:///testbed\n  Installing build dependencies: started\n  Installing build dependencies: finished with status 'done'\n  Checking if build backend supports build_editable: started\n  Checking if build backend supports build_editable: finished with status 'done'\n  Getting requirements to build editable: started\n  Getting requirements to build editable: finished with status 'done'\n  Preparing editable metadata (pyproject.toml): started\n  Preparing editable metadata (pyproject.toml): finished with status 'done'\nRequirement already satisfied: asgiref>=3.3.2 in /opt/miniconda3/envs/testbed/lib/python3.8/site-packages (from Django==4.0.dev20210720095921) (3.8.1)\nRequirement already satisfied: pytz in /opt/miniconda3/envs/testbed/lib/python3.8/site-packages (from Django==4.0.dev20210720095921) (2024.2)\nRequirement already satisfied: sqlparse>=0.2.2 in /opt/miniconda3/envs/testbed/lib/python3.8/site-packages (from Django==4.0.dev20210720095921) (0.5.1)\nRequirement already satisfied: typing-extensions>=4 in /opt/miniconda3/envs/testbed/lib/python3.8/site-packages (from asgiref>=3.3.2->Django==4.0.dev20210720095921) (4.12.2)\nBuilding wheels for collected packages: Django\n  Building editable for Django (pyproject.toml): started\n  Building editable for Django (pyproject.toml): finished with status 'done'\n  Created wheel for Django: filename=Django-4.0.dev20210720095921-0.editable-py3-none-any.whl size=26232 sha256=2c12e1518f05df308dd0d59136a1fd54993f86aed103fa3ed1e0edd7238658e8\n  Stored in directory: /tmp/pip-ephem-wheel-cache-5adupylo/wheels/b2/50/f1/218f2e9962a80d01a4b1297698978f9fb3b60056aa24343f24\nSuccessfully built Django\nInstalling collected packages: Django\n  Attempting uninstall: Django\n    Found existing installation: Django 4.0.dev20210720095921\n    Uninstalling Django-4.0.dev20210720095921:\n      Successfully uninstalled Django-4.0.dev20210720095921\nSuccessfully installed Django-4.0.dev20210720095921\nTesting against Django installed in '/testbed/django'\nImporting application defer\nFound 30 test(s).\nSkipping setup of unused database(s): other.\nOperations to perform:\n  Synchronize unmigrated apps: auth, contenttypes, defer, messages, sessions, staticfiles\n  Apply all migrations: admin, sites\nSynchronizing apps without migrations:\n  Creating tables...\n    Creating table django_content_type\n    Creating table auth_permission\n    Creating table auth_group\n    Creating table auth_user\n    Creating table django_session\n    Creating table defer_secondary\n    Creating table defer_primary\n    Creating table defer_child\n    Creating table defer_bigchild\n    Creating table defer_shadowparent\n    Creating table defer_shadowchild\n    Running deferred SQL...\nRunning migrations:\n  Applying admin.0001_initial... OK\n  Applying admin.0002_logentry_remove_auto_add... OK\n  Applying admin.0003_logentry_add_action_flag_choices... OK\n  Applying sites.0001_initial... OK\n  Applying sites.0002_alter_domain_unique... OK\nSystem check identified no issues (0 silenced).\n", {}]