[{"repo": "pallets/flask", "instance_id": "pallets__flask-4045", "base_commit": "d8c37f43724cd9fb0870f77877b7c4c7e38a19e0", "patch": "diff --git a/src/flask/blueprints.py b/src/flask/blueprints.py\n--- a/src/flask/blueprints.py\n+++ b/src/flask/blueprints.py\n@@ -188,6 +188,10 @@ def __init__(\n             template_folder=template_folder,\n             root_path=root_path,\n         )\n+\n+        if \".\" in name:\n+            raise ValueError(\"'name' may not contain a dot '.' character.\")\n+\n         self.name = name\n         self.url_prefix = url_prefix\n         self.subdomain = subdomain\n@@ -360,12 +364,12 @@ def add_url_rule(\n         \"\"\"Like :meth:`Flask.add_url_rule` but for a blueprint.  The endpoint for\n         the :func:`url_for` function is prefixed with the name of the blueprint.\n         \"\"\"\n-        if endpoint:\n-            assert \".\" not in endpoint, \"Blueprint endpoints should not contain dots\"\n-        if view_func and hasattr(view_func, \"__name__\"):\n-            assert (\n-                \".\" not in view_func.__name__\n-            ), \"Blueprint view function name should not contain dots\"\n+        if endpoint and \".\" in endpoint:\n+            raise ValueError(\"'endpoint' may not contain a dot '.' character.\")\n+\n+        if view_func and hasattr(view_func, \"__name__\") and \".\" in view_func.__name__:\n+            raise ValueError(\"'view_func' name may not contain a dot '.' character.\")\n+\n         self.record(lambda s: s.add_url_rule(rule, endpoint, view_func, **options))\n \n     def app_template_filter(self, name: t.Optional[str] = None) -> t.Callable:\n", "test_patch": "diff --git a/tests/test_basic.py b/tests/test_basic.py\n--- a/tests/test_basic.py\n+++ b/tests/test_basic.py\n@@ -1631,7 +1631,7 @@ def something_else():\n \n \n def test_inject_blueprint_url_defaults(app):\n-    bp = flask.Blueprint(\"foo.bar.baz\", __name__, template_folder=\"template\")\n+    bp = flask.Blueprint(\"foo\", __name__, template_folder=\"template\")\n \n     @bp.url_defaults\n     def bp_defaults(endpoint, values):\n@@ -1644,12 +1644,12 @@ def view(page):\n     app.register_blueprint(bp)\n \n     values = dict()\n-    app.inject_url_defaults(\"foo.bar.baz.view\", values)\n+    app.inject_url_defaults(\"foo.view\", values)\n     expected = dict(page=\"login\")\n     assert values == expected\n \n     with app.test_request_context(\"/somepage\"):\n-        url = flask.url_for(\"foo.bar.baz.view\")\n+        url = flask.url_for(\"foo.view\")\n     expected = \"/login\"\n     assert url == expected\n \ndiff --git a/tests/test_blueprints.py b/tests/test_blueprints.py\n--- a/tests/test_blueprints.py\n+++ b/tests/test_blueprints.py\n@@ -1,5 +1,3 @@\n-import functools\n-\n import pytest\n from jinja2 import TemplateNotFound\n from werkzeug.http import parse_cache_control_header\n@@ -253,28 +251,9 @@ def test_templates_list(test_apps):\n     assert templates == [\"admin/index.html\", \"frontend/index.html\"]\n \n \n-def test_dotted_names(app, client):\n-    frontend = flask.Blueprint(\"myapp.frontend\", __name__)\n-    backend = flask.Blueprint(\"myapp.backend\", __name__)\n-\n-    @frontend.route(\"/fe\")\n-    def frontend_index():\n-        return flask.url_for(\"myapp.backend.backend_index\")\n-\n-    @frontend.route(\"/fe2\")\n-    def frontend_page2():\n-        return flask.url_for(\".frontend_index\")\n-\n-    @backend.route(\"/be\")\n-    def backend_index():\n-        return flask.url_for(\"myapp.frontend.frontend_index\")\n-\n-    app.register_blueprint(frontend)\n-    app.register_blueprint(backend)\n-\n-    assert client.get(\"/fe\").data.strip() == b\"/be\"\n-    assert client.get(\"/fe2\").data.strip() == b\"/fe\"\n-    assert client.get(\"/be\").data.strip() == b\"/fe\"\n+def test_dotted_name_not_allowed(app, client):\n+    with pytest.raises(ValueError):\n+        flask.Blueprint(\"app.ui\", __name__)\n \n \n def test_dotted_names_from_app(app, client):\n@@ -343,62 +322,19 @@ def index():\n def test_route_decorator_custom_endpoint_with_dots(app, client):\n     bp = flask.Blueprint(\"bp\", __name__)\n \n-    @bp.route(\"/foo\")\n-    def foo():\n-        return flask.request.endpoint\n-\n-    try:\n-\n-        @bp.route(\"/bar\", endpoint=\"bar.bar\")\n-        def foo_bar():\n-            return flask.request.endpoint\n-\n-    except AssertionError:\n-        pass\n-    else:\n-        raise AssertionError(\"expected AssertionError not raised\")\n-\n-    try:\n-\n-        @bp.route(\"/bar/123\", endpoint=\"bar.123\")\n-        def foo_bar_foo():\n-            return flask.request.endpoint\n-\n-    except AssertionError:\n-        pass\n-    else:\n-        raise AssertionError(\"expected AssertionError not raised\")\n-\n-    def foo_foo_foo():\n-        pass\n-\n-    pytest.raises(\n-        AssertionError,\n-        lambda: bp.add_url_rule(\"/bar/123\", endpoint=\"bar.123\", view_func=foo_foo_foo),\n-    )\n-\n-    pytest.raises(\n-        AssertionError, bp.route(\"/bar/123\", endpoint=\"bar.123\"), lambda: None\n-    )\n-\n-    foo_foo_foo.__name__ = \"bar.123\"\n+    with pytest.raises(ValueError):\n+        bp.route(\"/\", endpoint=\"a.b\")(lambda: \"\")\n \n-    pytest.raises(\n-        AssertionError, lambda: bp.add_url_rule(\"/bar/123\", view_func=foo_foo_foo)\n-    )\n+    with pytest.raises(ValueError):\n+        bp.add_url_rule(\"/\", endpoint=\"a.b\")\n \n-    bp.add_url_rule(\n-        \"/bar/456\", endpoint=\"foofoofoo\", view_func=functools.partial(foo_foo_foo)\n-    )\n+    def view():\n+        return \"\"\n \n-    app.register_blueprint(bp, url_prefix=\"/py\")\n+    view.__name__ = \"a.b\"\n \n-    assert client.get(\"/py/foo\").data == b\"bp.foo\"\n-    # The rule's didn't actually made it through\n-    rv = client.get(\"/py/bar\")\n-    assert rv.status_code == 404\n-    rv = client.get(\"/py/bar/123\")\n-    assert rv.status_code == 404\n+    with pytest.raises(ValueError):\n+        bp.add_url_rule(\"/\", view_func=view)\n \n \n def test_endpoint_decorator(app, client):\n", "problem_statement": "Raise error when blueprint name contains a dot\nThis is required since every dot is now significant since blueprints can be nested. An error was already added for endpoint names in 1.0, but should have been added for this as well.\n", "hints_text": "", "created_at": "2021-05-13T21:32:41Z", "version": "2.0", "FAIL_TO_PASS": "[\"tests/test_blueprints.py::test_dotted_name_not_allowed\", \"tests/test_blueprints.py::test_route_decorator_custom_endpoint_with_dots\"]", "PASS_TO_PASS": "[\"tests/test_basic.py::test_method_route_no_methods\", \"tests/test_basic.py::test_disallow_string_for_allowed_methods\", \"tests/test_basic.py::test_error_handler_unknown_code\", \"tests/test_basic.py::test_request_locals\", \"tests/test_basic.py::test_exception_propagation\", \"tests/test_basic.py::test_werkzeug_passthrough_errors[None-True-True-True]\", \"tests/test_basic.py::test_werkzeug_passthrough_errors[None-True-True-False]\", \"tests/test_basic.py::test_werkzeug_passthrough_errors[None-True-False-True]\", \"tests/test_basic.py::test_werkzeug_passthrough_errors[None-True-False-False]\", \"tests/test_basic.py::test_werkzeug_passthrough_errors[None-False-True-True]\", \"tests/test_basic.py::test_werkzeug_passthrough_errors[None-False-True-False]\", \"tests/test_basic.py::test_werkzeug_passthrough_errors[None-False-False-True]\", \"tests/test_basic.py::test_werkzeug_passthrough_errors[None-False-False-False]\", \"tests/test_basic.py::test_werkzeug_passthrough_errors[True-True-True-True]\", \"tests/test_basic.py::test_werkzeug_passthrough_errors[True-True-True-False]\", \"tests/test_basic.py::test_werkzeug_passthrough_errors[True-True-False-True]\", \"tests/test_basic.py::test_werkzeug_passthrough_errors[True-True-False-False]\", \"tests/test_basic.py::test_werkzeug_passthrough_errors[True-False-True-True]\", \"tests/test_basic.py::test_werkzeug_passthrough_errors[True-False-True-False]\", \"tests/test_basic.py::test_werkzeug_passthrough_errors[True-False-False-True]\", \"tests/test_basic.py::test_werkzeug_passthrough_errors[True-False-False-False]\", \"tests/test_basic.py::test_werkzeug_passthrough_errors[False-True-True-True]\", \"tests/test_basic.py::test_werkzeug_passthrough_errors[False-True-True-False]\", \"tests/test_basic.py::test_werkzeug_passthrough_errors[False-True-False-True]\", \"tests/test_basic.py::test_werkzeug_passthrough_errors[False-True-False-False]\", \"tests/test_basic.py::test_werkzeug_passthrough_errors[False-False-True-True]\", \"tests/test_basic.py::test_werkzeug_passthrough_errors[False-False-True-False]\", \"tests/test_basic.py::test_werkzeug_passthrough_errors[False-False-False-True]\", \"tests/test_basic.py::test_werkzeug_passthrough_errors[False-False-False-False]\", \"tests/test_basic.py::test_get_method_on_g\", \"tests/test_basic.py::test_g_iteration_protocol\", \"tests/test_basic.py::test_run_defaults\", \"tests/test_basic.py::test_run_server_port\", \"tests/test_basic.py::test_run_from_config[None-None-pocoo.org:8080-pocoo.org-8080]\", \"tests/test_basic.py::test_run_from_config[localhost-None-pocoo.org:8080-localhost-8080]\", \"tests/test_basic.py::test_run_from_config[None-80-pocoo.org:8080-pocoo.org-80]\", \"tests/test_basic.py::test_run_from_config[localhost-80-pocoo.org:8080-localhost-80]\", \"tests/test_basic.py::test_run_from_config[localhost-0-localhost:8080-localhost-0]\", \"tests/test_basic.py::test_run_from_config[None-None-localhost:8080-localhost-8080]\", \"tests/test_basic.py::test_run_from_config[None-None-localhost:0-localhost-0]\", \"tests/test_basic.py::test_app_freed_on_zero_refcount\", \"tests/test_blueprints.py::test_template_filter\", \"tests/test_blueprints.py::test_add_template_filter\", \"tests/test_blueprints.py::test_template_filter_with_name\", \"tests/test_blueprints.py::test_add_template_filter_with_name\", \"tests/test_blueprints.py::test_template_test\", \"tests/test_blueprints.py::test_add_template_test\", \"tests/test_blueprints.py::test_template_test_with_name\", \"tests/test_blueprints.py::test_add_template_test_with_name\", \"tests/test_blueprints.py::test_template_global\"]", "environment_setup_commit": "4346498c85848c53843b810537b83a8f6124c9d3"}, "On branch main\nChanges not staged for commit:\n  (use \"git add <file>...\" to update what will be committed)\n  (use \"git restore <file>...\" to discard changes in working directory)\n\tmodified:   src/flask/blueprints.py\n\nno changes added to commit (use \"git add\" and/or \"git commit -a\")\ncommit d8c37f43724cd9fb0870f77877b7c4c7e38a19e0\nMerge: 6414df97 d5aadba4\nAuthor: David Lord <davidism@gmail.com>\nDate:   Thu May 13 13:35:12 2021 -0700\n\n    Merge pull request #4026 from greyli/improve-type-hints\n    \n    Improve type hints for send_file and send_from_directory\n\ndiff --git a/src/flask/blueprints.py b/src/flask/blueprints.py\nindex 5fb84d86..823995f6 100644\n--- a/src/flask/blueprints.py\n+++ b/src/flask/blueprints.py\n@@ -188,6 +188,10 @@ class Blueprint(Scaffold):\n             template_folder=template_folder,\n             root_path=root_path,\n         )\n+\n+        if \".\" in name:\n+            raise ValueError(\"'name' may not contain a dot '.' character.\")\n+\n         self.name = name\n         self.url_prefix = url_prefix\n         self.subdomain = subdomain\n@@ -360,12 +364,12 @@ class Blueprint(Scaffold):\n         \"\"\"Like :meth:`Flask.add_url_rule` but for a blueprint.  The endpoint for\n         the :func:`url_for` function is prefixed with the name of the blueprint.\n         \"\"\"\n-        if endpoint:\n-            assert \".\" not in endpoint, \"Blueprint endpoints should not contain dots\"\n-        if view_func and hasattr(view_func, \"__name__\"):\n-            assert (\n-                \".\" not in view_func.__name__\n-            ), \"Blueprint view function name should not contain dots\"\n+        if endpoint and \".\" in endpoint:\n+            raise ValueError(\"'endpoint' may not contain a dot '.' character.\")\n+\n+        if view_func and hasattr(view_func, \"__name__\") and \".\" in view_func.__name__:\n+            raise ValueError(\"'view_func' name may not contain a dot '.' character.\")\n+\n         self.record(lambda s: s.add_url_rule(rule, endpoint, view_func, **options))\n \n     def app_template_filter(self, name: t.Optional[str] = None) -> t.Callable:\nObtaining file:///testbed\n  Preparing metadata (setup.py): started\n  Preparing metadata (setup.py): finished with status 'done'\nRequirement already satisfied: Werkzeug>=2.0 in /opt/miniconda3/envs/testbed/lib/python3.9/site-packages (from Flask==2.0.1.dev0) (2.3.7)\nRequirement already satisfied: Jinja2>=3.0 in /opt/miniconda3/envs/testbed/lib/python3.9/site-packages (from Flask==2.0.1.dev0) (3.0.1)\nRequirement already satisfied: itsdangerous>=2.0 in /opt/miniconda3/envs/testbed/lib/python3.9/site-packages (from Flask==2.0.1.dev0) (2.1.2)\nRequirement already satisfied: click>=7.1.2 in /opt/miniconda3/envs/testbed/lib/python3.9/site-packages (from Flask==2.0.1.dev0) (8.0.1)\nRequirement already satisfied: MarkupSafe>=2.0 in /opt/miniconda3/envs/testbed/lib/python3.9/site-packages (from Jinja2>=3.0->Flask==2.0.1.dev0) (2.1.3)\nInstalling collected packages: Flask\n  Attempting uninstall: Flask\n    Found existing installation: Flask 2.0.1.dev0\n    Uninstalling Flask-2.0.1.dev0:\n      Successfully uninstalled Flask-2.0.1.dev0\n  Running setup.py develop for Flask\nSuccessfully installed Flask\n============================= test session starts ==============================\nplatform linux -- Python 3.9.20, pytest-6.2.5, py-1.10.0, pluggy-1.0.0\nrootdir: /testbed, configfile: setup.cfg\ncollected 179 items\n\ntests/test_basic.py FFFFFFF.FFF.FFFFFFFFFFFFFFFFFFEFFFFFFFFF.FFFFFFFFFFF [ 29%]\nFEEEEEEEEFFFFFFFFFFF.F.........................FFFFFFFFFFF..FFFFFFF..... [ 69%]\n....F.                                                                   [ 72%]\ntests/test_blueprints.py FFFFFFFFFFFFFFFFEFE.FFF.F....FFFFF....FFFFFF.FF [ 98%]\nFF                                                                       [100%]\n\n==================================== ERRORS ====================================\n________________________ ERROR at setup of test_flashes ________________________\n\napp = <Flask 'flask_test'>\n\n    @pytest.fixture\n    def req_ctx(app):\n>       with app.test_request_context() as ctx:\n\ntests/conftest.py:65: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \nsrc/flask/app.py:2015: in test_request_context\n    builder = EnvironBuilder(self, *args, **kwargs)\nsrc/flask/testing.py:70: in __init__\n    url = url_parse(path)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nurl = '/', scheme = None, allow_fragments = True\n\n    def url_parse(\n        url: str, scheme: str | None = None, allow_fragments: bool = True\n    ) -> BaseURL:\n        \"\"\"Parses a URL from a string into a :class:`URL` tuple.  If the URL\n        is lacking a scheme it can be provided as second argument. Otherwise,\n        it is ignored.  Optionally fragments can be stripped from the URL\n        by setting `allow_fragments` to `False`.\n    \n        The inverse of this function is :func:`url_unparse`.\n    \n        :param url: the URL to parse.\n        :param scheme: the default schema to use if the URL is schemaless.\n        :param allow_fragments: if set to `False` a fragment will be removed\n                                from the URL.\n    \n        .. deprecated:: 2.3\n            Will be removed in Werkzeug 3.0. Use ``urllib.parse.urlsplit`` instead.\n        \"\"\"\n>       warnings.warn(\n            \"'werkzeug.urls.url_parse' is deprecated and will be removed in Werkzeug 3.0.\"\n            \" Use 'urllib.parse.urlsplit' instead.\",\n            DeprecationWarning,\n            stacklevel=2,\n        )\nE       DeprecationWarning: 'werkzeug.urls.url_parse' is deprecated and will be removed in Werkzeug 3.0. Use 'urllib.parse.urlsplit' instead.\n\n/opt/miniconda3/envs/testbed/lib/python3.9/site-packages/werkzeug/urls.py:505: DeprecationWarning\n_____________________ ERROR at setup of test_make_response _____________________\n\napp = <Flask 'flask_test'>\n\n    @pytest.fixture\n    def req_ctx(app):\n>       with app.test_request_context() as ctx:\n\ntests/conftest.py:65: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \nsrc/flask/app.py:2015: in test_request_context\n    builder = EnvironBuilder(self, *args, **kwargs)\nsrc/flask/testing.py:70: in __init__\n    url = url_parse(path)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nurl = '/', scheme = None, allow_fragments = True\n\n    def url_parse(\n        url: str, scheme: str | None = None, allow_fragments: bool = True\n    ) -> BaseURL:\n        \"\"\"Parses a URL from a string into a :class:`URL` tuple.  If the URL\n        is lacking a scheme it can be provided as second argument. Otherwise,\n        it is ignored.  Optionally fragments can be stripped from the URL\n        by setting `allow_fragments` to `False`.\n    \n        The inverse of this function is :func:`url_unparse`.\n    \n        :param url: the URL to parse.\n        :param scheme: the default schema to use if the URL is schemaless.\n        :param allow_fragments: if set to `False` a fragment will be removed\n                                from the URL.\n    \n        .. deprecated:: 2.3\n            Will be removed in Werkzeug 3.0. Use ``urllib.parse.urlsplit`` instead.\n        \"\"\"\n>       warnings.warn(\n            \"'werkzeug.urls.url_parse' is deprecated and will be removed in Werkzeug 3.0.\"\n            \" Use 'urllib.parse.urlsplit' instead.\",\n            DeprecationWarning,\n            stacklevel=2,\n        )\nE       DeprecationWarning: 'werkzeug.urls.url_parse' is deprecated and will be removed in Werkzeug 3.0. Use 'urllib.parse.urlsplit' instead.\n\n/opt/miniconda3/envs/testbed/lib/python3.9/site-packages/werkzeug/urls.py:505: DeprecationWarning\n_________ ERROR at setup of test_make_response_with_response_instance __________\n\napp = <Flask 'flask_test'>\n\n    @pytest.fixture\n    def req_ctx(app):\n>       with app.test_request_context() as ctx:\n\ntests/conftest.py:65: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \nsrc/flask/app.py:2015: in test_request_context\n    builder = EnvironBuilder(self, *args, **kwargs)\nsrc/flask/testing.py:70: in __init__\n    url = url_parse(path)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nurl = '/', scheme = None, allow_fragments = True\n\n    def url_parse(\n        url: str, scheme: str | None = None, allow_fragments: bool = True\n    ) -> BaseURL:\n        \"\"\"Parses a URL from a string into a :class:`URL` tuple.  If the URL\n        is lacking a scheme it can be provided as second argument. Otherwise,\n        it is ignored.  Optionally fragments can be stripped from the URL\n        by setting `allow_fragments` to `False`.\n    \n        The inverse of this function is :func:`url_unparse`.\n    \n        :param url: the URL to parse.\n        :param scheme: the default schema to use if the URL is schemaless.\n        :param allow_fragments: if set to `False` a fragment will be removed\n                                from the URL.\n    \n        .. deprecated:: 2.3\n            Will be removed in Werkzeug 3.0. Use ``urllib.parse.urlsplit`` instead.\n        \"\"\"\n>       warnings.warn(\n            \"'werkzeug.urls.url_parse' is deprecated and will be removed in Werkzeug 3.0.\"\n            \" Use 'urllib.parse.urlsplit' instead.\",\n            DeprecationWarning,\n            stacklevel=2,\n        )\nE       DeprecationWarning: 'werkzeug.urls.url_parse' is deprecated and will be removed in Werkzeug 3.0. Use 'urllib.parse.urlsplit' instead.\n\n/opt/miniconda3/envs/testbed/lib/python3.9/site-packages/werkzeug/urls.py:505: DeprecationWarning\n________________ ERROR at setup of test_jsonify_no_prettyprint _________________\n\napp = <Flask 'flask_test'>\n\n    @pytest.fixture\n    def req_ctx(app):\n>       with app.test_request_context() as ctx:\n\ntests/conftest.py:65: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \nsrc/flask/app.py:2015: in test_request_context\n    builder = EnvironBuilder(self, *args, **kwargs)\nsrc/flask/testing.py:70: in __init__\n    url = url_parse(path)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nurl = '/', scheme = None, allow_fragments = True\n\n    def url_parse(\n        url: str, scheme: str | None = None, allow_fragments: bool = True\n    ) -> BaseURL:\n        \"\"\"Parses a URL from a string into a :class:`URL` tuple.  If the URL\n        is lacking a scheme it can be provided as second argument. Otherwise,\n        it is ignored.  Optionally fragments can be stripped from the URL\n        by setting `allow_fragments` to `False`.\n    \n        The inverse of this function is :func:`url_unparse`.\n    \n        :param url: the URL to parse.\n        :param scheme: the default schema to use if the URL is schemaless.\n        :param allow_fragments: if set to `False` a fragment will be removed\n                                from the URL.\n    \n        .. deprecated:: 2.3\n            Will be removed in Werkzeug 3.0. Use ``urllib.parse.urlsplit`` instead.\n        \"\"\"\n>       warnings.warn(\n            \"'werkzeug.urls.url_parse' is deprecated and will be removed in Werkzeug 3.0.\"\n            \" Use 'urllib.parse.urlsplit' instead.\",\n            DeprecationWarning,\n            stacklevel=2,\n        )\nE       DeprecationWarning: 'werkzeug.urls.url_parse' is deprecated and will be removed in Werkzeug 3.0. Use 'urllib.parse.urlsplit' instead.\n\n/opt/miniconda3/envs/testbed/lib/python3.9/site-packages/werkzeug/urls.py:505: DeprecationWarning\n__________________ ERROR at setup of test_jsonify_prettyprint __________________\n\napp = <Flask 'flask_test'>\n\n    @pytest.fixture\n    def req_ctx(app):\n>       with app.test_request_context() as ctx:\n\ntests/conftest.py:65: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \nsrc/flask/app.py:2015: in test_request_context\n    builder = EnvironBuilder(self, *args, **kwargs)\nsrc/flask/testing.py:70: in __init__\n    url = url_parse(path)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nurl = '/', scheme = None, allow_fragments = True\n\n    def url_parse(\n        url: str, scheme: str | None = None, allow_fragments: bool = True\n    ) -> BaseURL:\n        \"\"\"Parses a URL from a string into a :class:`URL` tuple.  If the URL\n        is lacking a scheme it can be provided as second argument. Otherwise,\n        it is ignored.  Optionally fragments can be stripped from the URL\n        by setting `allow_fragments` to `False`.\n    \n        The inverse of this function is :func:`url_unparse`.\n    \n        :param url: the URL to parse.\n        :param scheme: the default schema to use if the URL is schemaless.\n        :param allow_fragments: if set to `False` a fragment will be removed\n                                from the URL.\n    \n        .. deprecated:: 2.3\n            Will be removed in Werkzeug 3.0. Use ``urllib.parse.urlsplit`` instead.\n        \"\"\"\n>       warnings.warn(\n            \"'werkzeug.urls.url_parse' is deprecated and will be removed in Werkzeug 3.0.\"\n            \" Use 'urllib.parse.urlsplit' instead.\",\n            DeprecationWarning,\n            stacklevel=2,\n        )\nE       DeprecationWarning: 'werkzeug.urls.url_parse' is deprecated and will be removed in Werkzeug 3.0. Use 'urllib.parse.urlsplit' instead.\n\n/opt/miniconda3/envs/testbed/lib/python3.9/site-packages/werkzeug/urls.py:505: DeprecationWarning\n___________________ ERROR at setup of test_jsonify_mimetype ____________________\n\napp = <Flask 'flask_test'>\n\n    @pytest.fixture\n    def req_ctx(app):\n>       with app.test_request_context() as ctx:\n\ntests/conftest.py:65: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \nsrc/flask/app.py:2015: in test_request_context\n    builder = EnvironBuilder(self, *args, **kwargs)\nsrc/flask/testing.py:70: in __init__\n    url = url_parse(path)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nurl = '/', scheme = None, allow_fragments = True\n\n    def url_parse(\n        url: str, scheme: str | None = None, allow_fragments: bool = True\n    ) -> BaseURL:\n        \"\"\"Parses a URL from a string into a :class:`URL` tuple.  If the URL\n        is lacking a scheme it can be provided as second argument. Otherwise,\n        it is ignored.  Optionally fragments can be stripped from the URL\n        by setting `allow_fragments` to `False`.\n    \n        The inverse of this function is :func:`url_unparse`.\n    \n        :param url: the URL to parse.\n        :param scheme: the default schema to use if the URL is schemaless.\n        :param allow_fragments: if set to `False` a fragment will be removed\n                                from the URL.\n    \n        .. deprecated:: 2.3\n            Will be removed in Werkzeug 3.0. Use ``urllib.parse.urlsplit`` instead.\n        \"\"\"\n>       warnings.warn(\n            \"'werkzeug.urls.url_parse' is deprecated and will be removed in Werkzeug 3.0.\"\n            \" Use 'urllib.parse.urlsplit' instead.\",\n            DeprecationWarning,\n            stacklevel=2,\n        )\nE       DeprecationWarning: 'werkzeug.urls.url_parse' is deprecated and will be removed in Werkzeug 3.0. Use 'urllib.parse.urlsplit' instead.\n\n/opt/miniconda3/envs/testbed/lib/python3.9/site-packages/werkzeug/urls.py:505: DeprecationWarning\n__________________ ERROR at setup of test_json_dump_dataclass __________________\n\napp = <Flask 'flask_test'>\n\n    @pytest.fixture\n    def req_ctx(app):\n>       with app.test_request_context() as ctx:\n\ntests/conftest.py:65: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \nsrc/flask/app.py:2015: in test_request_context\n    builder = EnvironBuilder(self, *args, **kwargs)\nsrc/flask/testing.py:70: in __init__\n    url = url_parse(path)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nurl = '/', scheme = None, allow_fragments = True\n\n    def url_parse(\n        url: str, scheme: str | None = None, allow_fragments: bool = True\n    ) -> BaseURL:\n        \"\"\"Parses a URL from a string into a :class:`URL` tuple.  If the URL\n        is lacking a scheme it can be provided as second argument. Otherwise,\n        it is ignored.  Optionally fragments can be stripped from the URL\n        by setting `allow_fragments` to `False`.\n    \n        The inverse of this function is :func:`url_unparse`.\n    \n        :param url: the URL to parse.\n        :param scheme: the default schema to use if the URL is schemaless.\n        :param allow_fragments: if set to `False` a fragment will be removed\n                                from the URL.\n    \n        .. deprecated:: 2.3\n            Will be removed in Werkzeug 3.0. Use ``urllib.parse.urlsplit`` instead.\n        \"\"\"\n>       warnings.warn(\n            \"'werkzeug.urls.url_parse' is deprecated and will be removed in Werkzeug 3.0.\"\n            \" Use 'urllib.parse.urlsplit' instead.\",\n            DeprecationWarning,\n            stacklevel=2,\n        )\nE       DeprecationWarning: 'werkzeug.urls.url_parse' is deprecated and will be removed in Werkzeug 3.0. Use 'urllib.parse.urlsplit' instead.\n\n/opt/miniconda3/envs/testbed/lib/python3.9/site-packages/werkzeug/urls.py:505: DeprecationWarning\n_____________ ERROR at setup of test_jsonify_args_and_kwargs_check _____________\n\napp = <Flask 'flask_test'>\n\n    @pytest.fixture\n    def req_ctx(app):\n>       with app.test_request_context() as ctx:\n\ntests/conftest.py:65: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \nsrc/flask/app.py:2015: in test_request_context\n    builder = EnvironBuilder(self, *args, **kwargs)\nsrc/flask/testing.py:70: in __init__\n    url = url_parse(path)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nurl = '/', scheme = None, allow_fragments = True\n\n    def url_parse(\n        url: str, scheme: str | None = None, allow_fragments: bool = True\n    ) -> BaseURL:\n        \"\"\"Parses a URL from a string into a :class:`URL` tuple.  If the URL\n        is lacking a scheme it can be provided as second argument. Otherwise,\n        it is ignored.  Optionally fragments can be stripped from the URL\n        by setting `allow_fragments` to `False`.\n    \n        The inverse of this function is :func:`url_unparse`.\n    \n        :param url: the URL to parse.\n        :param scheme: the default schema to use if the URL is schemaless.\n        :param allow_fragments: if set to `False` a fragment will be removed\n                                from the URL.\n    \n        .. deprecated:: 2.3\n            Will be removed in Werkzeug 3.0. Use ``urllib.parse.urlsplit`` instead.\n        \"\"\"\n>       warnings.warn(\n            \"'werkzeug.urls.url_parse' is deprecated and will be removed in Werkzeug 3.0.\"\n            \" Use 'urllib.parse.urlsplit' instead.\",\n            DeprecationWarning,\n            stacklevel=2,\n        )\nE       DeprecationWarning: 'werkzeug.urls.url_parse' is deprecated and will be removed in Werkzeug 3.0. Use 'urllib.parse.urlsplit' instead.\n\n/opt/miniconda3/envs/testbed/lib/python3.9/site-packages/werkzeug/urls.py:505: DeprecationWarning\n____________________ ERROR at setup of test_url_generation _____________________\n\napp = <Flask 'flask_test'>\n\n    @pytest.fixture\n    def req_ctx(app):\n>       with app.test_request_context() as ctx:\n\ntests/conftest.py:65: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \nsrc/flask/app.py:2015: in test_request_context\n    builder = EnvironBuilder(self, *args, **kwargs)\nsrc/flask/testing.py:70: in __init__\n    url = url_parse(path)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nurl = '/', scheme = None, allow_fragments = True\n\n    def url_parse(\n        url: str, scheme: str | None = None, allow_fragments: bool = True\n    ) -> BaseURL:\n        \"\"\"Parses a URL from a string into a :class:`URL` tuple.  If the URL\n        is lacking a scheme it can be provided as second argument. Otherwise,\n        it is ignored.  Optionally fragments can be stripped from the URL\n        by setting `allow_fragments` to `False`.\n    \n        The inverse of this function is :func:`url_unparse`.\n    \n        :param url: the URL to parse.\n        :param scheme: the default schema to use if the URL is schemaless.\n        :param allow_fragments: if set to `False` a fragment will be removed\n                                from the URL.\n    \n        .. deprecated:: 2.3\n            Will be removed in Werkzeug 3.0. Use ``urllib.parse.urlsplit`` instead.\n        \"\"\"\n>       warnings.warn(\n            \"'werkzeug.urls.url_parse' is deprecated and will be removed in Werkzeug 3.0.\"\n            \" Use 'urllib.parse.urlsplit' instead.\",\n            DeprecationWarning,\n            stacklevel=2,\n        )\nE       DeprecationWarning: 'werkzeug.urls.url_parse' is deprecated and will be removed in Werkzeug 3.0. Use 'urllib.parse.urlsplit' instead.\n\n/opt/miniconda3/envs/testbed/lib/python3.9/site-packages/werkzeug/urls.py:505: DeprecationWarning\n_________________ ERROR at setup of test_templates_and_static __________________\n\nmonkeypatch = <_pytest.monkeypatch.MonkeyPatch object at 0x7f487bb4f760>\n\n    @pytest.fixture\n    def test_apps(monkeypatch):\n>       monkeypatch.syspath_prepend(os.path.join(os.path.dirname(__file__), \"test_apps\"))\n\ntests/conftest.py:76: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\n    \"\"\"\n    Package resource API\n    --------------------\n    \n    A resource is a logical file contained within a package, or a logical\n    subdirectory thereof.  The package resource API expects resource names\n    to have their path parts separated with ``/``, *not* whatever the local\n    path separator is.  Do not use os.path operations to manipulate resource\n    names being passed into the API.\n    \n    The package resource API is designed to work with normal filesystem packages,\n    .egg files, and unpacked .egg files.  It can also work in a limited way with\n    .zip files and with custom PEP 302 loaders that support the ``get_data()``\n    method.\n    \n    This module is deprecated. Users are directed to :mod:`importlib.resources`,\n    :mod:`importlib.metadata` and :pypi:`packaging` instead.\n    \"\"\"\n    \n    import sys\n    \n    if sys.version_info < (3, 8):\n        raise RuntimeError(\"Python 3.8 or later is required\")\n    \n    import os\n    import io\n    import time\n    import re\n    import types\n    from typing import (\n        TYPE_CHECKING,\n        List,\n        Protocol,\n        Callable,\n        Dict,\n        Iterable,\n        Optional,\n        TypeVar,\n    )\n    import zipfile\n    import zipimport\n    import warnings\n    import stat\n    import functools\n    import pkgutil\n    import operator\n    import platform\n    import collections\n    import plistlib\n    import email.parser\n    import errno\n    import tempfile\n    import textwrap\n    import inspect\n    import ntpath\n    import posixpath\n    import importlib\n    import importlib.machinery\n    from pkgutil import get_importer\n    \n    import _imp\n    \n    # capture these to bypass sandboxing\n    from os import utime\n    \n    try:\n        from os import mkdir, rename, unlink\n    \n        WRITE_SUPPORT = True\n    except ImportError:\n        # no write support, probably under GAE\n        WRITE_SUPPORT = False\n    \n    from os import open as os_open\n    from os.path import isdir, split\n    \n    from pkg_resources.extern.jaraco.text import (\n        yield_lines,\n        drop_comment,\n        join_continuation,\n    )\n    from pkg_resources.extern.packaging import markers as _packaging_markers\n    from pkg_resources.extern.packaging import requirements as _packaging_requirements\n    from pkg_resources.extern.packaging import utils as _packaging_utils\n    from pkg_resources.extern.packaging import version as _packaging_version\n    from pkg_resources.extern.platformdirs import user_cache_dir as _user_cache_dir\n    \n    \n>   warnings.warn(\n        \"pkg_resources is deprecated as an API. \"\n        \"See https://setuptools.pypa.io/en/latest/pkg_resources.html\",\n        DeprecationWarning,\n        stacklevel=2,\n    )\nE   DeprecationWarning: pkg_resources is deprecated as an API. See https://setuptools.pypa.io/en/latest/pkg_resources.html\n\n/opt/miniconda3/envs/testbed/lib/python3.9/site-packages/pkg_resources/__init__.py:89: DeprecationWarning\n____________________ ERROR at setup of test_templates_list _____________________\n\nmonkeypatch = <_pytest.monkeypatch.MonkeyPatch object at 0x7f487b481730>\n\n    @pytest.fixture\n    def test_apps(monkeypatch):\n>       monkeypatch.syspath_prepend(os.path.join(os.path.dirname(__file__), \"test_apps\"))\n\ntests/conftest.py:76: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\n    \"\"\"\n    Package resource API\n    --------------------\n    \n    A resource is a logical file contained within a package, or a logical\n    subdirectory thereof.  The package resource API expects resource names\n    to have their path parts separated with ``/``, *not* whatever the local\n    path separator is.  Do not use os.path operations to manipulate resource\n    names being passed into the API.\n    \n    The package resource API is designed to work with normal filesystem packages,\n    .egg files, and unpacked .egg files.  It can also work in a limited way with\n    .zip files and with custom PEP 302 loaders that support the ``get_data()``\n    method.\n    \n    This module is deprecated. Users are directed to :mod:`importlib.resources`,\n    :mod:`importlib.metadata` and :pypi:`packaging` instead.\n    \"\"\"\n    \n    import sys\n    \n    if sys.version_info < (3, 8):\n        raise RuntimeError(\"Python 3.8 or later is required\")\n    \n    import os\n    import io\n    import time\n    import re\n    import types\n    from typing import (\n        TYPE_CHECKING,\n        List,\n        Protocol,\n        Callable,\n        Dict,\n        Iterable,\n        Optional,\n        TypeVar,\n    )\n    import zipfile\n    import zipimport\n    import warnings\n    import stat\n    import functools\n    import pkgutil\n    import operator\n    import platform\n    import collections\n    import plistlib\n    import email.parser\n    import errno\n    import tempfile\n    import textwrap\n    import inspect\n    import ntpath\n    import posixpath\n    import importlib\n    import importlib.machinery\n    from pkgutil import get_importer\n    \n    import _imp\n    \n    # capture these to bypass sandboxing\n    from os import utime\n    \n    try:\n        from os import mkdir, rename, unlink\n    \n        WRITE_SUPPORT = True\n    except ImportError:\n        # no write support, probably under GAE\n        WRITE_SUPPORT = False\n    \n    from os import open as os_open\n    from os.path import isdir, split\n    \n    from pkg_resources.extern.jaraco.text import (\n        yield_lines,\n        drop_comment,\n        join_continuation,\n    )\n    from pkg_resources.extern.packaging import markers as _packaging_markers\n    from pkg_resources.extern.packaging import requirements as _packaging_requirements\n    from pkg_resources.extern.packaging import utils as _packaging_utils\n    from pkg_resources.extern.packaging import version as _packaging_version\n    from pkg_resources.extern.platformdirs import user_cache_dir as _user_cache_dir\n    \n    \n>   warnings.warn(\n        \"pkg_resources is deprecated as an API. \"\n        \"See https://setuptools.pypa.io/en/latest/pkg_resources.html\",\n        DeprecationWarning,\n        stacklevel=2,\n    )\nE   DeprecationWarning: pkg_resources is deprecated as an API. See https://setuptools.pypa.io/en/latest/pkg_resources.html\n\n/opt/miniconda3/envs/testbed/lib/python3.9/site-packages/pkg_resources/__init__.py:89: DeprecationWarning\n=================================== FAILURES ===================================\n______________________________ test_options_work _______________________________\n\napp = <Flask 'flask_test'>, client = <FlaskClient <Flask 'flask_test'>>\n\n    def test_options_work(app, client):\n        @app.route(\"/\", methods=[\"GET\", \"POST\"])\n        def index():\n            return \"Hello World\"\n    \n>       rv = client.open(\"/\", method=\"OPTIONS\")\n\ntests/test_basic.py:33: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \nsrc/flask/testing.py:209: in open\n    builder = EnvironBuilder(self.application, *args, **kwargs)\nsrc/flask/testing.py:70: in __init__\n    url = url_parse(path)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nurl = '/', scheme = None, allow_fragments = True\n\n    def url_parse(\n        url: str, scheme: str | None = None, allow_fragments: bool = True\n    ) -> BaseURL:\n        \"\"\"Parses a URL from a string into a :class:`URL` tuple.  If the URL\n        is lacking a scheme it can be provided as second argument. Otherwise,\n        it is ignored.  Optionally fragments can be stripped from the URL\n        by setting `allow_fragments` to `False`.\n    \n        The inverse of this function is :func:`url_unparse`.\n    \n        :param url: the URL to parse.\n        :param scheme: the default schema to use if the URL is schemaless.\n        :param allow_fragments: if set to `False` a fragment will be removed\n                                from the URL.\n    \n        .. deprecated:: 2.3\n            Will be removed in Werkzeug 3.0. Use ``urllib.parse.urlsplit`` instead.\n        \"\"\"\n>       warnings.warn(\n            \"'werkzeug.urls.url_parse' is deprecated and will be removed in Werkzeug 3.0.\"\n            \" Use 'urllib.parse.urlsplit' instead.\",\n            DeprecationWarning,\n            stacklevel=2,\n        )\nE       DeprecationWarning: 'werkzeug.urls.url_parse' is deprecated and will be removed in Werkzeug 3.0. Use 'urllib.parse.urlsplit' instead.\n\n/opt/miniconda3/envs/testbed/lib/python3.9/site-packages/werkzeug/urls.py:505: DeprecationWarning\n________________________ test_options_on_multiple_rules ________________________\n\napp = <Flask 'flask_test'>, client = <FlaskClient <Flask 'flask_test'>>\n\n    def test_options_on_multiple_rules(app, client):\n        @app.route(\"/\", methods=[\"GET\", \"POST\"])\n        def index():\n            return \"Hello World\"\n    \n        @app.route(\"/\", methods=[\"PUT\"])\n        def index_put():\n            return \"Aha!\"\n    \n>       rv = client.open(\"/\", method=\"OPTIONS\")\n\ntests/test_basic.py:47: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \nsrc/flask/testing.py:209: in open\n    builder = EnvironBuilder(self.application, *args, **kwargs)\nsrc/flask/testing.py:70: in __init__\n    url = url_parse(path)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nurl = '/', scheme = None, allow_fragments = True\n\n    def url_parse(\n        url: str, scheme: str | None = None, allow_fragments: bool = True\n    ) -> BaseURL:\n        \"\"\"Parses a URL from a string into a :class:`URL` tuple.  If the URL\n        is lacking a scheme it can be provided as second argument. Otherwise,\n        it is ignored.  Optionally fragments can be stripped from the URL\n        by setting `allow_fragments` to `False`.\n    \n        The inverse of this function is :func:`url_unparse`.\n    \n        :param url: the URL to parse.\n        :param scheme: the default schema to use if the URL is schemaless.\n        :param allow_fragments: if set to `False` a fragment will be removed\n                                from the URL.\n    \n        .. deprecated:: 2.3\n            Will be removed in Werkzeug 3.0. Use ``urllib.parse.urlsplit`` instead.\n        \"\"\"\n>       warnings.warn(\n            \"'werkzeug.urls.url_parse' is deprecated and will be removed in Werkzeug 3.0.\"\n            \" Use 'urllib.parse.urlsplit' instead.\",\n            DeprecationWarning,\n            stacklevel=2,\n        )\nE       DeprecationWarning: 'werkzeug.urls.url_parse' is deprecated and will be removed in Werkzeug 3.0. Use 'urllib.parse.urlsplit' instead.\n\n/opt/miniconda3/envs/testbed/lib/python3.9/site-packages/werkzeug/urls.py:505: DeprecationWarning\n____________________________ test_method_route[get] ____________________________\n\napp = <Flask 'flask_test'>, client = <FlaskClient <Flask 'flask_test'>>\nmethod = 'get'\n\n    @pytest.mark.parametrize(\"method\", [\"get\", \"post\", \"put\", \"delete\", \"patch\"])\n    def test_method_route(app, client, method):\n        method_route = getattr(app, method)\n        client_method = getattr(client, method)\n    \n        @method_route(\"/\")\n        def hello():\n            return \"Hello\"\n    \n>       assert client_method(\"/\").data == b\"Hello\"\n\ntests/test_basic.py:60: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n/opt/miniconda3/envs/testbed/lib/python3.9/site-packages/werkzeug/test.py:1243: in get\n    return self.open(*args, **kw)\nsrc/flask/testing.py:209: in open\n    builder = EnvironBuilder(self.application, *args, **kwargs)\nsrc/flask/testing.py:70: in __init__\n    url = url_parse(path)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nurl = '/', scheme = None, allow_fragments = True\n\n    def url_parse(\n        url: str, scheme: str | None = None, allow_fragments: bool = True\n    ) -> BaseURL:\n        \"\"\"Parses a URL from a string into a :class:`URL` tuple.  If the URL\n        is lacking a scheme it can be provided as second argument. Otherwise,\n        it is ignored.  Optionally fragments can be stripped from the URL\n        by setting `allow_fragments` to `False`.\n    \n        The inverse of this function is :func:`url_unparse`.\n    \n        :param url: the URL to parse.\n        :param scheme: the default schema to use if the URL is schemaless.\n        :param allow_fragments: if set to `False` a fragment will be removed\n                                from the URL.\n    \n        .. deprecated:: 2.3\n            Will be removed in Werkzeug 3.0. Use ``urllib.parse.urlsplit`` instead.\n        \"\"\"\n>       warnings.warn(\n            \"'werkzeug.urls.url_parse' is deprecated and will be removed in Werkzeug 3.0.\"\n            \" Use 'urllib.parse.urlsplit' instead.\",\n            DeprecationWarning,\n            stacklevel=2,\n        )\nE       DeprecationWarning: 'werkzeug.urls.url_parse' is deprecated and will be removed in Werkzeug 3.0. Use 'urllib.parse.urlsplit' instead.\n\n/opt/miniconda3/envs/testbed/lib/python3.9/site-packages/werkzeug/urls.py:505: DeprecationWarning\n___________________________ test_method_route[post] ____________________________\n\napp = <Flask 'flask_test'>, client = <FlaskClient <Flask 'flask_test'>>\nmethod = 'post'\n\n    @pytest.mark.parametrize(\"method\", [\"get\", \"post\", \"put\", \"delete\", \"patch\"])\n    def test_method_route(app, client, method):\n        method_route = getattr(app, method)\n        client_method = getattr(client, method)\n    \n        @method_route(\"/\")\n        def hello():\n            return \"Hello\"\n    \n>       assert client_method(\"/\").data == b\"Hello\"\n\ntests/test_basic.py:60: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n/opt/miniconda3/envs/testbed/lib/python3.9/site-packages/werkzeug/test.py:1248: in post\n    return self.open(*args, **kw)\nsrc/flask/testing.py:209: in open\n    builder = EnvironBuilder(self.application, *args, **kwargs)\nsrc/flask/testing.py:70: in __init__\n    url = url_parse(path)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nurl = '/', scheme = None, allow_fragments = True\n\n    def url_parse(\n        url: str, scheme: str | None = None, allow_fragments: bool = True\n    ) -> BaseURL:\n        \"\"\"Parses a URL from a string into a :class:`URL` tuple.  If the URL\n        is lacking a scheme it can be provided as second argument. Otherwise,\n        it is ignored.  Optionally fragments can be stripped from the URL\n        by setting `allow_fragments` to `False`.\n    \n        The inverse of this function is :func:`url_unparse`.\n    \n        :param url: the URL to parse.\n        :param scheme: the default schema to use if the URL is schemaless.\n        :param allow_fragments: if set to `False` a fragment will be removed\n                                from the URL.\n    \n        .. deprecated:: 2.3\n            Will be removed in Werkzeug 3.0. Use ``urllib.parse.urlsplit`` instead.\n        \"\"\"\n>       warnings.warn(\n            \"'werkzeug.urls.url_parse' is deprecated and will be removed in Werkzeug 3.0.\"\n            \" Use 'urllib.parse.urlsplit' instead.\",\n            DeprecationWarning,\n            stacklevel=2,\n        )\nE       DeprecationWarning: 'werkzeug.urls.url_parse' is deprecated and will be removed in Werkzeug 3.0. Use 'urllib.parse.urlsplit' instead.\n\n/opt/miniconda3/envs/testbed/lib/python3.9/site-packages/werkzeug/urls.py:505: DeprecationWarning\n____________________________ test_method_route[put] ____________________________\n\napp = <Flask 'flask_test'>, client = <FlaskClient <Flask 'flask_test'>>\nmethod = 'put'\n\n    @pytest.mark.parametrize(\"method\", [\"get\", \"post\", \"put\", \"delete\", \"patch\"])\n    def test_method_route(app, client, method):\n        method_route = getattr(app, method)\n        client_method = getattr(client, method)\n    \n        @method_route(\"/\")\n        def hello():\n            return \"Hello\"\n    \n>       assert client_method(\"/\").data == b\"Hello\"\n\ntests/test_basic.py:60: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n/opt/miniconda3/envs/testbed/lib/python3.9/site-packages/werkzeug/test.py:1253: in put\n    return self.open(*args, **kw)\nsrc/flask/testing.py:209: in open\n    builder = EnvironBuilder(self.application, *args, **kwargs)\nsrc/flask/testing.py:70: in __init__\n    url = url_parse(path)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nurl = '/', scheme = None, allow_fragments = True\n\n    def url_parse(\n        url: str, scheme: str | None = None, allow_fragments: bool = True\n    ) -> BaseURL:\n        \"\"\"Parses a URL from a string into a :class:`URL` tuple.  If the URL\n        is lacking a scheme it can be provided as second argument. Otherwise,\n        it is ignored.  Optionally fragments can be stripped from the URL\n        by setting `allow_fragments` to `False`.\n    \n        The inverse of this function is :func:`url_unparse`.\n    \n        :param url: the URL to parse.\n        :param scheme: the default schema to use if the URL is schemaless.\n        :param allow_fragments: if set to `False` a fragment will be removed\n                                from the URL.\n    \n        .. deprecated:: 2.3\n            Will be removed in Werkzeug 3.0. Use ``urllib.parse.urlsplit`` instead.\n        \"\"\"\n>       warnings.warn(\n            \"'werkzeug.urls.url_parse' is deprecated and will be removed in Werkzeug 3.0.\"\n            \" Use 'urllib.parse.urlsplit' instead.\",\n            DeprecationWarning,\n            stacklevel=2,\n        )\nE       DeprecationWarning: 'werkzeug.urls.url_parse' is deprecated and will be removed in Werkzeug 3.0. Use 'urllib.parse.urlsplit' instead.\n\n/opt/miniconda3/envs/testbed/lib/python3.9/site-packages/werkzeug/urls.py:505: DeprecationWarning\n__________________________ test_method_route[delete] ___________________________\n\napp = <Flask 'flask_test'>, client = <FlaskClient <Flask 'flask_test'>>\nmethod = 'delete'\n\n    @pytest.mark.parametrize(\"method\", [\"get\", \"post\", \"put\", \"delete\", \"patch\"])\n    def test_method_route(app, client, method):\n        method_route = getattr(app, method)\n        client_method = getattr(client, method)\n    \n        @method_route(\"/\")\n        def hello():\n            return \"Hello\"\n    \n>       assert client_method(\"/\").data == b\"Hello\"\n\ntests/test_basic.py:60: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n/opt/miniconda3/envs/testbed/lib/python3.9/site-packages/werkzeug/test.py:1258: in delete\n    return self.open(*args, **kw)\nsrc/flask/testing.py:209: in open\n    builder = EnvironBuilder(self.application, *args, **kwargs)\nsrc/flask/testing.py:70: in __init__\n    url = url_parse(path)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nurl = '/', scheme = None, allow_fragments = True\n\n    def url_parse(\n        url: str, scheme: str | None = None, allow_fragments: bool = True\n    ) -> BaseURL:\n        \"\"\"Parses a URL from a string into a :class:`URL` tuple.  If the URL\n        is lacking a scheme it can be provided as second argument. Otherwise,\n        it is ignored.  Optionally fragments can be stripped from the URL\n        by setting `allow_fragments` to `False`.\n    \n        The inverse of this function is :func:`url_unparse`.\n    \n        :param url: the URL to parse.\n        :param scheme: the default schema to use if the URL is schemaless.\n        :param allow_fragments: if set to `False` a fragment will be removed\n                                from the URL.\n    \n        .. deprecated:: 2.3\n            Will be removed in Werkzeug 3.0. Use ``urllib.parse.urlsplit`` instead.\n        \"\"\"\n>       warnings.warn(\n            \"'werkzeug.urls.url_parse' is deprecated and will be removed in Werkzeug 3.0.\"\n            \" Use 'urllib.parse.urlsplit' instead.\",\n            DeprecationWarning,\n            stacklevel=2,\n        )\nE       DeprecationWarning: 'werkzeug.urls.url_parse' is deprecated and will be removed in Werkzeug 3.0. Use 'urllib.parse.urlsplit' instead.\n\n/opt/miniconda3/envs/testbed/lib/python3.9/site-packages/werkzeug/urls.py:505: DeprecationWarning\n___________________________ test_method_route[patch] ___________________________\n\napp = <Flask 'flask_test'>, client = <FlaskClient <Flask 'flask_test'>>\nmethod = 'patch'\n\n    @pytest.mark.parametrize(\"method\", [\"get\", \"post\", \"put\", \"delete\", \"patch\"])\n    def test_method_route(app, client, method):\n        method_route = getattr(app, method)\n        client_method = getattr(client, method)\n    \n        @method_route(\"/\")\n        def hello():\n            return \"Hello\"\n    \n>       assert client_method(\"/\").data == b\"Hello\"\n\ntests/test_basic.py:60: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n/opt/miniconda3/envs/testbed/lib/python3.9/site-packages/werkzeug/test.py:1263: in patch\n    return self.open(*args, **kw)\nsrc/flask/testing.py:209: in open\n    builder = EnvironBuilder(self.application, *args, **kwargs)\nsrc/flask/testing.py:70: in __init__\n    url = url_parse(path)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nurl = '/', scheme = None, allow_fragments = True\n\n    def url_parse(\n        url: str, scheme: str | None = None, allow_fragments: bool = True\n    ) -> BaseURL:\n        \"\"\"Parses a URL from a string into a :class:`URL` tuple.  If the URL\n        is lacking a scheme it can be provided as second argument. Otherwise,\n        it is ignored.  Optionally fragments can be stripped from the URL\n        by setting `allow_fragments` to `False`.\n    \n        The inverse of this function is :func:`url_unparse`.\n    \n        :param url: the URL to parse.\n        :param scheme: the default schema to use if the URL is schemaless.\n        :param allow_fragments: if set to `False` a fragment will be removed\n                                from the URL.\n    \n        .. deprecated:: 2.3\n            Will be removed in Werkzeug 3.0. Use ``urllib.parse.urlsplit`` instead.\n        \"\"\"\n>       warnings.warn(\n            \"'werkzeug.urls.url_parse' is deprecated and will be removed in Werkzeug 3.0.\"\n            \" Use 'urllib.parse.urlsplit' instead.\",\n            DeprecationWarning,\n            stacklevel=2,\n        )\nE       DeprecationWarning: 'werkzeug.urls.url_parse' is deprecated and will be removed in Werkzeug 3.0. Use 'urllib.parse.urlsplit' instead.\n\n/opt/miniconda3/envs/testbed/lib/python3.9/site-packages/werkzeug/urls.py:505: DeprecationWarning\n_____________________ test_provide_automatic_options_attr ______________________\n\n    def test_provide_automatic_options_attr():\n        app = flask.Flask(__name__)\n    \n        def index():\n            return \"Hello World!\"\n    \n        index.provide_automatic_options = False\n        app.route(\"/\")(index)\n>       rv = app.test_client().open(\"/\", method=\"OPTIONS\")\n\ntests/test_basic.py:76: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \nsrc/flask/testing.py:209: in open\n    builder = EnvironBuilder(self.application, *args, **kwargs)\nsrc/flask/testing.py:70: in __init__\n    url = url_parse(path)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nurl = '/', scheme = None, allow_fragments = True\n\n    def url_parse(\n        url: str, scheme: str | None = None, allow_fragments: bool = True\n    ) -> BaseURL:\n        \"\"\"Parses a URL from a string into a :class:`URL` tuple.  If the URL\n        is lacking a scheme it can be provided as second argument. Otherwise,\n        it is ignored.  Optionally fragments can be stripped from the URL\n        by setting `allow_fragments` to `False`.\n    \n        The inverse of this function is :func:`url_unparse`.\n    \n        :param url: the URL to parse.\n        :param scheme: the default schema to use if the URL is schemaless.\n        :param allow_fragments: if set to `False` a fragment will be removed\n                                from the URL.\n    \n        .. deprecated:: 2.3\n            Will be removed in Werkzeug 3.0. Use ``urllib.parse.urlsplit`` instead.\n        \"\"\"\n>       warnings.warn(\n            \"'werkzeug.urls.url_parse' is deprecated and will be removed in Werkzeug 3.0.\"\n            \" Use 'urllib.parse.urlsplit' instead.\",\n            DeprecationWarning,\n            stacklevel=2,\n        )\nE       DeprecationWarning: 'werkzeug.urls.url_parse' is deprecated and will be removed in Werkzeug 3.0. Use 'urllib.parse.urlsplit' instead.\n\n/opt/miniconda3/envs/testbed/lib/python3.9/site-packages/werkzeug/urls.py:505: DeprecationWarning\n_____________________ test_provide_automatic_options_kwarg _____________________\n\napp = <Flask 'flask_test'>, client = <FlaskClient <Flask 'flask_test'>>\n\n    def test_provide_automatic_options_kwarg(app, client):\n        def index():\n            return flask.request.method\n    \n        def more():\n            return flask.request.method\n    \n        app.add_url_rule(\"/\", view_func=index, provide_automatic_options=False)\n        app.add_url_rule(\n            \"/more\",\n            view_func=more,\n            methods=[\"GET\", \"POST\"],\n            provide_automatic_options=False,\n        )\n>       assert client.get(\"/\").data == b\"GET\"\n\ntests/test_basic.py:104: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n/opt/miniconda3/envs/testbed/lib/python3.9/site-packages/werkzeug/test.py:1243: in get\n    return self.open(*args, **kw)\nsrc/flask/testing.py:209: in open\n    builder = EnvironBuilder(self.application, *args, **kwargs)\nsrc/flask/testing.py:70: in __init__\n    url = url_parse(path)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nurl = '/', scheme = None, allow_fragments = True\n\n    def url_parse(\n        url: str, scheme: str | None = None, allow_fragments: bool = True\n    ) -> BaseURL:\n        \"\"\"Parses a URL from a string into a :class:`URL` tuple.  If the URL\n        is lacking a scheme it can be provided as second argument. Otherwise,\n        it is ignored.  Optionally fragments can be stripped from the URL\n        by setting `allow_fragments` to `False`.\n    \n        The inverse of this function is :func:`url_unparse`.\n    \n        :param url: the URL to parse.\n        :param scheme: the default schema to use if the URL is schemaless.\n        :param allow_fragments: if set to `False` a fragment will be removed\n                                from the URL.\n    \n        .. deprecated:: 2.3\n            Will be removed in Werkzeug 3.0. Use ``urllib.parse.urlsplit`` instead.\n        \"\"\"\n>       warnings.warn(\n            \"'werkzeug.urls.url_parse' is deprecated and will be removed in Werkzeug 3.0.\"\n            \" Use 'urllib.parse.urlsplit' instead.\",\n            DeprecationWarning,\n            stacklevel=2,\n        )\nE       DeprecationWarning: 'werkzeug.urls.url_parse' is deprecated and will be removed in Werkzeug 3.0. Use 'urllib.parse.urlsplit' instead.\n\n/opt/miniconda3/envs/testbed/lib/python3.9/site-packages/werkzeug/urls.py:505: DeprecationWarning\n___________________________ test_request_dispatching ___________________________\n\napp = <Flask 'flask_test'>, client = <FlaskClient <Flask 'flask_test'>>\n\n    def test_request_dispatching(app, client):\n        @app.route(\"/\")\n        def index():\n            return flask.request.method\n    \n        @app.route(\"/more\", methods=[\"GET\", \"POST\"])\n        def more():\n            return flask.request.method\n    \n>       assert client.get(\"/\").data == b\"GET\"\n\ntests/test_basic.py:136: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n/opt/miniconda3/envs/testbed/lib/python3.9/site-packages/werkzeug/test.py:1243: in get\n    return self.open(*args, **kw)\nsrc/flask/testing.py:209: in open\n    builder = EnvironBuilder(self.application, *args, **kwargs)\nsrc/flask/testing.py:70: in __init__\n    url = url_parse(path)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nurl = '/', scheme = None, allow_fragments = True\n\n    def url_parse(\n        url: str, scheme: str | None = None, allow_fragments: bool = True\n    ) -> BaseURL:\n        \"\"\"Parses a URL from a string into a :class:`URL` tuple.  If the URL\n        is lacking a scheme it can be provided as second argument. Otherwise,\n        it is ignored.  Optionally fragments can be stripped from the URL\n        by setting `allow_fragments` to `False`.\n    \n        The inverse of this function is :func:`url_unparse`.\n    \n        :param url: the URL to parse.\n        :param scheme: the default schema to use if the URL is schemaless.\n        :param allow_fragments: if set to `False` a fragment will be removed\n                                from the URL.\n    \n        .. deprecated:: 2.3\n            Will be removed in Werkzeug 3.0. Use ``urllib.parse.urlsplit`` instead.\n        \"\"\"\n>       warnings.warn(\n            \"'werkzeug.urls.url_parse' is deprecated and will be removed in Werkzeug 3.0.\"\n            \" Use 'urllib.parse.urlsplit' instead.\",\n            DeprecationWarning,\n            stacklevel=2,\n        )\nE       DeprecationWarning: 'werkzeug.urls.url_parse' is deprecated and will be removed in Werkzeug 3.0. Use 'urllib.parse.urlsplit' instead.\n\n/opt/miniconda3/envs/testbed/lib/python3.9/site-packages/werkzeug/urls.py:505: DeprecationWarning\n_______________________________ test_url_mapping _______________________________\n\napp = <Flask 'flask_test'>, client = <FlaskClient <Flask 'flask_test'>>\n\n    def test_url_mapping(app, client):\n        random_uuid4 = \"7eb41166-9ebf-4d26-b771-ea3f54f8b383\"\n    \n        def index():\n            return flask.request.method\n    \n        def more():\n            return flask.request.method\n    \n        def options():\n            return random_uuid4\n    \n        app.add_url_rule(\"/\", \"index\", index)\n        app.add_url_rule(\"/more\", \"more\", more, methods=[\"GET\", \"POST\"])\n    \n        # Issue 1288: Test that automatic options are not added\n        #             when non-uppercase 'options' in methods\n        app.add_url_rule(\"/options\", \"options\", options, methods=[\"options\"])\n    \n>       assert client.get(\"/\").data == b\"GET\"\n\ntests/test_basic.py:177: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n/opt/miniconda3/envs/testbed/lib/python3.9/site-packages/werkzeug/test.py:1243: in get\n    return self.open(*args, **kw)\nsrc/flask/testing.py:209: in open\n    builder = EnvironBuilder(self.application, *args, **kwargs)\nsrc/flask/testing.py:70: in __init__\n    url = url_parse(path)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nurl = '/', scheme = None, allow_fragments = True\n\n    def url_parse(\n        url: str, scheme: str | None = None, allow_fragments: bool = True\n    ) -> BaseURL:\n        \"\"\"Parses a URL from a string into a :class:`URL` tuple.  If the URL\n        is lacking a scheme it can be provided as second argument. Otherwise,\n        it is ignored.  Optionally fragments can be stripped from the URL\n        by setting `allow_fragments` to `False`.\n    \n        The inverse of this function is :func:`url_unparse`.\n    \n        :param url: the URL to parse.\n        :param scheme: the default schema to use if the URL is schemaless.\n        :param allow_fragments: if set to `False` a fragment will be removed\n                                from the URL.\n    \n        .. deprecated:: 2.3\n            Will be removed in Werkzeug 3.0. Use ``urllib.parse.urlsplit`` instead.\n        \"\"\"\n>       warnings.warn(\n            \"'werkzeug.urls.url_parse' is deprecated and will be removed in Werkzeug 3.0.\"\n            \" Use 'urllib.parse.urlsplit' instead.\",\n            DeprecationWarning,\n            stacklevel=2,\n        )\nE       DeprecationWarning: 'werkzeug.urls.url_parse' is deprecated and will be removed in Werkzeug 3.0. Use 'urllib.parse.urlsplit' instead.\n\n/opt/miniconda3/envs/testbed/lib/python3.9/site-packages/werkzeug/urls.py:505: DeprecationWarning\n____________________________ test_werkzeug_routing _____________________________\n\napp = <Flask 'flask_test'>, client = <FlaskClient <Flask 'flask_test'>>\n\n    def test_werkzeug_routing(app, client):\n        from werkzeug.routing import Submount, Rule\n    \n        app.url_map.add(\n            Submount(\"/foo\", [Rule(\"/bar\", endpoint=\"bar\"), Rule(\"/\", endpoint=\"index\")])\n        )\n    \n        def bar():\n            return \"bar\"\n    \n        def index():\n            return \"index\"\n    \n        app.view_functions[\"bar\"] = bar\n        app.view_functions[\"index\"] = index\n    \n>       assert client.get(\"/foo/\").data == b\"index\"\n\ntests/test_basic.py:210: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n/opt/miniconda3/envs/testbed/lib/python3.9/site-packages/werkzeug/test.py:1243: in get\n    return self.open(*args, **kw)\nsrc/flask/testing.py:209: in open\n    builder = EnvironBuilder(self.application, *args, **kwargs)\nsrc/flask/testing.py:70: in __init__\n    url = url_parse(path)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nurl = '/foo/', scheme = None, allow_fragments = True\n\n    def url_parse(\n        url: str, scheme: str | None = None, allow_fragments: bool = True\n    ) -> BaseURL:\n        \"\"\"Parses a URL from a string into a :class:`URL` tuple.  If the URL\n        is lacking a scheme it can be provided as second argument. Otherwise,\n        it is ignored.  Optionally fragments can be stripped from the URL\n        by setting `allow_fragments` to `False`.\n    \n        The inverse of this function is :func:`url_unparse`.\n    \n        :param url: the URL to parse.\n        :param scheme: the default schema to use if the URL is schemaless.\n        :param allow_fragments: if set to `False` a fragment will be removed\n                                from the URL.\n    \n        .. deprecated:: 2.3\n            Will be removed in Werkzeug 3.0. Use ``urllib.parse.urlsplit`` instead.\n        \"\"\"\n>       warnings.warn(\n            \"'werkzeug.urls.url_parse' is deprecated and will be removed in Werkzeug 3.0.\"\n            \" Use 'urllib.parse.urlsplit' instead.\",\n            DeprecationWarning,\n            stacklevel=2,\n        )\nE       DeprecationWarning: 'werkzeug.urls.url_parse' is deprecated and will be removed in Werkzeug 3.0. Use 'urllib.parse.urlsplit' instead.\n\n/opt/miniconda3/envs/testbed/lib/python3.9/site-packages/werkzeug/urls.py:505: DeprecationWarning\n___________________________ test_endpoint_decorator ____________________________\n\napp = <Flask 'flask_test'>, client = <FlaskClient <Flask 'flask_test'>>\n\n    def test_endpoint_decorator(app, client):\n        from werkzeug.routing import Submount, Rule\n    \n        app.url_map.add(\n            Submount(\"/foo\", [Rule(\"/bar\", endpoint=\"bar\"), Rule(\"/\", endpoint=\"index\")])\n        )\n    \n        @app.endpoint(\"bar\")\n        def bar():\n            return \"bar\"\n    \n        @app.endpoint(\"index\")\n        def index():\n            return \"index\"\n    \n>       assert client.get(\"/foo/\").data == b\"index\"\n\ntests/test_basic.py:229: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n/opt/miniconda3/envs/testbed/lib/python3.9/site-packages/werkzeug/test.py:1243: in get\n    return self.open(*args, **kw)\nsrc/flask/testing.py:209: in open\n    builder = EnvironBuilder(self.application, *args, **kwargs)\nsrc/flask/testing.py:70: in __init__\n    url = url_parse(path)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nurl = '/foo/', scheme = None, allow_fragments = True\n\n    def url_parse(\n        url: str, scheme: str | None = None, allow_fragments: bool = True\n    ) -> BaseURL:\n        \"\"\"Parses a URL from a string into a :class:`URL` tuple.  If the URL\n        is lacking a scheme it can be provided as second argument. Otherwise,\n        it is ignored.  Optionally fragments can be stripped from the URL\n        by setting `allow_fragments` to `False`.\n    \n        The inverse of this function is :func:`url_unparse`.\n    \n        :param url: the URL to parse.\n        :param scheme: the default schema to use if the URL is schemaless.\n        :param allow_fragments: if set to `False` a fragment will be removed\n                                from the URL.\n    \n        .. deprecated:: 2.3\n            Will be removed in Werkzeug 3.0. Use ``urllib.parse.urlsplit`` instead.\n        \"\"\"\n>       warnings.warn(\n            \"'werkzeug.urls.url_parse' is deprecated and will be removed in Werkzeug 3.0.\"\n            \" Use 'urllib.parse.urlsplit' instead.\",\n            DeprecationWarning,\n            stacklevel=2,\n        )\nE       DeprecationWarning: 'werkzeug.urls.url_parse' is deprecated and will be removed in Werkzeug 3.0. Use 'urllib.parse.urlsplit' instead.\n\n/opt/miniconda3/envs/testbed/lib/python3.9/site-packages/werkzeug/urls.py:505: DeprecationWarning\n_________________________________ test_session _________________________________\n\napp = <Flask 'flask_test'>, client = <FlaskClient <Flask 'flask_test'>>\n\n    def test_session(app, client):\n        @app.route(\"/set\", methods=[\"POST\"])\n        def set():\n            assert not flask.session.accessed\n            assert not flask.session.modified\n            flask.session[\"value\"] = flask.request.form[\"value\"]\n            assert flask.session.accessed\n            assert flask.session.modified\n            return \"value set\"\n    \n        @app.route(\"/get\")\n        def get():\n            assert not flask.session.accessed\n            assert not flask.session.modified\n            v = flask.session.get(\"value\", \"None\")\n            assert flask.session.accessed\n            assert not flask.session.modified\n            return v\n    \n>       assert client.post(\"/set\", data={\"value\": \"42\"}).data == b\"value set\"\n\ntests/test_basic.py:252: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n/opt/miniconda3/envs/testbed/lib/python3.9/site-packages/werkzeug/test.py:1248: in post\n    return self.open(*args, **kw)\nsrc/flask/testing.py:209: in open\n    builder = EnvironBuilder(self.application, *args, **kwargs)\nsrc/flask/testing.py:70: in __init__\n    url = url_parse(path)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nurl = '/set', scheme = None, allow_fragments = True\n\n    def url_parse(\n        url: str, scheme: str | None = None, allow_fragments: bool = True\n    ) -> BaseURL:\n        \"\"\"Parses a URL from a string into a :class:`URL` tuple.  If the URL\n        is lacking a scheme it can be provided as second argument. Otherwise,\n        it is ignored.  Optionally fragments can be stripped from the URL\n        by setting `allow_fragments` to `False`.\n    \n        The inverse of this function is :func:`url_unparse`.\n    \n        :param url: the URL to parse.\n        :param scheme: the default schema to use if the URL is schemaless.\n        :param allow_fragments: if set to `False` a fragment will be removed\n                                from the URL.\n    \n        .. deprecated:: 2.3\n            Will be removed in Werkzeug 3.0. Use ``urllib.parse.urlsplit`` instead.\n        \"\"\"\n>       warnings.warn(\n            \"'werkzeug.urls.url_parse' is deprecated and will be removed in Werkzeug 3.0.\"\n            \" Use 'urllib.parse.urlsplit' instead.\",\n            DeprecationWarning,\n            stacklevel=2,\n        )\nE       DeprecationWarning: 'werkzeug.urls.url_parse' is deprecated and will be removed in Werkzeug 3.0. Use 'urllib.parse.urlsplit' instead.\n\n/opt/miniconda3/envs/testbed/lib/python3.9/site-packages/werkzeug/urls.py:505: DeprecationWarning\n________________________ test_session_using_server_name ________________________\n\napp = <Flask 'flask_test'>, client = <FlaskClient <Flask 'flask_test'>>\n\n    def test_session_using_server_name(app, client):\n        app.config.update(SERVER_NAME=\"example.com\")\n    \n        @app.route(\"/\")\n        def index():\n            flask.session[\"testing\"] = 42\n            return \"Hello World\"\n    \n>       rv = client.get(\"/\", \"http://example.com/\")\n\ntests/test_basic.py:264: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n/opt/miniconda3/envs/testbed/lib/python3.9/site-packages/werkzeug/test.py:1243: in get\n    return self.open(*args, **kw)\nsrc/flask/testing.py:216: in open\n    return super().open(  # type: ignore\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <FlaskClient <Flask 'flask_test'>>, buffered = False\nfollow_redirects = False, args = (<Request 'http://example.com/' [GET]>,)\nkwargs = {'as_tuple': False}, request = None\n\n    def open(\n        self,\n        *args: t.Any,\n        buffered: bool = False,\n        follow_redirects: bool = False,\n        **kwargs: t.Any,\n    ) -> TestResponse:\n        \"\"\"Generate an environ dict from the given arguments, make a\n        request to the application using it, and return the response.\n    \n        :param args: Passed to :class:`EnvironBuilder` to create the\n            environ for the request. If a single arg is passed, it can\n            be an existing :class:`EnvironBuilder` or an environ dict.\n        :param buffered: Convert the iterator returned by the app into\n            a list. If the iterator has a ``close()`` method, it is\n            called automatically.\n        :param follow_redirects: Make additional requests to follow HTTP\n            redirects until a non-redirect status is returned.\n            :attr:`TestResponse.history` lists the intermediate\n            responses.\n    \n        .. versionchanged:: 2.1\n            Removed the ``as_tuple`` parameter.\n    \n        .. versionchanged:: 2.0\n            The request input stream is closed when calling\n            ``response.close()``. Input streams for redirects are\n            automatically closed.\n    \n        .. versionchanged:: 0.5\n            If a dict is provided as file in the dict for the ``data``\n            parameter the content type has to be called ``content_type``\n            instead of ``mimetype``. This change was made for\n            consistency with :class:`werkzeug.FileWrapper`.\n    \n        .. versionchanged:: 0.5\n            Added the ``follow_redirects`` parameter.\n        \"\"\"\n        request: Request | None = None\n    \n        if not kwargs and len(args) == 1:\n            arg = args[0]\n    \n            if isinstance(arg, EnvironBuilder):\n                request = arg.get_request()\n            elif isinstance(arg, dict):\n                request = EnvironBuilder.from_environ(arg).get_request()\n            elif isinstance(arg, Request):\n                request = arg\n    \n        if request is None:\n>           builder = EnvironBuilder(*args, **kwargs)\nE           TypeError: __init__() got an unexpected keyword argument 'as_tuple'\n\n/opt/miniconda3/envs/testbed/lib/python3.9/site-packages/werkzeug/test.py:1190: TypeError\n___________________ test_session_using_server_name_and_port ____________________\n\napp = <Flask 'flask_test'>, client = <FlaskClient <Flask 'flask_test'>>\n\n    def test_session_using_server_name_and_port(app, client):\n        app.config.update(SERVER_NAME=\"example.com:8080\")\n    \n        @app.route(\"/\")\n        def index():\n            flask.session[\"testing\"] = 42\n            return \"Hello World\"\n    \n>       rv = client.get(\"/\", \"http://example.com:8080/\")\n\ntests/test_basic.py:277: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n/opt/miniconda3/envs/testbed/lib/python3.9/site-packages/werkzeug/test.py:1243: in get\n    return self.open(*args, **kw)\nsrc/flask/testing.py:216: in open\n    return super().open(  # type: ignore\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <FlaskClient <Flask 'flask_test'>>, buffered = False\nfollow_redirects = False, args = (<Request 'http://example.com:8080/' [GET]>,)\nkwargs = {'as_tuple': False}, request = None\n\n    def open(\n        self,\n        *args: t.Any,\n        buffered: bool = False,\n        follow_redirects: bool = False,\n        **kwargs: t.Any,\n    ) -> TestResponse:\n        \"\"\"Generate an environ dict from the given arguments, make a\n        request to the application using it, and return the response.\n    \n        :param args: Passed to :class:`EnvironBuilder` to create the\n            environ for the request. If a single arg is passed, it can\n            be an existing :class:`EnvironBuilder` or an environ dict.\n        :param buffered: Convert the iterator returned by the app into\n            a list. If the iterator has a ``close()`` method, it is\n            called automatically.\n        :param follow_redirects: Make additional requests to follow HTTP\n            redirects until a non-redirect status is returned.\n            :attr:`TestResponse.history` lists the intermediate\n            responses.\n    \n        .. versionchanged:: 2.1\n            Removed the ``as_tuple`` parameter.\n    \n        .. versionchanged:: 2.0\n            The request input stream is closed when calling\n            ``response.close()``. Input streams for redirects are\n            automatically closed.\n    \n        .. versionchanged:: 0.5\n            If a dict is provided as file in the dict for the ``data``\n            parameter the content type has to be called ``content_type``\n            instead of ``mimetype``. This change was made for\n            consistency with :class:`werkzeug.FileWrapper`.\n    \n        .. versionchanged:: 0.5\n            Added the ``follow_redirects`` parameter.\n        \"\"\"\n        request: Request | None = None\n    \n        if not kwargs and len(args) == 1:\n            arg = args[0]\n    \n            if isinstance(arg, EnvironBuilder):\n                request = arg.get_request()\n            elif isinstance(arg, dict):\n                request = EnvironBuilder.from_environ(arg).get_request()\n            elif isinstance(arg, Request):\n                request = arg\n    \n        if request is None:\n>           builder = EnvironBuilder(*args, **kwargs)\nE           TypeError: __init__() got an unexpected keyword argument 'as_tuple'\n\n/opt/miniconda3/envs/testbed/lib/python3.9/site-packages/werkzeug/test.py:1190: TypeError\n_________________ test_session_using_server_name_port_and_path _________________\n\napp = <Flask 'flask_test'>, client = <FlaskClient <Flask 'flask_test'>>\n\n    def test_session_using_server_name_port_and_path(app, client):\n        app.config.update(SERVER_NAME=\"example.com:8080\", APPLICATION_ROOT=\"/foo\")\n    \n        @app.route(\"/\")\n        def index():\n            flask.session[\"testing\"] = 42\n            return \"Hello World\"\n    \n>       rv = client.get(\"/\", \"http://example.com:8080/foo\")\n\ntests/test_basic.py:290: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n/opt/miniconda3/envs/testbed/lib/python3.9/site-packages/werkzeug/test.py:1243: in get\n    return self.open(*args, **kw)\nsrc/flask/testing.py:216: in open\n    return super().open(  # type: ignore\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <FlaskClient <Flask 'flask_test'>>, buffered = False\nfollow_redirects = False\nargs = (<Request 'http://example.com:8080/foo/' [GET]>,)\nkwargs = {'as_tuple': False}, request = None\n\n    def open(\n        self,\n        *args: t.Any,\n        buffered: bool = False,\n        follow_redirects: bool = False,\n        **kwargs: t.Any,\n    ) -> TestResponse:\n        \"\"\"Generate an environ dict from the given arguments, make a\n        request to the application using it, and return the response.\n    \n        :param args: Passed to :class:`EnvironBuilder` to create the\n            environ for the request. If a single arg is passed, it can\n            be an existing :class:`EnvironBuilder` or an environ dict.\n        :param buffered: Convert the iterator returned by the app into\n            a list. If the iterator has a ``close()`` method, it is\n            called automatically.\n        :param follow_redirects: Make additional requests to follow HTTP\n            redirects until a non-redirect status is returned.\n            :attr:`TestResponse.history` lists the intermediate\n            responses.\n    \n        .. versionchanged:: 2.1\n            Removed the ``as_tuple`` parameter.\n    \n        .. versionchanged:: 2.0\n            The request input stream is closed when calling\n            ``response.close()``. Input streams for redirects are\n            automatically closed.\n    \n        .. versionchanged:: 0.5\n            If a dict is provided as file in the dict for the ``data``\n            parameter the content type has to be called ``content_type``\n            instead of ``mimetype``. This change was made for\n            consistency with :class:`werkzeug.FileWrapper`.\n    \n        .. versionchanged:: 0.5\n            Added the ``follow_redirects`` parameter.\n        \"\"\"\n        request: Request | None = None\n    \n        if not kwargs and len(args) == 1:\n            arg = args[0]\n    \n            if isinstance(arg, EnvironBuilder):\n                request = arg.get_request()\n            elif isinstance(arg, dict):\n                request = EnvironBuilder.from_environ(arg).get_request()\n            elif isinstance(arg, Request):\n                request = arg\n    \n        if request is None:\n>           builder = EnvironBuilder(*args, **kwargs)\nE           TypeError: __init__() got an unexpected keyword argument 'as_tuple'\n\n/opt/miniconda3/envs/testbed/lib/python3.9/site-packages/werkzeug/test.py:1190: TypeError\n_____________________ test_session_using_application_root ______________________\n\napp = <Flask 'flask_test'>, client = <FlaskClient <Flask 'flask_test'>>\n\n    def test_session_using_application_root(app, client):\n        class PrefixPathMiddleware:\n            def __init__(self, app, prefix):\n                self.app = app\n                self.prefix = prefix\n    \n            def __call__(self, environ, start_response):\n                environ[\"SCRIPT_NAME\"] = self.prefix\n                return self.app(environ, start_response)\n    \n        app.wsgi_app = PrefixPathMiddleware(app.wsgi_app, \"/bar\")\n        app.config.update(APPLICATION_ROOT=\"/bar\")\n    \n        @app.route(\"/\")\n        def index():\n            flask.session[\"testing\"] = 42\n            return \"Hello World\"\n    \n>       rv = client.get(\"/\", \"http://example.com:8080/\")\n\ntests/test_basic.py:314: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n/opt/miniconda3/envs/testbed/lib/python3.9/site-packages/werkzeug/test.py:1243: in get\n    return self.open(*args, **kw)\nsrc/flask/testing.py:216: in open\n    return super().open(  # type: ignore\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <FlaskClient <Flask 'flask_test'>>, buffered = False\nfollow_redirects = False, args = (<Request 'http://example.com:8080/' [GET]>,)\nkwargs = {'as_tuple': False}, request = None\n\n    def open(\n        self,\n        *args: t.Any,\n        buffered: bool = False,\n        follow_redirects: bool = False,\n        **kwargs: t.Any,\n    ) -> TestResponse:\n        \"\"\"Generate an environ dict from the given arguments, make a\n        request to the application using it, and return the response.\n    \n        :param args: Passed to :class:`EnvironBuilder` to create the\n            environ for the request. If a single arg is passed, it can\n            be an existing :class:`EnvironBuilder` or an environ dict.\n        :param buffered: Convert the iterator returned by the app into\n            a list. If the iterator has a ``close()`` method, it is\n            called automatically.\n        :param follow_redirects: Make additional requests to follow HTTP\n            redirects until a non-redirect status is returned.\n            :attr:`TestResponse.history` lists the intermediate\n            responses.\n    \n        .. versionchanged:: 2.1\n            Removed the ``as_tuple`` parameter.\n    \n        .. versionchanged:: 2.0\n            The request input stream is closed when calling\n            ``response.close()``. Input streams for redirects are\n            automatically closed.\n    \n        .. versionchanged:: 0.5\n            If a dict is provided as file in the dict for the ``data``\n            parameter the content type has to be called ``content_type``\n            instead of ``mimetype``. This change was made for\n            consistency with :class:`werkzeug.FileWrapper`.\n    \n        .. versionchanged:: 0.5\n            Added the ``follow_redirects`` parameter.\n        \"\"\"\n        request: Request | None = None\n    \n        if not kwargs and len(args) == 1:\n            arg = args[0]\n    \n            if isinstance(arg, EnvironBuilder):\n                request = arg.get_request()\n            elif isinstance(arg, dict):\n                request = EnvironBuilder.from_environ(arg).get_request()\n            elif isinstance(arg, Request):\n                request = arg\n    \n        if request is None:\n>           builder = EnvironBuilder(*args, **kwargs)\nE           TypeError: __init__() got an unexpected keyword argument 'as_tuple'\n\n/opt/miniconda3/envs/testbed/lib/python3.9/site-packages/werkzeug/test.py:1190: TypeError\n_____________________ test_session_using_session_settings ______________________\n\napp = <Flask 'flask_test'>, client = <FlaskClient <Flask 'flask_test'>>\n\n    def test_session_using_session_settings(app, client):\n        app.config.update(\n            SERVER_NAME=\"www.example.com:8080\",\n            APPLICATION_ROOT=\"/test\",\n            SESSION_COOKIE_DOMAIN=\".example.com\",\n            SESSION_COOKIE_HTTPONLY=False,\n            SESSION_COOKIE_SECURE=True,\n            SESSION_COOKIE_SAMESITE=\"Lax\",\n            SESSION_COOKIE_PATH=\"/\",\n        )\n    \n        @app.route(\"/\")\n        def index():\n            flask.session[\"testing\"] = 42\n            return \"Hello World\"\n    \n>       rv = client.get(\"/\", \"http://www.example.com:8080/test/\")\n\ntests/test_basic.py:334: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n/opt/miniconda3/envs/testbed/lib/python3.9/site-packages/werkzeug/test.py:1243: in get\n    return self.open(*args, **kw)\nsrc/flask/testing.py:216: in open\n    return super().open(  # type: ignore\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <FlaskClient <Flask 'flask_test'>>, buffered = False\nfollow_redirects = False\nargs = (<Request 'http://www.example.com:8080/test/' [GET]>,)\nkwargs = {'as_tuple': False}, request = None\n\n    def open(\n        self,\n        *args: t.Any,\n        buffered: bool = False,\n        follow_redirects: bool = False,\n        **kwargs: t.Any,\n    ) -> TestResponse:\n        \"\"\"Generate an environ dict from the given arguments, make a\n        request to the application using it, and return the response.\n    \n        :param args: Passed to :class:`EnvironBuilder` to create the\n            environ for the request. If a single arg is passed, it can\n            be an existing :class:`EnvironBuilder` or an environ dict.\n        :param buffered: Convert the iterator returned by the app into\n            a list. If the iterator has a ``close()`` method, it is\n            called automatically.\n        :param follow_redirects: Make additional requests to follow HTTP\n            redirects until a non-redirect status is returned.\n            :attr:`TestResponse.history` lists the intermediate\n            responses.\n    \n        .. versionchanged:: 2.1\n            Removed the ``as_tuple`` parameter.\n    \n        .. versionchanged:: 2.0\n            The request input stream is closed when calling\n            ``response.close()``. Input streams for redirects are\n            automatically closed.\n    \n        .. versionchanged:: 0.5\n            If a dict is provided as file in the dict for the ``data``\n            parameter the content type has to be called ``content_type``\n            instead of ``mimetype``. This change was made for\n            consistency with :class:`werkzeug.FileWrapper`.\n    \n        .. versionchanged:: 0.5\n            Added the ``follow_redirects`` parameter.\n        \"\"\"\n        request: Request | None = None\n    \n        if not kwargs and len(args) == 1:\n            arg = args[0]\n    \n            if isinstance(arg, EnvironBuilder):\n                request = arg.get_request()\n            elif isinstance(arg, dict):\n                request = EnvironBuilder.from_environ(arg).get_request()\n            elif isinstance(arg, Request):\n                request = arg\n    \n        if request is None:\n>           builder = EnvironBuilder(*args, **kwargs)\nE           TypeError: __init__() got an unexpected keyword argument 'as_tuple'\n\n/opt/miniconda3/envs/testbed/lib/python3.9/site-packages/werkzeug/test.py:1190: TypeError\n____________________ test_session_using_samesite_attribute _____________________\n\napp = <Flask 'flask_test'>, client = <FlaskClient <Flask 'flask_test'>>\n\n    def test_session_using_samesite_attribute(app, client):\n        @app.route(\"/\")\n        def index():\n            flask.session[\"testing\"] = 42\n            return \"Hello World\"\n    \n        app.config.update(SESSION_COOKIE_SAMESITE=\"invalid\")\n    \n        with pytest.raises(ValueError):\n>           client.get(\"/\")\n\ntests/test_basic.py:365: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n/opt/miniconda3/envs/testbed/lib/python3.9/site-packages/werkzeug/test.py:1243: in get\n    return self.open(*args, **kw)\nsrc/flask/testing.py:209: in open\n    builder = EnvironBuilder(self.application, *args, **kwargs)\nsrc/flask/testing.py:70: in __init__\n    url = url_parse(path)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nurl = '/', scheme = None, allow_fragments = True\n\n    def url_parse(\n        url: str, scheme: str | None = None, allow_fragments: bool = True\n    ) -> BaseURL:\n        \"\"\"Parses a URL from a string into a :class:`URL` tuple.  If the URL\n        is lacking a scheme it can be provided as second argument. Otherwise,\n        it is ignored.  Optionally fragments can be stripped from the URL\n        by setting `allow_fragments` to `False`.\n    \n        The inverse of this function is :func:`url_unparse`.\n    \n        :param url: the URL to parse.\n        :param scheme: the default schema to use if the URL is schemaless.\n        :param allow_fragments: if set to `False` a fragment will be removed\n                                from the URL.\n    \n        .. deprecated:: 2.3\n            Will be removed in Werkzeug 3.0. Use ``urllib.parse.urlsplit`` instead.\n        \"\"\"\n>       warnings.warn(\n            \"'werkzeug.urls.url_parse' is deprecated and will be removed in Werkzeug 3.0.\"\n            \" Use 'urllib.parse.urlsplit' instead.\",\n            DeprecationWarning,\n            stacklevel=2,\n        )\nE       DeprecationWarning: 'werkzeug.urls.url_parse' is deprecated and will be removed in Werkzeug 3.0. Use 'urllib.parse.urlsplit' instead.\n\n/opt/miniconda3/envs/testbed/lib/python3.9/site-packages/werkzeug/urls.py:505: DeprecationWarning\n________________________ test_session_localhost_warning ________________________\n\nrecwarn = WarningsRecorder(record=True), app = <Flask 'flask_test'>\nclient = <FlaskClient <Flask 'flask_test'>>\n\n    def test_session_localhost_warning(recwarn, app, client):\n        app.config.update(SERVER_NAME=\"localhost:5000\")\n    \n        @app.route(\"/\")\n        def index():\n            flask.session[\"testing\"] = 42\n            return \"testing\"\n    \n>       rv = client.get(\"/\", \"http://localhost:5000/\")\n\ntests/test_basic.py:391: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n/opt/miniconda3/envs/testbed/lib/python3.9/site-packages/werkzeug/test.py:1243: in get\n    return self.open(*args, **kw)\nsrc/flask/testing.py:216: in open\n    return super().open(  # type: ignore\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <FlaskClient <Flask 'flask_test'>>, buffered = False\nfollow_redirects = False, args = (<Request 'http://localhost:5000/' [GET]>,)\nkwargs = {'as_tuple': False}, request = None\n\n    def open(\n        self,\n        *args: t.Any,\n        buffered: bool = False,\n        follow_redirects: bool = False,\n        **kwargs: t.Any,\n    ) -> TestResponse:\n        \"\"\"Generate an environ dict from the given arguments, make a\n        request to the application using it, and return the response.\n    \n        :param args: Passed to :class:`EnvironBuilder` to create the\n            environ for the request. If a single arg is passed, it can\n            be an existing :class:`EnvironBuilder` or an environ dict.\n        :param buffered: Convert the iterator returned by the app into\n            a list. If the iterator has a ``close()`` method, it is\n            called automatically.\n        :param follow_redirects: Make additional requests to follow HTTP\n            redirects until a non-redirect status is returned.\n            :attr:`TestResponse.history` lists the intermediate\n            responses.\n    \n        .. versionchanged:: 2.1\n            Removed the ``as_tuple`` parameter.\n    \n        .. versionchanged:: 2.0\n            The request input stream is closed when calling\n            ``response.close()``. Input streams for redirects are\n            automatically closed.\n    \n        .. versionchanged:: 0.5\n            If a dict is provided as file in the dict for the ``data``\n            parameter the content type has to be called ``content_type``\n            instead of ``mimetype``. This change was made for\n            consistency with :class:`werkzeug.FileWrapper`.\n    \n        .. versionchanged:: 0.5\n            Added the ``follow_redirects`` parameter.\n        \"\"\"\n        request: Request | None = None\n    \n        if not kwargs and len(args) == 1:\n            arg = args[0]\n    \n            if isinstance(arg, EnvironBuilder):\n                request = arg.get_request()\n            elif isinstance(arg, dict):\n                request = EnvironBuilder.from_environ(arg).get_request()\n            elif isinstance(arg, Request):\n                request = arg\n    \n        if request is None:\n>           builder = EnvironBuilder(*args, **kwargs)\nE           TypeError: __init__() got an unexpected keyword argument 'as_tuple'\n\n/opt/miniconda3/envs/testbed/lib/python3.9/site-packages/werkzeug/test.py:1190: TypeError\n___________________________ test_session_ip_warning ____________________________\n\nrecwarn = WarningsRecorder(record=True), app = <Flask 'flask_test'>\nclient = <FlaskClient <Flask 'flask_test'>>\n\n    def test_session_ip_warning(recwarn, app, client):\n        app.config.update(SERVER_NAME=\"127.0.0.1:5000\")\n    \n        @app.route(\"/\")\n        def index():\n            flask.session[\"testing\"] = 42\n            return \"testing\"\n    \n>       rv = client.get(\"/\", \"http://127.0.0.1:5000/\")\n\ntests/test_basic.py:405: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n/opt/miniconda3/envs/testbed/lib/python3.9/site-packages/werkzeug/test.py:1243: in get\n    return self.open(*args, **kw)\nsrc/flask/testing.py:216: in open\n    return super().open(  # type: ignore\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <FlaskClient <Flask 'flask_test'>>, buffered = False\nfollow_redirects = False, args = (<Request 'http://127.0.0.1:5000/' [GET]>,)\nkwargs = {'as_tuple': False}, request = None\n\n    def open(\n        self,\n        *args: t.Any,\n        buffered: bool = False,\n        follow_redirects: bool = False,\n        **kwargs: t.Any,\n    ) -> TestResponse:\n        \"\"\"Generate an environ dict from the given arguments, make a\n        request to the application using it, and return the response.\n    \n        :param args: Passed to :class:`EnvironBuilder` to create the\n            environ for the request. If a single arg is passed, it can\n            be an existing :class:`EnvironBuilder` or an environ dict.\n        :param buffered: Convert the iterator returned by the app into\n            a list. If the iterator has a ``close()`` method, it is\n            called automatically.\n        :param follow_redirects: Make additional requests to follow HTTP\n            redirects until a non-redirect status is returned.\n            :attr:`TestResponse.history` lists the intermediate\n            responses.\n    \n        .. versionchanged:: 2.1\n            Removed the ``as_tuple`` parameter.\n    \n        .. versionchanged:: 2.0\n            The request input stream is closed when calling\n            ``response.close()``. Input streams for redirects are\n            automatically closed.\n    \n        .. versionchanged:: 0.5\n            If a dict is provided as file in the dict for the ``data``\n            parameter the content type has to be called ``content_type``\n            instead of ``mimetype``. This change was made for\n            consistency with :class:`werkzeug.FileWrapper`.\n    \n        .. versionchanged:: 0.5\n            Added the ``follow_redirects`` parameter.\n        \"\"\"\n        request: Request | None = None\n    \n        if not kwargs and len(args) == 1:\n            arg = args[0]\n    \n            if isinstance(arg, EnvironBuilder):\n                request = arg.get_request()\n            elif isinstance(arg, dict):\n                request = EnvironBuilder.from_environ(arg).get_request()\n            elif isinstance(arg, Request):\n                request = arg\n    \n        if request is None:\n>           builder = EnvironBuilder(*args, **kwargs)\nE           TypeError: __init__() got an unexpected keyword argument 'as_tuple'\n\n/opt/miniconda3/envs/testbed/lib/python3.9/site-packages/werkzeug/test.py:1190: TypeError\n_____________________________ test_missing_session _____________________________\n\napp = <Flask 'flask_test'>\n\n    def test_missing_session(app):\n        app.secret_key = None\n    \n        def expect_exception(f, *args, **kwargs):\n            e = pytest.raises(RuntimeError, f, *args, **kwargs)\n            assert e.value.args and \"session is unavailable\" in e.value.args[0]\n    \n>       with app.test_request_context():\n\ntests/test_basic.py:418: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \nsrc/flask/app.py:2015: in test_request_context\n    builder = EnvironBuilder(self, *args, **kwargs)\nsrc/flask/testing.py:70: in __init__\n    url = url_parse(path)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nurl = '/', scheme = None, allow_fragments = True\n\n    def url_parse(\n        url: str, scheme: str | None = None, allow_fragments: bool = True\n    ) -> BaseURL:\n        \"\"\"Parses a URL from a string into a :class:`URL` tuple.  If the URL\n        is lacking a scheme it can be provided as second argument. Otherwise,\n        it is ignored.  Optionally fragments can be stripped from the URL\n        by setting `allow_fragments` to `False`.\n    \n        The inverse of this function is :func:`url_unparse`.\n    \n        :param url: the URL to parse.\n        :param scheme: the default schema to use if the URL is schemaless.\n        :param allow_fragments: if set to `False` a fragment will be removed\n                                from the URL.\n    \n        .. deprecated:: 2.3\n            Will be removed in Werkzeug 3.0. Use ``urllib.parse.urlsplit`` instead.\n        \"\"\"\n>       warnings.warn(\n            \"'werkzeug.urls.url_parse' is deprecated and will be removed in Werkzeug 3.0.\"\n            \" Use 'urllib.parse.urlsplit' instead.\",\n            DeprecationWarning,\n            stacklevel=2,\n        )\nE       DeprecationWarning: 'werkzeug.urls.url_parse' is deprecated and will be removed in Werkzeug 3.0. Use 'urllib.parse.urlsplit' instead.\n\n/opt/miniconda3/envs/testbed/lib/python3.9/site-packages/werkzeug/urls.py:505: DeprecationWarning\n___________________________ test_session_expiration ____________________________\n\napp = <Flask 'flask_test'>, client = <FlaskClient <Flask 'flask_test'>>\n\n    def test_session_expiration(app, client):\n        permanent = True\n    \n        @app.route(\"/\")\n        def index():\n            flask.session[\"test\"] = 42\n            flask.session.permanent = permanent\n            return \"\"\n    \n        @app.route(\"/test\")\n        def test():\n            return str(flask.session.permanent)\n    \n>       rv = client.get(\"/\")\n\ntests/test_basic.py:437: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n/opt/miniconda3/envs/testbed/lib/python3.9/site-packages/werkzeug/test.py:1243: in get\n    return self.open(*args, **kw)\nsrc/flask/testing.py:209: in open\n    builder = EnvironBuilder(self.application, *args, **kwargs)\nsrc/flask/testing.py:70: in __init__\n    url = url_parse(path)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nurl = '/', scheme = None, allow_fragments = True\n\n    def url_parse(\n        url: str, scheme: str | None = None, allow_fragments: bool = True\n    ) -> BaseURL:\n        \"\"\"Parses a URL from a string into a :class:`URL` tuple.  If the URL\n        is lacking a scheme it can be provided as second argument. Otherwise,\n        it is ignored.  Optionally fragments can be stripped from the URL\n        by setting `allow_fragments` to `False`.\n    \n        The inverse of this function is :func:`url_unparse`.\n    \n        :param url: the URL to parse.\n        :param scheme: the default schema to use if the URL is schemaless.\n        :param allow_fragments: if set to `False` a fragment will be removed\n                                from the URL.\n    \n        .. deprecated:: 2.3\n            Will be removed in Werkzeug 3.0. Use ``urllib.parse.urlsplit`` instead.\n        \"\"\"\n>       warnings.warn(\n            \"'werkzeug.urls.url_parse' is deprecated and will be removed in Werkzeug 3.0.\"\n            \" Use 'urllib.parse.urlsplit' instead.\",\n            DeprecationWarning,\n            stacklevel=2,\n        )\nE       DeprecationWarning: 'werkzeug.urls.url_parse' is deprecated and will be removed in Werkzeug 3.0. Use 'urllib.parse.urlsplit' instead.\n\n/opt/miniconda3/envs/testbed/lib/python3.9/site-packages/werkzeug/urls.py:505: DeprecationWarning\n___________________________ test_session_stored_last ___________________________\n\napp = <Flask 'flask_test'>, client = <FlaskClient <Flask 'flask_test'>>\n\n    def test_session_stored_last(app, client):\n        @app.after_request\n        def modify_session(response):\n            flask.session[\"foo\"] = 42\n            return response\n    \n        @app.route(\"/\")\n        def dump_session_contents():\n            return repr(flask.session.get(\"foo\"))\n    \n>       assert client.get(\"/\").data == b\"None\"\n\ntests/test_basic.py:466: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n/opt/miniconda3/envs/testbed/lib/python3.9/site-packages/werkzeug/test.py:1243: in get\n    return self.open(*args, **kw)\nsrc/flask/testing.py:209: in open\n    builder = EnvironBuilder(self.application, *args, **kwargs)\nsrc/flask/testing.py:70: in __init__\n    url = url_parse(path)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nurl = '/', scheme = None, allow_fragments = True\n\n    def url_parse(\n        url: str, scheme: str | None = None, allow_fragments: bool = True\n    ) -> BaseURL:\n        \"\"\"Parses a URL from a string into a :class:`URL` tuple.  If the URL\n        is lacking a scheme it can be provided as second argument. Otherwise,\n        it is ignored.  Optionally fragments can be stripped from the URL\n        by setting `allow_fragments` to `False`.\n    \n        The inverse of this function is :func:`url_unparse`.\n    \n        :param url: the URL to parse.\n        :param scheme: the default schema to use if the URL is schemaless.\n        :param allow_fragments: if set to `False` a fragment will be removed\n                                from the URL.\n    \n        .. deprecated:: 2.3\n            Will be removed in Werkzeug 3.0. Use ``urllib.parse.urlsplit`` instead.\n        \"\"\"\n>       warnings.warn(\n            \"'werkzeug.urls.url_parse' is deprecated and will be removed in Werkzeug 3.0.\"\n            \" Use 'urllib.parse.urlsplit' instead.\",\n            DeprecationWarning,\n            stacklevel=2,\n        )\nE       DeprecationWarning: 'werkzeug.urls.url_parse' is deprecated and will be removed in Werkzeug 3.0. Use 'urllib.parse.urlsplit' instead.\n\n/opt/miniconda3/envs/testbed/lib/python3.9/site-packages/werkzeug/urls.py:505: DeprecationWarning\n__________________________ test_session_special_types __________________________\n\napp = <Flask 'flask_test'>, client = <FlaskClient <Flask 'flask_test'>>\n\n    def test_session_special_types(app, client):\n        now = datetime.utcnow().replace(microsecond=0)\n        the_uuid = uuid.uuid4()\n    \n        @app.route(\"/\")\n        def dump_session_contents():\n            flask.session[\"t\"] = (1, 2, 3)\n            flask.session[\"b\"] = b\"\\xff\"\n            flask.session[\"m\"] = flask.Markup(\"<html>\")\n            flask.session[\"u\"] = the_uuid\n            flask.session[\"d\"] = now\n            flask.session[\"t_tag\"] = {\" t\": \"not-a-tuple\"}\n            flask.session[\"di_t_tag\"] = {\" t__\": \"not-a-tuple\"}\n            flask.session[\"di_tag\"] = {\" di\": \"not-a-dict\"}\n            return \"\", 204\n    \n        with client:\n>           client.get(\"/\")\n\ntests/test_basic.py:487: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n/opt/miniconda3/envs/testbed/lib/python3.9/site-packages/werkzeug/test.py:1243: in get\n    return self.open(*args, **kw)\nsrc/flask/testing.py:209: in open\n    builder = EnvironBuilder(self.application, *args, **kwargs)\nsrc/flask/testing.py:70: in __init__\n    url = url_parse(path)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nurl = '/', scheme = None, allow_fragments = True\n\n    def url_parse(\n        url: str, scheme: str | None = None, allow_fragments: bool = True\n    ) -> BaseURL:\n        \"\"\"Parses a URL from a string into a :class:`URL` tuple.  If the URL\n        is lacking a scheme it can be provided as second argument. Otherwise,\n        it is ignored.  Optionally fragments can be stripped from the URL\n        by setting `allow_fragments` to `False`.\n    \n        The inverse of this function is :func:`url_unparse`.\n    \n        :param url: the URL to parse.\n        :param scheme: the default schema to use if the URL is schemaless.\n        :param allow_fragments: if set to `False` a fragment will be removed\n                                from the URL.\n    \n        .. deprecated:: 2.3\n            Will be removed in Werkzeug 3.0. Use ``urllib.parse.urlsplit`` instead.\n        \"\"\"\n>       warnings.warn(\n            \"'werkzeug.urls.url_parse' is deprecated and will be removed in Werkzeug 3.0.\"\n            \" Use 'urllib.parse.urlsplit' instead.\",\n            DeprecationWarning,\n            stacklevel=2,\n        )\nE       DeprecationWarning: 'werkzeug.urls.url_parse' is deprecated and will be removed in Werkzeug 3.0. Use 'urllib.parse.urlsplit' instead.\n\n/opt/miniconda3/envs/testbed/lib/python3.9/site-packages/werkzeug/urls.py:505: DeprecationWarning\n_________________________ test_session_cookie_setting __________________________\n\napp = <Flask 'flask_test'>\n\n    def test_session_cookie_setting(app):\n        is_permanent = True\n    \n        @app.route(\"/bump\")\n        def bump():\n            rv = flask.session[\"foo\"] = flask.session.get(\"foo\", 0) + 1\n            flask.session.permanent = is_permanent\n            return str(rv)\n    \n        @app.route(\"/read\")\n        def read():\n            return str(flask.session.get(\"foo\", 0))\n    \n        def run_test(expect_header):\n            with app.test_client() as c:\n                assert c.get(\"/bump\").data == b\"1\"\n                assert c.get(\"/bump\").data == b\"2\"\n                assert c.get(\"/bump\").data == b\"3\"\n    \n                rv = c.get(\"/read\")\n                set_cookie = rv.headers.get(\"set-cookie\")\n                assert (set_cookie is not None) == expect_header\n                assert rv.data == b\"3\"\n    \n        is_permanent = True\n        app.config[\"SESSION_REFRESH_EACH_REQUEST\"] = True\n>       run_test(expect_header=True)\n\ntests/test_basic.py:527: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \ntests/test_basic.py:516: in run_test\n    assert c.get(\"/bump\").data == b\"1\"\n/opt/miniconda3/envs/testbed/lib/python3.9/site-packages/werkzeug/test.py:1243: in get\n    return self.open(*args, **kw)\nsrc/flask/testing.py:209: in open\n    builder = EnvironBuilder(self.application, *args, **kwargs)\nsrc/flask/testing.py:70: in __init__\n    url = url_parse(path)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nurl = '/bump', scheme = None, allow_fragments = True\n\n    def url_parse(\n        url: str, scheme: str | None = None, allow_fragments: bool = True\n    ) -> BaseURL:\n        \"\"\"Parses a URL from a string into a :class:`URL` tuple.  If the URL\n        is lacking a scheme it can be provided as second argument. Otherwise,\n        it is ignored.  Optionally fragments can be stripped from the URL\n        by setting `allow_fragments` to `False`.\n    \n        The inverse of this function is :func:`url_unparse`.\n    \n        :param url: the URL to parse.\n        :param scheme: the default schema to use if the URL is schemaless.\n        :param allow_fragments: if set to `False` a fragment will be removed\n                                from the URL.\n    \n        .. deprecated:: 2.3\n            Will be removed in Werkzeug 3.0. Use ``urllib.parse.urlsplit`` instead.\n        \"\"\"\n>       warnings.warn(\n            \"'werkzeug.urls.url_parse' is deprecated and will be removed in Werkzeug 3.0.\"\n            \" Use 'urllib.parse.urlsplit' instead.\",\n            DeprecationWarning,\n            stacklevel=2,\n        )\nE       DeprecationWarning: 'werkzeug.urls.url_parse' is deprecated and will be removed in Werkzeug 3.0. Use 'urllib.parse.urlsplit' instead.\n\n/opt/miniconda3/envs/testbed/lib/python3.9/site-packages/werkzeug/urls.py:505: DeprecationWarning\n___________________________ test_session_vary_cookie ___________________________\n\napp = <Flask 'flask_test'>, client = <FlaskClient <Flask 'flask_test'>>\n\n    def test_session_vary_cookie(app, client):\n        @app.route(\"/set\")\n        def set_session():\n            flask.session[\"test\"] = \"test\"\n            return \"\"\n    \n        @app.route(\"/get\")\n        def get():\n            return flask.session.get(\"test\")\n    \n        @app.route(\"/getitem\")\n        def getitem():\n            return flask.session[\"test\"]\n    \n        @app.route(\"/setdefault\")\n        def setdefault():\n            return flask.session.setdefault(\"test\", \"default\")\n    \n        @app.route(\"/vary-cookie-header-set\")\n        def vary_cookie_header_set():\n            response = flask.Response()\n            response.vary.add(\"Cookie\")\n            flask.session[\"test\"] = \"test\"\n            return response\n    \n        @app.route(\"/vary-header-set\")\n        def vary_header_set():\n            response = flask.Response()\n            response.vary.update((\"Accept-Encoding\", \"Accept-Language\"))\n            flask.session[\"test\"] = \"test\"\n            return response\n    \n        @app.route(\"/no-vary-header\")\n        def no_vary_header():\n            return \"\"\n    \n        def expect(path, header_value=\"Cookie\"):\n            rv = client.get(path)\n    \n            if header_value:\n                # The 'Vary' key should exist in the headers only once.\n                assert len(rv.headers.get_all(\"Vary\")) == 1\n                assert rv.headers[\"Vary\"] == header_value\n            else:\n                assert \"Vary\" not in rv.headers\n    \n>       expect(\"/set\")\n\ntests/test_basic.py:588: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \ntests/test_basic.py:579: in expect\n    rv = client.get(path)\n/opt/miniconda3/envs/testbed/lib/python3.9/site-packages/werkzeug/test.py:1243: in get\n    return self.open(*args, **kw)\nsrc/flask/testing.py:209: in open\n    builder = EnvironBuilder(self.application, *args, **kwargs)\nsrc/flask/testing.py:70: in __init__\n    url = url_parse(path)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nurl = '/set', scheme = None, allow_fragments = True\n\n    def url_parse(\n        url: str, scheme: str | None = None, allow_fragments: bool = True\n    ) -> BaseURL:\n        \"\"\"Parses a URL from a string into a :class:`URL` tuple.  If the URL\n        is lacking a scheme it can be provided as second argument. Otherwise,\n        it is ignored.  Optionally fragments can be stripped from the URL\n        by setting `allow_fragments` to `False`.\n    \n        The inverse of this function is :func:`url_unparse`.\n    \n        :param url: the URL to parse.\n        :param scheme: the default schema to use if the URL is schemaless.\n        :param allow_fragments: if set to `False` a fragment will be removed\n                                from the URL.\n    \n        .. deprecated:: 2.3\n            Will be removed in Werkzeug 3.0. Use ``urllib.parse.urlsplit`` instead.\n        \"\"\"\n>       warnings.warn(\n            \"'werkzeug.urls.url_parse' is deprecated and will be removed in Werkzeug 3.0.\"\n            \" Use 'urllib.parse.urlsplit' instead.\",\n            DeprecationWarning,\n            stacklevel=2,\n        )\nE       DeprecationWarning: 'werkzeug.urls.url_parse' is deprecated and will be removed in Werkzeug 3.0. Use 'urllib.parse.urlsplit' instead.\n\n/opt/miniconda3/envs/testbed/lib/python3.9/site-packages/werkzeug/urls.py:505: DeprecationWarning\n____________________________ test_extended_flashing ____________________________\n\napp = <Flask 'flask_test'>\n\n    def test_extended_flashing(app):\n        # Be sure app.testing=True below, else tests can fail silently.\n        #\n        # Specifically, if app.testing is not set to True, the AssertionErrors\n        # in the view functions will cause a 500 response to the test client\n        # instead of propagating exceptions.\n    \n        @app.route(\"/\")\n        def index():\n            flask.flash(\"Hello World\")\n            flask.flash(\"Hello World\", \"error\")\n            flask.flash(flask.Markup(\"<em>Testing</em>\"), \"warning\")\n            return \"\"\n    \n        @app.route(\"/test/\")\n        def test():\n            messages = flask.get_flashed_messages()\n            assert list(messages) == [\n                \"Hello World\",\n                \"Hello World\",\n                flask.Markup(\"<em>Testing</em>\"),\n            ]\n            return \"\"\n    \n        @app.route(\"/test_with_categories/\")\n        def test_with_categories():\n            messages = flask.get_flashed_messages(with_categories=True)\n            assert len(messages) == 3\n            assert list(messages) == [\n                (\"message\", \"Hello World\"),\n                (\"error\", \"Hello World\"),\n                (\"warning\", flask.Markup(\"<em>Testing</em>\")),\n            ]\n            return \"\"\n    \n        @app.route(\"/test_filter/\")\n        def test_filter():\n            messages = flask.get_flashed_messages(\n                category_filter=[\"message\"], with_categories=True\n            )\n            assert list(messages) == [(\"message\", \"Hello World\")]\n            return \"\"\n    \n        @app.route(\"/test_filters/\")\n        def test_filters():\n            messages = flask.get_flashed_messages(\n                category_filter=[\"message\", \"warning\"], with_categories=True\n            )\n            assert list(messages) == [\n                (\"message\", \"Hello World\"),\n                (\"warning\", flask.Markup(\"<em>Testing</em>\")),\n            ]\n            return \"\"\n    \n        @app.route(\"/test_filters_without_returning_categories/\")\n        def test_filters2():\n            messages = flask.get_flashed_messages(category_filter=[\"message\", \"warning\"])\n            assert len(messages) == 2\n            assert messages[0] == \"Hello World\"\n            assert messages[1] == flask.Markup(\"<em>Testing</em>\")\n            return \"\"\n    \n        # Create new test client on each test to clean flashed messages.\n    \n        client = app.test_client()\n>       client.get(\"/\")\n\ntests/test_basic.py:671: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n/opt/miniconda3/envs/testbed/lib/python3.9/site-packages/werkzeug/test.py:1243: in get\n    return self.open(*args, **kw)\nsrc/flask/testing.py:209: in open\n    builder = EnvironBuilder(self.application, *args, **kwargs)\nsrc/flask/testing.py:70: in __init__\n    url = url_parse(path)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nurl = '/', scheme = None, allow_fragments = True\n\n    def url_parse(\n        url: str, scheme: str | None = None, allow_fragments: bool = True\n    ) -> BaseURL:\n        \"\"\"Parses a URL from a string into a :class:`URL` tuple.  If the URL\n        is lacking a scheme it can be provided as second argument. Otherwise,\n        it is ignored.  Optionally fragments can be stripped from the URL\n        by setting `allow_fragments` to `False`.\n    \n        The inverse of this function is :func:`url_unparse`.\n    \n        :param url: the URL to parse.\n        :param scheme: the default schema to use if the URL is schemaless.\n        :param allow_fragments: if set to `False` a fragment will be removed\n                                from the URL.\n    \n        .. deprecated:: 2.3\n            Will be removed in Werkzeug 3.0. Use ``urllib.parse.urlsplit`` instead.\n        \"\"\"\n>       warnings.warn(\n            \"'werkzeug.urls.url_parse' is deprecated and will be removed in Werkzeug 3.0.\"\n            \" Use 'urllib.parse.urlsplit' instead.\",\n            DeprecationWarning,\n            stacklevel=2,\n        )\nE       DeprecationWarning: 'werkzeug.urls.url_parse' is deprecated and will be removed in Werkzeug 3.0. Use 'urllib.parse.urlsplit' instead.\n\n/opt/miniconda3/envs/testbed/lib/python3.9/site-packages/werkzeug/urls.py:505: DeprecationWarning\n___________________________ test_request_processing ____________________________\n\napp = <Flask 'flask_test'>, client = <FlaskClient <Flask 'flask_test'>>\n\n    def test_request_processing(app, client):\n        evts = []\n    \n        @app.before_request\n        def before_request():\n            evts.append(\"before\")\n    \n        @app.after_request\n        def after_request(response):\n            response.data += b\"|after\"\n            evts.append(\"after\")\n            return response\n    \n        @app.route(\"/\")\n        def index():\n            assert \"before\" in evts\n            assert \"after\" not in evts\n            return \"request\"\n    \n        assert \"after\" not in evts\n>       rv = client.get(\"/\").data\n\ntests/test_basic.py:707: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n/opt/miniconda3/envs/testbed/lib/python3.9/site-packages/werkzeug/test.py:1243: in get\n    return self.open(*args, **kw)\nsrc/flask/testing.py:209: in open\n    builder = EnvironBuilder(self.application, *args, **kwargs)\nsrc/flask/testing.py:70: in __init__\n    url = url_parse(path)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nurl = '/', scheme = None, allow_fragments = True\n\n    def url_parse(\n        url: str, scheme: str | None = None, allow_fragments: bool = True\n    ) -> BaseURL:\n        \"\"\"Parses a URL from a string into a :class:`URL` tuple.  If the URL\n        is lacking a scheme it can be provided as second argument. Otherwise,\n        it is ignored.  Optionally fragments can be stripped from the URL\n        by setting `allow_fragments` to `False`.\n    \n        The inverse of this function is :func:`url_unparse`.\n    \n        :param url: the URL to parse.\n        :param scheme: the default schema to use if the URL is schemaless.\n        :param allow_fragments: if set to `False` a fragment will be removed\n                                from the URL.\n    \n        .. deprecated:: 2.3\n            Will be removed in Werkzeug 3.0. Use ``urllib.parse.urlsplit`` instead.\n        \"\"\"\n>       warnings.warn(\n            \"'werkzeug.urls.url_parse' is deprecated and will be removed in Werkzeug 3.0.\"\n            \" Use 'urllib.parse.urlsplit' instead.\",\n            DeprecationWarning,\n            stacklevel=2,\n        )\nE       DeprecationWarning: 'werkzeug.urls.url_parse' is deprecated and will be removed in Werkzeug 3.0. Use 'urllib.parse.urlsplit' instead.\n\n/opt/miniconda3/envs/testbed/lib/python3.9/site-packages/werkzeug/urls.py:505: DeprecationWarning\n___________________ test_request_preprocessing_early_return ____________________\n\napp = <Flask 'flask_test'>, client = <FlaskClient <Flask 'flask_test'>>\n\n    def test_request_preprocessing_early_return(app, client):\n        evts = []\n    \n        @app.before_request\n        def before_request1():\n            evts.append(1)\n    \n        @app.before_request\n        def before_request2():\n            evts.append(2)\n            return \"hello\"\n    \n        @app.before_request\n        def before_request3():\n            evts.append(3)\n            return \"bye\"\n    \n        @app.route(\"/\")\n        def index():\n            evts.append(\"index\")\n            return \"damnit\"\n    \n>       rv = client.get(\"/\").data.strip()\n\ntests/test_basic.py:734: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n/opt/miniconda3/envs/testbed/lib/python3.9/site-packages/werkzeug/test.py:1243: in get\n    return self.open(*args, **kw)\nsrc/flask/testing.py:209: in open\n    builder = EnvironBuilder(self.application, *args, **kwargs)\nsrc/flask/testing.py:70: in __init__\n    url = url_parse(path)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nurl = '/', scheme = None, allow_fragments = True\n\n    def url_parse(\n        url: str, scheme: str | None = None, allow_fragments: bool = True\n    ) -> BaseURL:\n        \"\"\"Parses a URL from a string into a :class:`URL` tuple.  If the URL\n        is lacking a scheme it can be provided as second argument. Otherwise,\n        it is ignored.  Optionally fragments can be stripped from the URL\n        by setting `allow_fragments` to `False`.\n    \n        The inverse of this function is :func:`url_unparse`.\n    \n        :param url: the URL to parse.\n        :param scheme: the default schema to use if the URL is schemaless.\n        :param allow_fragments: if set to `False` a fragment will be removed\n                                from the URL.\n    \n        .. deprecated:: 2.3\n            Will be removed in Werkzeug 3.0. Use ``urllib.parse.urlsplit`` instead.\n        \"\"\"\n>       warnings.warn(\n            \"'werkzeug.urls.url_parse' is deprecated and will be removed in Werkzeug 3.0.\"\n            \" Use 'urllib.parse.urlsplit' instead.\",\n            DeprecationWarning,\n            stacklevel=2,\n        )\nE       DeprecationWarning: 'werkzeug.urls.url_parse' is deprecated and will be removed in Werkzeug 3.0. Use 'urllib.parse.urlsplit' instead.\n\n/opt/miniconda3/envs/testbed/lib/python3.9/site-packages/werkzeug/urls.py:505: DeprecationWarning\n________________________ test_after_request_processing _________________________\n\napp = <Flask 'flask_test'>, client = <FlaskClient <Flask 'flask_test'>>\n\n    def test_after_request_processing(app, client):\n        @app.route(\"/\")\n        def index():\n            @flask.after_this_request\n            def foo(response):\n                response.headers[\"X-Foo\"] = \"a header\"\n                return response\n    \n            return \"Test\"\n    \n>       resp = client.get(\"/\")\n\ntests/test_basic.py:749: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n/opt/miniconda3/envs/testbed/lib/python3.9/site-packages/werkzeug/test.py:1243: in get\n    return self.open(*args, **kw)\nsrc/flask/testing.py:209: in open\n    builder = EnvironBuilder(self.application, *args, **kwargs)\nsrc/flask/testing.py:70: in __init__\n    url = url_parse(path)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nurl = '/', scheme = None, allow_fragments = True\n\n    def url_parse(\n        url: str, scheme: str | None = None, allow_fragments: bool = True\n    ) -> BaseURL:\n        \"\"\"Parses a URL from a string into a :class:`URL` tuple.  If the URL\n        is lacking a scheme it can be provided as second argument. Otherwise,\n        it is ignored.  Optionally fragments can be stripped from the URL\n        by setting `allow_fragments` to `False`.\n    \n        The inverse of this function is :func:`url_unparse`.\n    \n        :param url: the URL to parse.\n        :param scheme: the default schema to use if the URL is schemaless.\n        :param allow_fragments: if set to `False` a fragment will be removed\n                                from the URL.\n    \n        .. deprecated:: 2.3\n            Will be removed in Werkzeug 3.0. Use ``urllib.parse.urlsplit`` instead.\n        \"\"\"\n>       warnings.warn(\n            \"'werkzeug.urls.url_parse' is deprecated and will be removed in Werkzeug 3.0.\"\n            \" Use 'urllib.parse.urlsplit' instead.\",\n            DeprecationWarning,\n            stacklevel=2,\n        )\nE       DeprecationWarning: 'werkzeug.urls.url_parse' is deprecated and will be removed in Werkzeug 3.0. Use 'urllib.parse.urlsplit' instead.\n\n/opt/miniconda3/envs/testbed/lib/python3.9/site-packages/werkzeug/urls.py:505: DeprecationWarning\n________________________ test_teardown_request_handler _________________________\n\napp = <Flask 'flask_test'>, client = <FlaskClient <Flask 'flask_test'>>\n\n    def test_teardown_request_handler(app, client):\n        called = []\n    \n        @app.teardown_request\n        def teardown_request(exc):\n            called.append(True)\n            return \"Ignored\"\n    \n        @app.route(\"/\")\n        def root():\n            return \"Response\"\n    \n>       rv = client.get(\"/\")\n\ntests/test_basic.py:766: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n/opt/miniconda3/envs/testbed/lib/python3.9/site-packages/werkzeug/test.py:1243: in get\n    return self.open(*args, **kw)\nsrc/flask/testing.py:209: in open\n    builder = EnvironBuilder(self.application, *args, **kwargs)\nsrc/flask/testing.py:70: in __init__\n    url = url_parse(path)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nurl = '/', scheme = None, allow_fragments = True\n\n    def url_parse(\n        url: str, scheme: str | None = None, allow_fragments: bool = True\n    ) -> BaseURL:\n        \"\"\"Parses a URL from a string into a :class:`URL` tuple.  If the URL\n        is lacking a scheme it can be provided as second argument. Otherwise,\n        it is ignored.  Optionally fragments can be stripped from the URL\n        by setting `allow_fragments` to `False`.\n    \n        The inverse of this function is :func:`url_unparse`.\n    \n        :param url: the URL to parse.\n        :param scheme: the default schema to use if the URL is schemaless.\n        :param allow_fragments: if set to `False` a fragment will be removed\n                                from the URL.\n    \n        .. deprecated:: 2.3\n            Will be removed in Werkzeug 3.0. Use ``urllib.parse.urlsplit`` instead.\n        \"\"\"\n>       warnings.warn(\n            \"'werkzeug.urls.url_parse' is deprecated and will be removed in Werkzeug 3.0.\"\n            \" Use 'urllib.parse.urlsplit' instead.\",\n            DeprecationWarning,\n            stacklevel=2,\n        )\nE       DeprecationWarning: 'werkzeug.urls.url_parse' is deprecated and will be removed in Werkzeug 3.0. Use 'urllib.parse.urlsplit' instead.\n\n/opt/miniconda3/envs/testbed/lib/python3.9/site-packages/werkzeug/urls.py:505: DeprecationWarning\n___________________ test_teardown_request_handler_debug_mode ___________________\n\napp = <Flask 'flask_test'>, client = <FlaskClient <Flask 'flask_test'>>\n\n    def test_teardown_request_handler_debug_mode(app, client):\n        called = []\n    \n        @app.teardown_request\n        def teardown_request(exc):\n            called.append(True)\n            return \"Ignored\"\n    \n        @app.route(\"/\")\n        def root():\n            return \"Response\"\n    \n>       rv = client.get(\"/\")\n\ntests/test_basic.py:784: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n/opt/miniconda3/envs/testbed/lib/python3.9/site-packages/werkzeug/test.py:1243: in get\n    return self.open(*args, **kw)\nsrc/flask/testing.py:209: in open\n    builder = EnvironBuilder(self.application, *args, **kwargs)\nsrc/flask/testing.py:70: in __init__\n    url = url_parse(path)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nurl = '/', scheme = None, allow_fragments = True\n\n    def url_parse(\n        url: str, scheme: str | None = None, allow_fragments: bool = True\n    ) -> BaseURL:\n        \"\"\"Parses a URL from a string into a :class:`URL` tuple.  If the URL\n        is lacking a scheme it can be provided as second argument. Otherwise,\n        it is ignored.  Optionally fragments can be stripped from the URL\n        by setting `allow_fragments` to `False`.\n    \n        The inverse of this function is :func:`url_unparse`.\n    \n        :param url: the URL to parse.\n        :param scheme: the default schema to use if the URL is schemaless.\n        :param allow_fragments: if set to `False` a fragment will be removed\n                                from the URL.\n    \n        .. deprecated:: 2.3\n            Will be removed in Werkzeug 3.0. Use ``urllib.parse.urlsplit`` instead.\n        \"\"\"\n>       warnings.warn(\n            \"'werkzeug.urls.url_parse' is deprecated and will be removed in Werkzeug 3.0.\"\n            \" Use 'urllib.parse.urlsplit' instead.\",\n            DeprecationWarning,\n            stacklevel=2,\n        )\nE       DeprecationWarning: 'werkzeug.urls.url_parse' is deprecated and will be removed in Werkzeug 3.0. Use 'urllib.parse.urlsplit' instead.\n\n/opt/miniconda3/envs/testbed/lib/python3.9/site-packages/werkzeug/urls.py:505: DeprecationWarning\n_____________________ test_teardown_request_handler_error ______________________\n\napp = <Flask 'flask_test'>, client = <FlaskClient <Flask 'flask_test'>>\n\n    def test_teardown_request_handler_error(app, client):\n        called = []\n        app.testing = False\n    \n        @app.teardown_request\n        def teardown_request1(exc):\n            assert type(exc) == ZeroDivisionError\n            called.append(True)\n            # This raises a new error and blows away sys.exc_info(), so we can\n            # test that all teardown_requests get passed the same original\n            # exception.\n            try:\n                raise TypeError()\n            except Exception:\n                pass\n    \n        @app.teardown_request\n        def teardown_request2(exc):\n            assert type(exc) == ZeroDivisionError\n            called.append(True)\n            # This raises a new error and blows away sys.exc_info(), so we can\n            # test that all teardown_requests get passed the same original\n            # exception.\n            try:\n                raise TypeError()\n            except Exception:\n                pass\n    \n        @app.route(\"/\")\n        def fails():\n            1 // 0\n    \n>       rv = client.get(\"/\")\n\ntests/test_basic.py:822: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n/opt/miniconda3/envs/testbed/lib/python3.9/site-packages/werkzeug/test.py:1243: in get\n    return self.open(*args, **kw)\nsrc/flask/testing.py:209: in open\n    builder = EnvironBuilder(self.application, *args, **kwargs)\nsrc/flask/testing.py:70: in __init__\n    url = url_parse(path)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nurl = '/', scheme = None, allow_fragments = True\n\n    def url_parse(\n        url: str, scheme: str | None = None, allow_fragments: bool = True\n    ) -> BaseURL:\n        \"\"\"Parses a URL from a string into a :class:`URL` tuple.  If the URL\n        is lacking a scheme it can be provided as second argument. Otherwise,\n        it is ignored.  Optionally fragments can be stripped from the URL\n        by setting `allow_fragments` to `False`.\n    \n        The inverse of this function is :func:`url_unparse`.\n    \n        :param url: the URL to parse.\n        :param scheme: the default schema to use if the URL is schemaless.\n        :param allow_fragments: if set to `False` a fragment will be removed\n                                from the URL.\n    \n        .. deprecated:: 2.3\n            Will be removed in Werkzeug 3.0. Use ``urllib.parse.urlsplit`` instead.\n        \"\"\"\n>       warnings.warn(\n            \"'werkzeug.urls.url_parse' is deprecated and will be removed in Werkzeug 3.0.\"\n            \" Use 'urllib.parse.urlsplit' instead.\",\n            DeprecationWarning,\n            stacklevel=2,\n        )\nE       DeprecationWarning: 'werkzeug.urls.url_parse' is deprecated and will be removed in Werkzeug 3.0. Use 'urllib.parse.urlsplit' instead.\n\n/opt/miniconda3/envs/testbed/lib/python3.9/site-packages/werkzeug/urls.py:505: DeprecationWarning\n_______________________ test_before_after_request_order ________________________\n\napp = <Flask 'flask_test'>, client = <FlaskClient <Flask 'flask_test'>>\n\n    def test_before_after_request_order(app, client):\n        called = []\n    \n        @app.before_request\n        def before1():\n            called.append(1)\n    \n        @app.before_request\n        def before2():\n            called.append(2)\n    \n        @app.after_request\n        def after1(response):\n            called.append(4)\n            return response\n    \n        @app.after_request\n        def after2(response):\n            called.append(3)\n            return response\n    \n        @app.teardown_request\n        def finish1(exc):\n            called.append(6)\n    \n        @app.teardown_request\n        def finish2(exc):\n            called.append(5)\n    \n        @app.route(\"/\")\n        def index():\n            return \"42\"\n    \n>       rv = client.get(\"/\")\n\ntests/test_basic.py:861: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n/opt/miniconda3/envs/testbed/lib/python3.9/site-packages/werkzeug/test.py:1243: in get\n    return self.open(*args, **kw)\nsrc/flask/testing.py:209: in open\n    builder = EnvironBuilder(self.application, *args, **kwargs)\nsrc/flask/testing.py:70: in __init__\n    url = url_parse(path)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nurl = '/', scheme = None, allow_fragments = True\n\n    def url_parse(\n        url: str, scheme: str | None = None, allow_fragments: bool = True\n    ) -> BaseURL:\n        \"\"\"Parses a URL from a string into a :class:`URL` tuple.  If the URL\n        is lacking a scheme it can be provided as second argument. Otherwise,\n        it is ignored.  Optionally fragments can be stripped from the URL\n        by setting `allow_fragments` to `False`.\n    \n        The inverse of this function is :func:`url_unparse`.\n    \n        :param url: the URL to parse.\n        :param scheme: the default schema to use if the URL is schemaless.\n        :param allow_fragments: if set to `False` a fragment will be removed\n                                from the URL.\n    \n        .. deprecated:: 2.3\n            Will be removed in Werkzeug 3.0. Use ``urllib.parse.urlsplit`` instead.\n        \"\"\"\n>       warnings.warn(\n            \"'werkzeug.urls.url_parse' is deprecated and will be removed in Werkzeug 3.0.\"\n            \" Use 'urllib.parse.urlsplit' instead.\",\n            DeprecationWarning,\n            stacklevel=2,\n        )\nE       DeprecationWarning: 'werkzeug.urls.url_parse' is deprecated and will be removed in Werkzeug 3.0. Use 'urllib.parse.urlsplit' instead.\n\n/opt/miniconda3/envs/testbed/lib/python3.9/site-packages/werkzeug/urls.py:505: DeprecationWarning\n_____________________________ test_error_handling ______________________________\n\napp = <Flask 'flask_test'>, client = <FlaskClient <Flask 'flask_test'>>\n\n    def test_error_handling(app, client):\n        app.testing = False\n    \n        @app.errorhandler(404)\n        def not_found(e):\n            return \"not found\", 404\n    \n        @app.errorhandler(500)\n        def internal_server_error(e):\n            return \"internal server error\", 500\n    \n        @app.errorhandler(Forbidden)\n        def forbidden(e):\n            return \"forbidden\", 403\n    \n        @app.route(\"/\")\n        def index():\n            flask.abort(404)\n    \n        @app.route(\"/error\")\n        def error():\n            1 // 0\n    \n        @app.route(\"/forbidden\")\n        def error2():\n            flask.abort(403)\n    \n>       rv = client.get(\"/\")\n\ntests/test_basic.py:893: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n/opt/miniconda3/envs/testbed/lib/python3.9/site-packages/werkzeug/test.py:1243: in get\n    return self.open(*args, **kw)\nsrc/flask/testing.py:209: in open\n    builder = EnvironBuilder(self.application, *args, **kwargs)\nsrc/flask/testing.py:70: in __init__\n    url = url_parse(path)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nurl = '/', scheme = None, allow_fragments = True\n\n    def url_parse(\n        url: str, scheme: str | None = None, allow_fragments: bool = True\n    ) -> BaseURL:\n        \"\"\"Parses a URL from a string into a :class:`URL` tuple.  If the URL\n        is lacking a scheme it can be provided as second argument. Otherwise,\n        it is ignored.  Optionally fragments can be stripped from the URL\n        by setting `allow_fragments` to `False`.\n    \n        The inverse of this function is :func:`url_unparse`.\n    \n        :param url: the URL to parse.\n        :param scheme: the default schema to use if the URL is schemaless.\n        :param allow_fragments: if set to `False` a fragment will be removed\n                                from the URL.\n    \n        .. deprecated:: 2.3\n            Will be removed in Werkzeug 3.0. Use ``urllib.parse.urlsplit`` instead.\n        \"\"\"\n>       warnings.warn(\n            \"'werkzeug.urls.url_parse' is deprecated and will be removed in Werkzeug 3.0.\"\n            \" Use 'urllib.parse.urlsplit' instead.\",\n            DeprecationWarning,\n            stacklevel=2,\n        )\nE       DeprecationWarning: 'werkzeug.urls.url_parse' is deprecated and will be removed in Werkzeug 3.0. Use 'urllib.parse.urlsplit' instead.\n\n/opt/miniconda3/envs/testbed/lib/python3.9/site-packages/werkzeug/urls.py:505: DeprecationWarning\n________________________ test_error_handling_processing ________________________\n\napp = <Flask 'flask_test'>, client = <FlaskClient <Flask 'flask_test'>>\n\n    def test_error_handling_processing(app, client):\n        app.testing = False\n    \n        @app.errorhandler(500)\n        def internal_server_error(e):\n            return \"internal server error\", 500\n    \n        @app.route(\"/\")\n        def broken_func():\n            1 // 0\n    \n        @app.after_request\n        def after_request(resp):\n            resp.mimetype = \"text/x-special\"\n            return resp\n    \n>       resp = client.get(\"/\")\n\ntests/test_basic.py:927: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n/opt/miniconda3/envs/testbed/lib/python3.9/site-packages/werkzeug/test.py:1243: in get\n    return self.open(*args, **kw)\nsrc/flask/testing.py:209: in open\n    builder = EnvironBuilder(self.application, *args, **kwargs)\nsrc/flask/testing.py:70: in __init__\n    url = url_parse(path)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nurl = '/', scheme = None, allow_fragments = True\n\n    def url_parse(\n        url: str, scheme: str | None = None, allow_fragments: bool = True\n    ) -> BaseURL:\n        \"\"\"Parses a URL from a string into a :class:`URL` tuple.  If the URL\n        is lacking a scheme it can be provided as second argument. Otherwise,\n        it is ignored.  Optionally fragments can be stripped from the URL\n        by setting `allow_fragments` to `False`.\n    \n        The inverse of this function is :func:`url_unparse`.\n    \n        :param url: the URL to parse.\n        :param scheme: the default schema to use if the URL is schemaless.\n        :param allow_fragments: if set to `False` a fragment will be removed\n                                from the URL.\n    \n        .. deprecated:: 2.3\n            Will be removed in Werkzeug 3.0. Use ``urllib.parse.urlsplit`` instead.\n        \"\"\"\n>       warnings.warn(\n            \"'werkzeug.urls.url_parse' is deprecated and will be removed in Werkzeug 3.0.\"\n            \" Use 'urllib.parse.urlsplit' instead.\",\n            DeprecationWarning,\n            stacklevel=2,\n        )\nE       DeprecationWarning: 'werkzeug.urls.url_parse' is deprecated and will be removed in Werkzeug 3.0. Use 'urllib.parse.urlsplit' instead.\n\n/opt/miniconda3/envs/testbed/lib/python3.9/site-packages/werkzeug/urls.py:505: DeprecationWarning\n______________________ test_baseexception_error_handling _______________________\n\napp = <Flask 'flask_test'>, client = <FlaskClient <Flask 'flask_test'>>\n\n    def test_baseexception_error_handling(app, client):\n        app.testing = False\n    \n        @app.route(\"/\")\n        def broken_func():\n            raise KeyboardInterrupt()\n    \n        with pytest.raises(KeyboardInterrupt):\n>           client.get(\"/\")\n\ntests/test_basic.py:940: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n/opt/miniconda3/envs/testbed/lib/python3.9/site-packages/werkzeug/test.py:1243: in get\n    return self.open(*args, **kw)\nsrc/flask/testing.py:209: in open\n    builder = EnvironBuilder(self.application, *args, **kwargs)\nsrc/flask/testing.py:70: in __init__\n    url = url_parse(path)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nurl = '/', scheme = None, allow_fragments = True\n\n    def url_parse(\n        url: str, scheme: str | None = None, allow_fragments: bool = True\n    ) -> BaseURL:\n        \"\"\"Parses a URL from a string into a :class:`URL` tuple.  If the URL\n        is lacking a scheme it can be provided as second argument. Otherwise,\n        it is ignored.  Optionally fragments can be stripped from the URL\n        by setting `allow_fragments` to `False`.\n    \n        The inverse of this function is :func:`url_unparse`.\n    \n        :param url: the URL to parse.\n        :param scheme: the default schema to use if the URL is schemaless.\n        :param allow_fragments: if set to `False` a fragment will be removed\n                                from the URL.\n    \n        .. deprecated:: 2.3\n            Will be removed in Werkzeug 3.0. Use ``urllib.parse.urlsplit`` instead.\n        \"\"\"\n>       warnings.warn(\n            \"'werkzeug.urls.url_parse' is deprecated and will be removed in Werkzeug 3.0.\"\n            \" Use 'urllib.parse.urlsplit' instead.\",\n            DeprecationWarning,\n            stacklevel=2,\n        )\nE       DeprecationWarning: 'werkzeug.urls.url_parse' is deprecated and will be removed in Werkzeug 3.0. Use 'urllib.parse.urlsplit' instead.\n\n/opt/miniconda3/envs/testbed/lib/python3.9/site-packages/werkzeug/urls.py:505: DeprecationWarning\n____________________ test_before_request_and_routing_errors ____________________\n\napp = <Flask 'flask_test'>, client = <FlaskClient <Flask 'flask_test'>>\n\n    def test_before_request_and_routing_errors(app, client):\n        @app.before_request\n        def attach_something():\n            flask.g.something = \"value\"\n    \n        @app.errorhandler(404)\n        def return_something(error):\n            return flask.g.something, 404\n    \n>       rv = client.get(\"/\")\n\ntests/test_basic.py:956: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n/opt/miniconda3/envs/testbed/lib/python3.9/site-packages/werkzeug/test.py:1243: in get\n    return self.open(*args, **kw)\nsrc/flask/testing.py:209: in open\n    builder = EnvironBuilder(self.application, *args, **kwargs)\nsrc/flask/testing.py:70: in __init__\n    url = url_parse(path)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nurl = '/', scheme = None, allow_fragments = True\n\n    def url_parse(\n        url: str, scheme: str | None = None, allow_fragments: bool = True\n    ) -> BaseURL:\n        \"\"\"Parses a URL from a string into a :class:`URL` tuple.  If the URL\n        is lacking a scheme it can be provided as second argument. Otherwise,\n        it is ignored.  Optionally fragments can be stripped from the URL\n        by setting `allow_fragments` to `False`.\n    \n        The inverse of this function is :func:`url_unparse`.\n    \n        :param url: the URL to parse.\n        :param scheme: the default schema to use if the URL is schemaless.\n        :param allow_fragments: if set to `False` a fragment will be removed\n                                from the URL.\n    \n        .. deprecated:: 2.3\n            Will be removed in Werkzeug 3.0. Use ``urllib.parse.urlsplit`` instead.\n        \"\"\"\n>       warnings.warn(\n            \"'werkzeug.urls.url_parse' is deprecated and will be removed in Werkzeug 3.0.\"\n            \" Use 'urllib.parse.urlsplit' instead.\",\n            DeprecationWarning,\n            stacklevel=2,\n        )\nE       DeprecationWarning: 'werkzeug.urls.url_parse' is deprecated and will be removed in Werkzeug 3.0. Use 'urllib.parse.urlsplit' instead.\n\n/opt/miniconda3/envs/testbed/lib/python3.9/site-packages/werkzeug/urls.py:505: DeprecationWarning\n___________________________ test_user_error_handling ___________________________\n\napp = <Flask 'flask_test'>, client = <FlaskClient <Flask 'flask_test'>>\n\n    def test_user_error_handling(app, client):\n        class MyException(Exception):\n            pass\n    \n        @app.errorhandler(MyException)\n        def handle_my_exception(e):\n            assert isinstance(e, MyException)\n            return \"42\"\n    \n        @app.route(\"/\")\n        def index():\n            raise MyException()\n    \n>       assert client.get(\"/\").data == b\"42\"\n\ntests/test_basic.py:974: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n/opt/miniconda3/envs/testbed/lib/python3.9/site-packages/werkzeug/test.py:1243: in get\n    return self.open(*args, **kw)\nsrc/flask/testing.py:209: in open\n    builder = EnvironBuilder(self.application, *args, **kwargs)\nsrc/flask/testing.py:70: in __init__\n    url = url_parse(path)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nurl = '/', scheme = None, allow_fragments = True\n\n    def url_parse(\n        url: str, scheme: str | None = None, allow_fragments: bool = True\n    ) -> BaseURL:\n        \"\"\"Parses a URL from a string into a :class:`URL` tuple.  If the URL\n        is lacking a scheme it can be provided as second argument. Otherwise,\n        it is ignored.  Optionally fragments can be stripped from the URL\n        by setting `allow_fragments` to `False`.\n    \n        The inverse of this function is :func:`url_unparse`.\n    \n        :param url: the URL to parse.\n        :param scheme: the default schema to use if the URL is schemaless.\n        :param allow_fragments: if set to `False` a fragment will be removed\n                                from the URL.\n    \n        .. deprecated:: 2.3\n            Will be removed in Werkzeug 3.0. Use ``urllib.parse.urlsplit`` instead.\n        \"\"\"\n>       warnings.warn(\n            \"'werkzeug.urls.url_parse' is deprecated and will be removed in Werkzeug 3.0.\"\n            \" Use 'urllib.parse.urlsplit' instead.\",\n            DeprecationWarning,\n            stacklevel=2,\n        )\nE       DeprecationWarning: 'werkzeug.urls.url_parse' is deprecated and will be removed in Werkzeug 3.0. Use 'urllib.parse.urlsplit' instead.\n\n/opt/miniconda3/envs/testbed/lib/python3.9/site-packages/werkzeug/urls.py:505: DeprecationWarning\n______________________ test_http_error_subclass_handling _______________________\n\napp = <Flask 'flask_test'>, client = <FlaskClient <Flask 'flask_test'>>\n\n    def test_http_error_subclass_handling(app, client):\n        class ForbiddenSubclass(Forbidden):\n            pass\n    \n        @app.errorhandler(ForbiddenSubclass)\n        def handle_forbidden_subclass(e):\n            assert isinstance(e, ForbiddenSubclass)\n            return \"banana\"\n    \n        @app.errorhandler(403)\n        def handle_403(e):\n            assert not isinstance(e, ForbiddenSubclass)\n            assert isinstance(e, Forbidden)\n            return \"apple\"\n    \n        @app.route(\"/1\")\n        def index1():\n            raise ForbiddenSubclass()\n    \n        @app.route(\"/2\")\n        def index2():\n            flask.abort(403)\n    \n        @app.route(\"/3\")\n        def index3():\n            raise Forbidden()\n    \n>       assert client.get(\"/1\").data == b\"banana\"\n\ntests/test_basic.py:1004: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n/opt/miniconda3/envs/testbed/lib/python3.9/site-packages/werkzeug/test.py:1243: in get\n    return self.open(*args, **kw)\nsrc/flask/testing.py:209: in open\n    builder = EnvironBuilder(self.application, *args, **kwargs)\nsrc/flask/testing.py:70: in __init__\n    url = url_parse(path)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nurl = '/1', scheme = None, allow_fragments = True\n\n    def url_parse(\n        url: str, scheme: str | None = None, allow_fragments: bool = True\n    ) -> BaseURL:\n        \"\"\"Parses a URL from a string into a :class:`URL` tuple.  If the URL\n        is lacking a scheme it can be provided as second argument. Otherwise,\n        it is ignored.  Optionally fragments can be stripped from the URL\n        by setting `allow_fragments` to `False`.\n    \n        The inverse of this function is :func:`url_unparse`.\n    \n        :param url: the URL to parse.\n        :param scheme: the default schema to use if the URL is schemaless.\n        :param allow_fragments: if set to `False` a fragment will be removed\n                                from the URL.\n    \n        .. deprecated:: 2.3\n            Will be removed in Werkzeug 3.0. Use ``urllib.parse.urlsplit`` instead.\n        \"\"\"\n>       warnings.warn(\n            \"'werkzeug.urls.url_parse' is deprecated and will be removed in Werkzeug 3.0.\"\n            \" Use 'urllib.parse.urlsplit' instead.\",\n            DeprecationWarning,\n            stacklevel=2,\n        )\nE       DeprecationWarning: 'werkzeug.urls.url_parse' is deprecated and will be removed in Werkzeug 3.0. Use 'urllib.parse.urlsplit' instead.\n\n/opt/miniconda3/envs/testbed/lib/python3.9/site-packages/werkzeug/urls.py:505: DeprecationWarning\n_________________________ test_errorhandler_precedence _________________________\n\napp = <Flask 'flask_test'>, client = <FlaskClient <Flask 'flask_test'>>\n\n    def test_errorhandler_precedence(app, client):\n        class E1(Exception):\n            pass\n    \n        class E2(Exception):\n            pass\n    \n        class E3(E1, E2):\n            pass\n    \n        @app.errorhandler(E2)\n        def handle_e2(e):\n            return \"E2\"\n    \n        @app.errorhandler(Exception)\n        def handle_exception(e):\n            return \"Exception\"\n    \n        @app.route(\"/E1\")\n        def raise_e1():\n            raise E1\n    \n        @app.route(\"/E3\")\n        def raise_e3():\n            raise E3\n    \n>       rv = client.get(\"/E1\")\n\ntests/test_basic.py:1035: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n/opt/miniconda3/envs/testbed/lib/python3.9/site-packages/werkzeug/test.py:1243: in get\n    return self.open(*args, **kw)\nsrc/flask/testing.py:209: in open\n    builder = EnvironBuilder(self.application, *args, **kwargs)\nsrc/flask/testing.py:70: in __init__\n    url = url_parse(path)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nurl = '/E1', scheme = None, allow_fragments = True\n\n    def url_parse(\n        url: str, scheme: str | None = None, allow_fragments: bool = True\n    ) -> BaseURL:\n        \"\"\"Parses a URL from a string into a :class:`URL` tuple.  If the URL\n        is lacking a scheme it can be provided as second argument. Otherwise,\n        it is ignored.  Optionally fragments can be stripped from the URL\n        by setting `allow_fragments` to `False`.\n    \n        The inverse of this function is :func:`url_unparse`.\n    \n        :param url: the URL to parse.\n        :param scheme: the default schema to use if the URL is schemaless.\n        :param allow_fragments: if set to `False` a fragment will be removed\n                                from the URL.\n    \n        .. deprecated:: 2.3\n            Will be removed in Werkzeug 3.0. Use ``urllib.parse.urlsplit`` instead.\n        \"\"\"\n>       warnings.warn(\n            \"'werkzeug.urls.url_parse' is deprecated and will be removed in Werkzeug 3.0.\"\n            \" Use 'urllib.parse.urlsplit' instead.\",\n            DeprecationWarning,\n            stacklevel=2,\n        )\nE       DeprecationWarning: 'werkzeug.urls.url_parse' is deprecated and will be removed in Werkzeug 3.0. Use 'urllib.parse.urlsplit' instead.\n\n/opt/miniconda3/envs/testbed/lib/python3.9/site-packages/werkzeug/urls.py:505: DeprecationWarning\n___________________ test_trapping_of_bad_request_key_errors ____________________\n\napp = <Flask 'flask_test'>, client = <FlaskClient <Flask 'flask_test'>>\n\n    def test_trapping_of_bad_request_key_errors(app, client):\n        @app.route(\"/key\")\n        def fail():\n            flask.request.form[\"missing_key\"]\n    \n        @app.route(\"/abort\")\n        def allow_abort():\n            flask.abort(400)\n    \n>       rv = client.get(\"/key\")\n\ntests/test_basic.py:1051: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n/opt/miniconda3/envs/testbed/lib/python3.9/site-packages/werkzeug/test.py:1243: in get\n    return self.open(*args, **kw)\nsrc/flask/testing.py:209: in open\n    builder = EnvironBuilder(self.application, *args, **kwargs)\nsrc/flask/testing.py:70: in __init__\n    url = url_parse(path)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nurl = '/key', scheme = None, allow_fragments = True\n\n    def url_parse(\n        url: str, scheme: str | None = None, allow_fragments: bool = True\n    ) -> BaseURL:\n        \"\"\"Parses a URL from a string into a :class:`URL` tuple.  If the URL\n        is lacking a scheme it can be provided as second argument. Otherwise,\n        it is ignored.  Optionally fragments can be stripped from the URL\n        by setting `allow_fragments` to `False`.\n    \n        The inverse of this function is :func:`url_unparse`.\n    \n        :param url: the URL to parse.\n        :param scheme: the default schema to use if the URL is schemaless.\n        :param allow_fragments: if set to `False` a fragment will be removed\n                                from the URL.\n    \n        .. deprecated:: 2.3\n            Will be removed in Werkzeug 3.0. Use ``urllib.parse.urlsplit`` instead.\n        \"\"\"\n>       warnings.warn(\n            \"'werkzeug.urls.url_parse' is deprecated and will be removed in Werkzeug 3.0.\"\n            \" Use 'urllib.parse.urlsplit' instead.\",\n            DeprecationWarning,\n            stacklevel=2,\n        )\nE       DeprecationWarning: 'werkzeug.urls.url_parse' is deprecated and will be removed in Werkzeug 3.0. Use 'urllib.parse.urlsplit' instead.\n\n/opt/miniconda3/envs/testbed/lib/python3.9/site-packages/werkzeug/urls.py:505: DeprecationWarning\n_____________________ test_trapping_of_all_http_exceptions _____________________\n\napp = <Flask 'flask_test'>, client = <FlaskClient <Flask 'flask_test'>>\n\n    def test_trapping_of_all_http_exceptions(app, client):\n        app.config[\"TRAP_HTTP_EXCEPTIONS\"] = True\n    \n        @app.route(\"/fail\")\n        def fail():\n            flask.abort(404)\n    \n        with pytest.raises(NotFound):\n>           client.get(\"/fail\")\n\ntests/test_basic.py:1081: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n/opt/miniconda3/envs/testbed/lib/python3.9/site-packages/werkzeug/test.py:1243: in get\n    return self.open(*args, **kw)\nsrc/flask/testing.py:209: in open\n    builder = EnvironBuilder(self.application, *args, **kwargs)\nsrc/flask/testing.py:70: in __init__\n    url = url_parse(path)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nurl = '/fail', scheme = None, allow_fragments = True\n\n    def url_parse(\n        url: str, scheme: str | None = None, allow_fragments: bool = True\n    ) -> BaseURL:\n        \"\"\"Parses a URL from a string into a :class:`URL` tuple.  If the URL\n        is lacking a scheme it can be provided as second argument. Otherwise,\n        it is ignored.  Optionally fragments can be stripped from the URL\n        by setting `allow_fragments` to `False`.\n    \n        The inverse of this function is :func:`url_unparse`.\n    \n        :param url: the URL to parse.\n        :param scheme: the default schema to use if the URL is schemaless.\n        :param allow_fragments: if set to `False` a fragment will be removed\n                                from the URL.\n    \n        .. deprecated:: 2.3\n            Will be removed in Werkzeug 3.0. Use ``urllib.parse.urlsplit`` instead.\n        \"\"\"\n>       warnings.warn(\n            \"'werkzeug.urls.url_parse' is deprecated and will be removed in Werkzeug 3.0.\"\n            \" Use 'urllib.parse.urlsplit' instead.\",\n            DeprecationWarning,\n            stacklevel=2,\n        )\nE       DeprecationWarning: 'werkzeug.urls.url_parse' is deprecated and will be removed in Werkzeug 3.0. Use 'urllib.parse.urlsplit' instead.\n\n/opt/miniconda3/envs/testbed/lib/python3.9/site-packages/werkzeug/urls.py:505: DeprecationWarning\n___________________ test_error_handler_after_processor_error ___________________\n\napp = <Flask 'flask_test'>, client = <FlaskClient <Flask 'flask_test'>>\n\n    def test_error_handler_after_processor_error(app, client):\n        app.testing = False\n    \n        @app.before_request\n        def before_request():\n            if _trigger == \"before\":\n                1 // 0\n    \n        @app.after_request\n        def after_request(response):\n            if _trigger == \"after\":\n                1 // 0\n            return response\n    \n        @app.route(\"/\")\n        def index():\n            return \"Foo\"\n    \n        @app.errorhandler(500)\n        def internal_server_error(e):\n            return \"Hello Server Error\", 500\n    \n        for _trigger in \"before\", \"after\":\n>           rv = client.get(\"/\")\n\ntests/test_basic.py:1107: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n/opt/miniconda3/envs/testbed/lib/python3.9/site-packages/werkzeug/test.py:1243: in get\n    return self.open(*args, **kw)\nsrc/flask/testing.py:209: in open\n    builder = EnvironBuilder(self.application, *args, **kwargs)\nsrc/flask/testing.py:70: in __init__\n    url = url_parse(path)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nurl = '/', scheme = None, allow_fragments = True\n\n    def url_parse(\n        url: str, scheme: str | None = None, allow_fragments: bool = True\n    ) -> BaseURL:\n        \"\"\"Parses a URL from a string into a :class:`URL` tuple.  If the URL\n        is lacking a scheme it can be provided as second argument. Otherwise,\n        it is ignored.  Optionally fragments can be stripped from the URL\n        by setting `allow_fragments` to `False`.\n    \n        The inverse of this function is :func:`url_unparse`.\n    \n        :param url: the URL to parse.\n        :param scheme: the default schema to use if the URL is schemaless.\n        :param allow_fragments: if set to `False` a fragment will be removed\n                                from the URL.\n    \n        .. deprecated:: 2.3\n            Will be removed in Werkzeug 3.0. Use ``urllib.parse.urlsplit`` instead.\n        \"\"\"\n>       warnings.warn(\n            \"'werkzeug.urls.url_parse' is deprecated and will be removed in Werkzeug 3.0.\"\n            \" Use 'urllib.parse.urlsplit' instead.\",\n            DeprecationWarning,\n            stacklevel=2,\n        )\nE       DeprecationWarning: 'werkzeug.urls.url_parse' is deprecated and will be removed in Werkzeug 3.0. Use 'urllib.parse.urlsplit' instead.\n\n/opt/miniconda3/envs/testbed/lib/python3.9/site-packages/werkzeug/urls.py:505: DeprecationWarning\n__________________________ test_enctype_debug_helper ___________________________\n\napp = <Flask 'flask_test'>, client = <FlaskClient <Flask 'flask_test'>>\n\n    def test_enctype_debug_helper(app, client):\n        from flask.debughelpers import DebugFilesKeyError\n    \n        app.debug = True\n    \n        @app.route(\"/fail\", methods=[\"POST\"])\n        def index():\n            return flask.request.files[\"foo\"].filename\n    \n        # with statement is important because we leave an exception on the\n        # stack otherwise and we want to ensure that this is not the case\n        # to not negatively affect other tests.\n        with client:\n            with pytest.raises(DebugFilesKeyError) as e:\n>               client.post(\"/fail\", data={\"foo\": \"index.txt\"})\n\ntests/test_basic.py:1126: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n/opt/miniconda3/envs/testbed/lib/python3.9/site-packages/werkzeug/test.py:1248: in post\n    return self.open(*args, **kw)\nsrc/flask/testing.py:209: in open\n    builder = EnvironBuilder(self.application, *args, **kwargs)\nsrc/flask/testing.py:70: in __init__\n    url = url_parse(path)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nurl = '/fail', scheme = None, allow_fragments = True\n\n    def url_parse(\n        url: str, scheme: str | None = None, allow_fragments: bool = True\n    ) -> BaseURL:\n        \"\"\"Parses a URL from a string into a :class:`URL` tuple.  If the URL\n        is lacking a scheme it can be provided as second argument. Otherwise,\n        it is ignored.  Optionally fragments can be stripped from the URL\n        by setting `allow_fragments` to `False`.\n    \n        The inverse of this function is :func:`url_unparse`.\n    \n        :param url: the URL to parse.\n        :param scheme: the default schema to use if the URL is schemaless.\n        :param allow_fragments: if set to `False` a fragment will be removed\n                                from the URL.\n    \n        .. deprecated:: 2.3\n            Will be removed in Werkzeug 3.0. Use ``urllib.parse.urlsplit`` instead.\n        \"\"\"\n>       warnings.warn(\n            \"'werkzeug.urls.url_parse' is deprecated and will be removed in Werkzeug 3.0.\"\n            \" Use 'urllib.parse.urlsplit' instead.\",\n            DeprecationWarning,\n            stacklevel=2,\n        )\nE       DeprecationWarning: 'werkzeug.urls.url_parse' is deprecated and will be removed in Werkzeug 3.0. Use 'urllib.parse.urlsplit' instead.\n\n/opt/miniconda3/envs/testbed/lib/python3.9/site-packages/werkzeug/urls.py:505: DeprecationWarning\n_____________________________ test_response_types ______________________________\n\napp = <Flask 'flask_test'>, client = <FlaskClient <Flask 'flask_test'>>\n\n    def test_response_types(app, client):\n        @app.route(\"/text\")\n        def from_text():\n            return \"H\u00e4llo W\u00f6rld\"\n    \n        @app.route(\"/bytes\")\n        def from_bytes():\n            return \"H\u00e4llo W\u00f6rld\".encode()\n    \n        @app.route(\"/full_tuple\")\n        def from_full_tuple():\n            return (\n                \"Meh\",\n                400,\n                {\"X-Foo\": \"Testing\", \"Content-Type\": \"text/plain; charset=utf-8\"},\n            )\n    \n        @app.route(\"/text_headers\")\n        def from_text_headers():\n            return \"Hello\", {\"X-Foo\": \"Test\", \"Content-Type\": \"text/plain; charset=utf-8\"}\n    \n        @app.route(\"/text_status\")\n        def from_text_status():\n            return \"Hi, status!\", 400\n    \n        @app.route(\"/response_headers\")\n        def from_response_headers():\n            return (\n                flask.Response(\n                    \"Hello world\", 404, {\"Content-Type\": \"text/html\", \"X-Foo\": \"Baz\"}\n                ),\n                {\"Content-Type\": \"text/plain\", \"X-Foo\": \"Bar\", \"X-Bar\": \"Foo\"},\n            )\n    \n        @app.route(\"/response_status\")\n        def from_response_status():\n            return app.response_class(\"Hello world\", 400), 500\n    \n        @app.route(\"/wsgi\")\n        def from_wsgi():\n            return NotFound()\n    \n        @app.route(\"/dict\")\n        def from_dict():\n            return {\"foo\": \"bar\"}, 201\n    \n>       assert client.get(\"/text\").data == \"H\u00e4llo W\u00f6rld\".encode()\n\ntests/test_basic.py:1177: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n/opt/miniconda3/envs/testbed/lib/python3.9/site-packages/werkzeug/test.py:1243: in get\n    return self.open(*args, **kw)\nsrc/flask/testing.py:209: in open\n    builder = EnvironBuilder(self.application, *args, **kwargs)\nsrc/flask/testing.py:70: in __init__\n    url = url_parse(path)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nurl = '/text', scheme = None, allow_fragments = True\n\n    def url_parse(\n        url: str, scheme: str | None = None, allow_fragments: bool = True\n    ) -> BaseURL:\n        \"\"\"Parses a URL from a string into a :class:`URL` tuple.  If the URL\n        is lacking a scheme it can be provided as second argument. Otherwise,\n        it is ignored.  Optionally fragments can be stripped from the URL\n        by setting `allow_fragments` to `False`.\n    \n        The inverse of this function is :func:`url_unparse`.\n    \n        :param url: the URL to parse.\n        :param scheme: the default schema to use if the URL is schemaless.\n        :param allow_fragments: if set to `False` a fragment will be removed\n                                from the URL.\n    \n        .. deprecated:: 2.3\n            Will be removed in Werkzeug 3.0. Use ``urllib.parse.urlsplit`` instead.\n        \"\"\"\n>       warnings.warn(\n            \"'werkzeug.urls.url_parse' is deprecated and will be removed in Werkzeug 3.0.\"\n            \" Use 'urllib.parse.urlsplit' instead.\",\n            DeprecationWarning,\n            stacklevel=2,\n        )\nE       DeprecationWarning: 'werkzeug.urls.url_parse' is deprecated and will be removed in Werkzeug 3.0. Use 'urllib.parse.urlsplit' instead.\n\n/opt/miniconda3/envs/testbed/lib/python3.9/site-packages/werkzeug/urls.py:505: DeprecationWarning\n__________________________ test_response_type_errors ___________________________\n\n    def test_response_type_errors():\n        app = flask.Flask(__name__)\n        app.testing = True\n    \n        @app.route(\"/none\")\n        def from_none():\n            pass\n    \n        @app.route(\"/small_tuple\")\n        def from_small_tuple():\n            return (\"Hello\",)\n    \n        @app.route(\"/large_tuple\")\n        def from_large_tuple():\n            return \"Hello\", 234, {\"X-Foo\": \"Bar\"}, \"???\"\n    \n        @app.route(\"/bad_type\")\n        def from_bad_type():\n            return True\n    \n        @app.route(\"/bad_wsgi\")\n        def from_bad_wsgi():\n            return lambda: None\n    \n        c = app.test_client()\n    \n        with pytest.raises(TypeError) as e:\n>           c.get(\"/none\")\n\ntests/test_basic.py:1244: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n/opt/miniconda3/envs/testbed/lib/python3.9/site-packages/werkzeug/test.py:1243: in get\n    return self.open(*args, **kw)\nsrc/flask/testing.py:209: in open\n    builder = EnvironBuilder(self.application, *args, **kwargs)\nsrc/flask/testing.py:70: in __init__\n    url = url_parse(path)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nurl = '/none', scheme = None, allow_fragments = True\n\n    def url_parse(\n        url: str, scheme: str | None = None, allow_fragments: bool = True\n    ) -> BaseURL:\n        \"\"\"Parses a URL from a string into a :class:`URL` tuple.  If the URL\n        is lacking a scheme it can be provided as second argument. Otherwise,\n        it is ignored.  Optionally fragments can be stripped from the URL\n        by setting `allow_fragments` to `False`.\n    \n        The inverse of this function is :func:`url_unparse`.\n    \n        :param url: the URL to parse.\n        :param scheme: the default schema to use if the URL is schemaless.\n        :param allow_fragments: if set to `False` a fragment will be removed\n                                from the URL.\n    \n        .. deprecated:: 2.3\n            Will be removed in Werkzeug 3.0. Use ``urllib.parse.urlsplit`` instead.\n        \"\"\"\n>       warnings.warn(\n            \"'werkzeug.urls.url_parse' is deprecated and will be removed in Werkzeug 3.0.\"\n            \" Use 'urllib.parse.urlsplit' instead.\",\n            DeprecationWarning,\n            stacklevel=2,\n        )\nE       DeprecationWarning: 'werkzeug.urls.url_parse' is deprecated and will be removed in Werkzeug 3.0. Use 'urllib.parse.urlsplit' instead.\n\n/opt/miniconda3/envs/testbed/lib/python3.9/site-packages/werkzeug/urls.py:505: DeprecationWarning\n___________________________ test_build_error_handler ___________________________\n\napp = <Flask 'flask_test'>\n\n    def test_build_error_handler(app):\n        # Test base case, a URL which results in a BuildError.\n>       with app.test_request_context():\n\ntests/test_basic.py:1356: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \nsrc/flask/app.py:2015: in test_request_context\n    builder = EnvironBuilder(self, *args, **kwargs)\nsrc/flask/testing.py:70: in __init__\n    url = url_parse(path)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nurl = '/', scheme = None, allow_fragments = True\n\n    def url_parse(\n        url: str, scheme: str | None = None, allow_fragments: bool = True\n    ) -> BaseURL:\n        \"\"\"Parses a URL from a string into a :class:`URL` tuple.  If the URL\n        is lacking a scheme it can be provided as second argument. Otherwise,\n        it is ignored.  Optionally fragments can be stripped from the URL\n        by setting `allow_fragments` to `False`.\n    \n        The inverse of this function is :func:`url_unparse`.\n    \n        :param url: the URL to parse.\n        :param scheme: the default schema to use if the URL is schemaless.\n        :param allow_fragments: if set to `False` a fragment will be removed\n                                from the URL.\n    \n        .. deprecated:: 2.3\n            Will be removed in Werkzeug 3.0. Use ``urllib.parse.urlsplit`` instead.\n        \"\"\"\n>       warnings.warn(\n            \"'werkzeug.urls.url_parse' is deprecated and will be removed in Werkzeug 3.0.\"\n            \" Use 'urllib.parse.urlsplit' instead.\",\n            DeprecationWarning,\n            stacklevel=2,\n        )\nE       DeprecationWarning: 'werkzeug.urls.url_parse' is deprecated and will be removed in Werkzeug 3.0. Use 'urllib.parse.urlsplit' instead.\n\n/opt/miniconda3/envs/testbed/lib/python3.9/site-packages/werkzeug/urls.py:505: DeprecationWarning\n_______________________ test_build_error_handler_reraise _______________________\n\napp = <Flask 'flask_test'>\n\n    def test_build_error_handler_reraise(app):\n        # Test a custom handler which reraises the BuildError\n        def handler_raises_build_error(error, endpoint, values):\n            raise error\n    \n        app.url_build_error_handlers.append(handler_raises_build_error)\n    \n>       with app.test_request_context():\n\ntests/test_basic.py:1387: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \nsrc/flask/app.py:2015: in test_request_context\n    builder = EnvironBuilder(self, *args, **kwargs)\nsrc/flask/testing.py:70: in __init__\n    url = url_parse(path)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nurl = '/', scheme = None, allow_fragments = True\n\n    def url_parse(\n        url: str, scheme: str | None = None, allow_fragments: bool = True\n    ) -> BaseURL:\n        \"\"\"Parses a URL from a string into a :class:`URL` tuple.  If the URL\n        is lacking a scheme it can be provided as second argument. Otherwise,\n        it is ignored.  Optionally fragments can be stripped from the URL\n        by setting `allow_fragments` to `False`.\n    \n        The inverse of this function is :func:`url_unparse`.\n    \n        :param url: the URL to parse.\n        :param scheme: the default schema to use if the URL is schemaless.\n        :param allow_fragments: if set to `False` a fragment will be removed\n                                from the URL.\n    \n        .. deprecated:: 2.3\n            Will be removed in Werkzeug 3.0. Use ``urllib.parse.urlsplit`` instead.\n        \"\"\"\n>       warnings.warn(\n            \"'werkzeug.urls.url_parse' is deprecated and will be removed in Werkzeug 3.0.\"\n            \" Use 'urllib.parse.urlsplit' instead.\",\n            DeprecationWarning,\n            stacklevel=2,\n        )\nE       DeprecationWarning: 'werkzeug.urls.url_parse' is deprecated and will be removed in Werkzeug 3.0. Use 'urllib.parse.urlsplit' instead.\n\n/opt/miniconda3/envs/testbed/lib/python3.9/site-packages/werkzeug/urls.py:505: DeprecationWarning\n__________ test_url_for_passes_special_values_to_build_error_handler ___________\n\napp = <Flask 'flask_test'>\n\n    def test_url_for_passes_special_values_to_build_error_handler(app):\n        @app.url_build_error_handlers.append\n        def handler(error, endpoint, values):\n            assert values == {\n                \"_external\": False,\n                \"_anchor\": None,\n                \"_method\": None,\n                \"_scheme\": None,\n            }\n            return \"handled\"\n    \n>       with app.test_request_context():\n\ntests/test_basic.py:1402: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \nsrc/flask/app.py:2015: in test_request_context\n    builder = EnvironBuilder(self, *args, **kwargs)\nsrc/flask/testing.py:70: in __init__\n    url = url_parse(path)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nurl = '/', scheme = None, allow_fragments = True\n\n    def url_parse(\n        url: str, scheme: str | None = None, allow_fragments: bool = True\n    ) -> BaseURL:\n        \"\"\"Parses a URL from a string into a :class:`URL` tuple.  If the URL\n        is lacking a scheme it can be provided as second argument. Otherwise,\n        it is ignored.  Optionally fragments can be stripped from the URL\n        by setting `allow_fragments` to `False`.\n    \n        The inverse of this function is :func:`url_unparse`.\n    \n        :param url: the URL to parse.\n        :param scheme: the default schema to use if the URL is schemaless.\n        :param allow_fragments: if set to `False` a fragment will be removed\n                                from the URL.\n    \n        .. deprecated:: 2.3\n            Will be removed in Werkzeug 3.0. Use ``urllib.parse.urlsplit`` instead.\n        \"\"\"\n>       warnings.warn(\n            \"'werkzeug.urls.url_parse' is deprecated and will be removed in Werkzeug 3.0.\"\n            \" Use 'urllib.parse.urlsplit' instead.\",\n            DeprecationWarning,\n            stacklevel=2,\n        )\nE       DeprecationWarning: 'werkzeug.urls.url_parse' is deprecated and will be removed in Werkzeug 3.0. Use 'urllib.parse.urlsplit' instead.\n\n/opt/miniconda3/envs/testbed/lib/python3.9/site-packages/werkzeug/urls.py:505: DeprecationWarning\n______________________________ test_static_files _______________________________\n\napp = <Flask 'flask_test'>, client = <FlaskClient <Flask 'flask_test'>>\n\n    def test_static_files(app, client):\n>       rv = client.get(\"/static/index.html\")\n\ntests/test_basic.py:1407: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n/opt/miniconda3/envs/testbed/lib/python3.9/site-packages/werkzeug/test.py:1243: in get\n    return self.open(*args, **kw)\nsrc/flask/testing.py:209: in open\n    builder = EnvironBuilder(self.application, *args, **kwargs)\nsrc/flask/testing.py:70: in __init__\n    url = url_parse(path)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nurl = '/static/index.html', scheme = None, allow_fragments = True\n\n    def url_parse(\n        url: str, scheme: str | None = None, allow_fragments: bool = True\n    ) -> BaseURL:\n        \"\"\"Parses a URL from a string into a :class:`URL` tuple.  If the URL\n        is lacking a scheme it can be provided as second argument. Otherwise,\n        it is ignored.  Optionally fragments can be stripped from the URL\n        by setting `allow_fragments` to `False`.\n    \n        The inverse of this function is :func:`url_unparse`.\n    \n        :param url: the URL to parse.\n        :param scheme: the default schema to use if the URL is schemaless.\n        :param allow_fragments: if set to `False` a fragment will be removed\n                                from the URL.\n    \n        .. deprecated:: 2.3\n            Will be removed in Werkzeug 3.0. Use ``urllib.parse.urlsplit`` instead.\n        \"\"\"\n>       warnings.warn(\n            \"'werkzeug.urls.url_parse' is deprecated and will be removed in Werkzeug 3.0.\"\n            \" Use 'urllib.parse.urlsplit' instead.\",\n            DeprecationWarning,\n            stacklevel=2,\n        )\nE       DeprecationWarning: 'werkzeug.urls.url_parse' is deprecated and will be removed in Werkzeug 3.0. Use 'urllib.parse.urlsplit' instead.\n\n/opt/miniconda3/envs/testbed/lib/python3.9/site-packages/werkzeug/urls.py:505: DeprecationWarning\n_____________________________ test_static_url_path _____________________________\n\n    def test_static_url_path():\n        app = flask.Flask(__name__, static_url_path=\"/foo\")\n        app.testing = True\n>       rv = app.test_client().get(\"/foo/index.html\")\n\ntests/test_basic.py:1418: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n/opt/miniconda3/envs/testbed/lib/python3.9/site-packages/werkzeug/test.py:1243: in get\n    return self.open(*args, **kw)\nsrc/flask/testing.py:209: in open\n    builder = EnvironBuilder(self.application, *args, **kwargs)\nsrc/flask/testing.py:70: in __init__\n    url = url_parse(path)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nurl = '/foo/index.html', scheme = None, allow_fragments = True\n\n    def url_parse(\n        url: str, scheme: str | None = None, allow_fragments: bool = True\n    ) -> BaseURL:\n        \"\"\"Parses a URL from a string into a :class:`URL` tuple.  If the URL\n        is lacking a scheme it can be provided as second argument. Otherwise,\n        it is ignored.  Optionally fragments can be stripped from the URL\n        by setting `allow_fragments` to `False`.\n    \n        The inverse of this function is :func:`url_unparse`.\n    \n        :param url: the URL to parse.\n        :param scheme: the default schema to use if the URL is schemaless.\n        :param allow_fragments: if set to `False` a fragment will be removed\n                                from the URL.\n    \n        .. deprecated:: 2.3\n            Will be removed in Werkzeug 3.0. Use ``urllib.parse.urlsplit`` instead.\n        \"\"\"\n>       warnings.warn(\n            \"'werkzeug.urls.url_parse' is deprecated and will be removed in Werkzeug 3.0.\"\n            \" Use 'urllib.parse.urlsplit' instead.\",\n            DeprecationWarning,\n            stacklevel=2,\n        )\nE       DeprecationWarning: 'werkzeug.urls.url_parse' is deprecated and will be removed in Werkzeug 3.0. Use 'urllib.parse.urlsplit' instead.\n\n/opt/miniconda3/envs/testbed/lib/python3.9/site-packages/werkzeug/urls.py:505: DeprecationWarning\n____________________ test_static_url_path_with_ending_slash ____________________\n\n    def test_static_url_path_with_ending_slash():\n        app = flask.Flask(__name__, static_url_path=\"/foo/\")\n        app.testing = True\n>       rv = app.test_client().get(\"/foo/index.html\")\n\ntests/test_basic.py:1429: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n/opt/miniconda3/envs/testbed/lib/python3.9/site-packages/werkzeug/test.py:1243: in get\n    return self.open(*args, **kw)\nsrc/flask/testing.py:209: in open\n    builder = EnvironBuilder(self.application, *args, **kwargs)\nsrc/flask/testing.py:70: in __init__\n    url = url_parse(path)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nurl = '/foo/index.html', scheme = None, allow_fragments = True\n\n    def url_parse(\n        url: str, scheme: str | None = None, allow_fragments: bool = True\n    ) -> BaseURL:\n        \"\"\"Parses a URL from a string into a :class:`URL` tuple.  If the URL\n        is lacking a scheme it can be provided as second argument. Otherwise,\n        it is ignored.  Optionally fragments can be stripped from the URL\n        by setting `allow_fragments` to `False`.\n    \n        The inverse of this function is :func:`url_unparse`.\n    \n        :param url: the URL to parse.\n        :param scheme: the default schema to use if the URL is schemaless.\n        :param allow_fragments: if set to `False` a fragment will be removed\n                                from the URL.\n    \n        .. deprecated:: 2.3\n            Will be removed in Werkzeug 3.0. Use ``urllib.parse.urlsplit`` instead.\n        \"\"\"\n>       warnings.warn(\n            \"'werkzeug.urls.url_parse' is deprecated and will be removed in Werkzeug 3.0.\"\n            \" Use 'urllib.parse.urlsplit' instead.\",\n            DeprecationWarning,\n            stacklevel=2,\n        )\nE       DeprecationWarning: 'werkzeug.urls.url_parse' is deprecated and will be removed in Werkzeug 3.0. Use 'urllib.parse.urlsplit' instead.\n\n/opt/miniconda3/envs/testbed/lib/python3.9/site-packages/werkzeug/urls.py:505: DeprecationWarning\n__________________________ test_static_url_empty_path __________________________\n\napp = <Flask 'test_basic'>\n\n    def test_static_url_empty_path(app):\n        app = flask.Flask(__name__, static_folder=\"\", static_url_path=\"\")\n>       rv = app.test_client().open(\"/static/index.html\", method=\"GET\")\n\ntests/test_basic.py:1439: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \nsrc/flask/testing.py:209: in open\n    builder = EnvironBuilder(self.application, *args, **kwargs)\nsrc/flask/testing.py:70: in __init__\n    url = url_parse(path)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nurl = '/static/index.html', scheme = None, allow_fragments = True\n\n    def url_parse(\n        url: str, scheme: str | None = None, allow_fragments: bool = True\n    ) -> BaseURL:\n        \"\"\"Parses a URL from a string into a :class:`URL` tuple.  If the URL\n        is lacking a scheme it can be provided as second argument. Otherwise,\n        it is ignored.  Optionally fragments can be stripped from the URL\n        by setting `allow_fragments` to `False`.\n    \n        The inverse of this function is :func:`url_unparse`.\n    \n        :param url: the URL to parse.\n        :param scheme: the default schema to use if the URL is schemaless.\n        :param allow_fragments: if set to `False` a fragment will be removed\n                                from the URL.\n    \n        .. deprecated:: 2.3\n            Will be removed in Werkzeug 3.0. Use ``urllib.parse.urlsplit`` instead.\n        \"\"\"\n>       warnings.warn(\n            \"'werkzeug.urls.url_parse' is deprecated and will be removed in Werkzeug 3.0.\"\n            \" Use 'urllib.parse.urlsplit' instead.\",\n            DeprecationWarning,\n            stacklevel=2,\n        )\nE       DeprecationWarning: 'werkzeug.urls.url_parse' is deprecated and will be removed in Werkzeug 3.0. Use 'urllib.parse.urlsplit' instead.\n\n/opt/miniconda3/envs/testbed/lib/python3.9/site-packages/werkzeug/urls.py:505: DeprecationWarning\n______________________ test_static_url_empty_path_default ______________________\n\napp = <Flask 'test_basic'>\n\n    def test_static_url_empty_path_default(app):\n        app = flask.Flask(__name__, static_folder=\"\")\n>       rv = app.test_client().open(\"/static/index.html\", method=\"GET\")\n\ntests/test_basic.py:1446: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \nsrc/flask/testing.py:209: in open\n    builder = EnvironBuilder(self.application, *args, **kwargs)\nsrc/flask/testing.py:70: in __init__\n    url = url_parse(path)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nurl = '/static/index.html', scheme = None, allow_fragments = True\n\n    def url_parse(\n        url: str, scheme: str | None = None, allow_fragments: bool = True\n    ) -> BaseURL:\n        \"\"\"Parses a URL from a string into a :class:`URL` tuple.  If the URL\n        is lacking a scheme it can be provided as second argument. Otherwise,\n        it is ignored.  Optionally fragments can be stripped from the URL\n        by setting `allow_fragments` to `False`.\n    \n        The inverse of this function is :func:`url_unparse`.\n    \n        :param url: the URL to parse.\n        :param scheme: the default schema to use if the URL is schemaless.\n        :param allow_fragments: if set to `False` a fragment will be removed\n                                from the URL.\n    \n        .. deprecated:: 2.3\n            Will be removed in Werkzeug 3.0. Use ``urllib.parse.urlsplit`` instead.\n        \"\"\"\n>       warnings.warn(\n            \"'werkzeug.urls.url_parse' is deprecated and will be removed in Werkzeug 3.0.\"\n            \" Use 'urllib.parse.urlsplit' instead.\",\n            DeprecationWarning,\n            stacklevel=2,\n        )\nE       DeprecationWarning: 'werkzeug.urls.url_parse' is deprecated and will be removed in Werkzeug 3.0. Use 'urllib.parse.urlsplit' instead.\n\n/opt/miniconda3/envs/testbed/lib/python3.9/site-packages/werkzeug/urls.py:505: DeprecationWarning\n_____________________ test_static_folder_with_pathlib_path _____________________\n\napp = <Flask 'test_basic'>\n\n    @pytest.mark.skipif(sys.version_info < (3, 6), reason=\"requires Python >= 3.6\")\n    def test_static_folder_with_pathlib_path(app):\n        from pathlib import Path\n    \n        app = flask.Flask(__name__, static_folder=Path(\"static\"))\n>       rv = app.test_client().open(\"/static/index.html\", method=\"GET\")\n\ntests/test_basic.py:1456: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \nsrc/flask/testing.py:209: in open\n    builder = EnvironBuilder(self.application, *args, **kwargs)\nsrc/flask/testing.py:70: in __init__\n    url = url_parse(path)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nurl = '/static/index.html', scheme = None, allow_fragments = True\n\n    def url_parse(\n        url: str, scheme: str | None = None, allow_fragments: bool = True\n    ) -> BaseURL:\n        \"\"\"Parses a URL from a string into a :class:`URL` tuple.  If the URL\n        is lacking a scheme it can be provided as second argument. Otherwise,\n        it is ignored.  Optionally fragments can be stripped from the URL\n        by setting `allow_fragments` to `False`.\n    \n        The inverse of this function is :func:`url_unparse`.\n    \n        :param url: the URL to parse.\n        :param scheme: the default schema to use if the URL is schemaless.\n        :param allow_fragments: if set to `False` a fragment will be removed\n                                from the URL.\n    \n        .. deprecated:: 2.3\n            Will be removed in Werkzeug 3.0. Use ``urllib.parse.urlsplit`` instead.\n        \"\"\"\n>       warnings.warn(\n            \"'werkzeug.urls.url_parse' is deprecated and will be removed in Werkzeug 3.0.\"\n            \" Use 'urllib.parse.urlsplit' instead.\",\n            DeprecationWarning,\n            stacklevel=2,\n        )\nE       DeprecationWarning: 'werkzeug.urls.url_parse' is deprecated and will be removed in Werkzeug 3.0. Use 'urllib.parse.urlsplit' instead.\n\n/opt/miniconda3/envs/testbed/lib/python3.9/site-packages/werkzeug/urls.py:505: DeprecationWarning\n_____________________ test_static_folder_with_ending_slash _____________________\n\n    def test_static_folder_with_ending_slash():\n        app = flask.Flask(__name__, static_folder=\"static/\")\n    \n        @app.route(\"/<path:path>\")\n        def catch_all(path):\n            return path\n    \n>       rv = app.test_client().get(\"/catch/all\")\n\ntests/test_basic.py:1468: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n/opt/miniconda3/envs/testbed/lib/python3.9/site-packages/werkzeug/test.py:1243: in get\n    return self.open(*args, **kw)\nsrc/flask/testing.py:209: in open\n    builder = EnvironBuilder(self.application, *args, **kwargs)\nsrc/flask/testing.py:70: in __init__\n    url = url_parse(path)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nurl = '/catch/all', scheme = None, allow_fragments = True\n\n    def url_parse(\n        url: str, scheme: str | None = None, allow_fragments: bool = True\n    ) -> BaseURL:\n        \"\"\"Parses a URL from a string into a :class:`URL` tuple.  If the URL\n        is lacking a scheme it can be provided as second argument. Otherwise,\n        it is ignored.  Optionally fragments can be stripped from the URL\n        by setting `allow_fragments` to `False`.\n    \n        The inverse of this function is :func:`url_unparse`.\n    \n        :param url: the URL to parse.\n        :param scheme: the default schema to use if the URL is schemaless.\n        :param allow_fragments: if set to `False` a fragment will be removed\n                                from the URL.\n    \n        .. deprecated:: 2.3\n            Will be removed in Werkzeug 3.0. Use ``urllib.parse.urlsplit`` instead.\n        \"\"\"\n>       warnings.warn(\n            \"'werkzeug.urls.url_parse' is deprecated and will be removed in Werkzeug 3.0.\"\n            \" Use 'urllib.parse.urlsplit' instead.\",\n            DeprecationWarning,\n            stacklevel=2,\n        )\nE       DeprecationWarning: 'werkzeug.urls.url_parse' is deprecated and will be removed in Werkzeug 3.0. Use 'urllib.parse.urlsplit' instead.\n\n/opt/miniconda3/envs/testbed/lib/python3.9/site-packages/werkzeug/urls.py:505: DeprecationWarning\n_____________________ test_static_route_with_host_matching _____________________\n\n    def test_static_route_with_host_matching():\n        app = flask.Flask(__name__, host_matching=True, static_host=\"example.com\")\n        c = app.test_client()\n>       rv = c.get(\"http://example.com/static/index.html\")\n\ntests/test_basic.py:1475: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n/opt/miniconda3/envs/testbed/lib/python3.9/site-packages/werkzeug/test.py:1243: in get\n    return self.open(*args, **kw)\nsrc/flask/testing.py:209: in open\n    builder = EnvironBuilder(self.application, *args, **kwargs)\nsrc/flask/testing.py:70: in __init__\n    url = url_parse(path)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nurl = 'http://example.com/static/index.html', scheme = None\nallow_fragments = True\n\n    def url_parse(\n        url: str, scheme: str | None = None, allow_fragments: bool = True\n    ) -> BaseURL:\n        \"\"\"Parses a URL from a string into a :class:`URL` tuple.  If the URL\n        is lacking a scheme it can be provided as second argument. Otherwise,\n        it is ignored.  Optionally fragments can be stripped from the URL\n        by setting `allow_fragments` to `False`.\n    \n        The inverse of this function is :func:`url_unparse`.\n    \n        :param url: the URL to parse.\n        :param scheme: the default schema to use if the URL is schemaless.\n        :param allow_fragments: if set to `False` a fragment will be removed\n                                from the URL.\n    \n        .. deprecated:: 2.3\n            Will be removed in Werkzeug 3.0. Use ``urllib.parse.urlsplit`` instead.\n        \"\"\"\n>       warnings.warn(\n            \"'werkzeug.urls.url_parse' is deprecated and will be removed in Werkzeug 3.0.\"\n            \" Use 'urllib.parse.urlsplit' instead.\",\n            DeprecationWarning,\n            stacklevel=2,\n        )\nE       DeprecationWarning: 'werkzeug.urls.url_parse' is deprecated and will be removed in Werkzeug 3.0. Use 'urllib.parse.urlsplit' instead.\n\n/opt/miniconda3/envs/testbed/lib/python3.9/site-packages/werkzeug/urls.py:505: DeprecationWarning\n__________________________ test_server_name_subdomain __________________________\n\n    def test_server_name_subdomain():\n        app = flask.Flask(__name__, subdomain_matching=True)\n        client = app.test_client()\n    \n        @app.route(\"/\")\n        def index():\n            return \"default\"\n    \n        @app.route(\"/\", subdomain=\"foo\")\n        def subdomain():\n            return \"subdomain\"\n    \n        app.config[\"SERVER_NAME\"] = \"dev.local:5000\"\n>       rv = client.get(\"/\")\n\ntests/test_basic.py:1511: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n/opt/miniconda3/envs/testbed/lib/python3.9/site-packages/werkzeug/test.py:1243: in get\n    return self.open(*args, **kw)\nsrc/flask/testing.py:209: in open\n    builder = EnvironBuilder(self.application, *args, **kwargs)\nsrc/flask/testing.py:70: in __init__\n    url = url_parse(path)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nurl = '/', scheme = None, allow_fragments = True\n\n    def url_parse(\n        url: str, scheme: str | None = None, allow_fragments: bool = True\n    ) -> BaseURL:\n        \"\"\"Parses a URL from a string into a :class:`URL` tuple.  If the URL\n        is lacking a scheme it can be provided as second argument. Otherwise,\n        it is ignored.  Optionally fragments can be stripped from the URL\n        by setting `allow_fragments` to `False`.\n    \n        The inverse of this function is :func:`url_unparse`.\n    \n        :param url: the URL to parse.\n        :param scheme: the default schema to use if the URL is schemaless.\n        :param allow_fragments: if set to `False` a fragment will be removed\n                                from the URL.\n    \n        .. deprecated:: 2.3\n            Will be removed in Werkzeug 3.0. Use ``urllib.parse.urlsplit`` instead.\n        \"\"\"\n>       warnings.warn(\n            \"'werkzeug.urls.url_parse' is deprecated and will be removed in Werkzeug 3.0.\"\n            \" Use 'urllib.parse.urlsplit' instead.\",\n            DeprecationWarning,\n            stacklevel=2,\n        )\nE       DeprecationWarning: 'werkzeug.urls.url_parse' is deprecated and will be removed in Werkzeug 3.0. Use 'urllib.parse.urlsplit' instead.\n\n/opt/miniconda3/envs/testbed/lib/python3.9/site-packages/werkzeug/urls.py:505: DeprecationWarning\n___________________________ test_max_content_length ____________________________\n\napp = <Flask 'flask_test'>, client = <FlaskClient <Flask 'flask_test'>>\n\n    def test_max_content_length(app, client):\n        app.config[\"MAX_CONTENT_LENGTH\"] = 64\n    \n        @app.before_request\n        def always_first():\n            flask.request.form[\"myfile\"]\n            AssertionError()\n    \n        @app.route(\"/accept\", methods=[\"POST\"])\n        def accept_file():\n            flask.request.form[\"myfile\"]\n            AssertionError()\n    \n        @app.errorhandler(413)\n        def catcher(error):\n            return \"42\"\n    \n>       rv = client.post(\"/accept\", data={\"myfile\": \"foo\" * 100})\n\ntests/test_basic.py:1600: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n/opt/miniconda3/envs/testbed/lib/python3.9/site-packages/werkzeug/test.py:1248: in post\n    return self.open(*args, **kw)\nsrc/flask/testing.py:209: in open\n    builder = EnvironBuilder(self.application, *args, **kwargs)\nsrc/flask/testing.py:70: in __init__\n    url = url_parse(path)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nurl = '/accept', scheme = None, allow_fragments = True\n\n    def url_parse(\n        url: str, scheme: str | None = None, allow_fragments: bool = True\n    ) -> BaseURL:\n        \"\"\"Parses a URL from a string into a :class:`URL` tuple.  If the URL\n        is lacking a scheme it can be provided as second argument. Otherwise,\n        it is ignored.  Optionally fragments can be stripped from the URL\n        by setting `allow_fragments` to `False`.\n    \n        The inverse of this function is :func:`url_unparse`.\n    \n        :param url: the URL to parse.\n        :param scheme: the default schema to use if the URL is schemaless.\n        :param allow_fragments: if set to `False` a fragment will be removed\n                                from the URL.\n    \n        .. deprecated:: 2.3\n            Will be removed in Werkzeug 3.0. Use ``urllib.parse.urlsplit`` instead.\n        \"\"\"\n>       warnings.warn(\n            \"'werkzeug.urls.url_parse' is deprecated and will be removed in Werkzeug 3.0.\"\n            \" Use 'urllib.parse.urlsplit' instead.\",\n            DeprecationWarning,\n            stacklevel=2,\n        )\nE       DeprecationWarning: 'werkzeug.urls.url_parse' is deprecated and will be removed in Werkzeug 3.0. Use 'urllib.parse.urlsplit' instead.\n\n/opt/miniconda3/envs/testbed/lib/python3.9/site-packages/werkzeug/urls.py:505: DeprecationWarning\n_____________________________ test_url_processors ______________________________\n\napp = <Flask 'flask_test'>, client = <FlaskClient <Flask 'flask_test'>>\n\n    def test_url_processors(app, client):\n        @app.url_defaults\n        def add_language_code(endpoint, values):\n            if flask.g.lang_code is not None and app.url_map.is_endpoint_expecting(\n                endpoint, \"lang_code\"\n            ):\n                values.setdefault(\"lang_code\", flask.g.lang_code)\n    \n        @app.url_value_preprocessor\n        def pull_lang_code(endpoint, values):\n            flask.g.lang_code = values.pop(\"lang_code\", None)\n    \n        @app.route(\"/<lang_code>/\")\n        def index():\n            return flask.url_for(\"about\")\n    \n        @app.route(\"/<lang_code>/about\")\n        def about():\n            return flask.url_for(\"something_else\")\n    \n        @app.route(\"/foo\")\n        def something_else():\n            return flask.url_for(\"about\", lang_code=\"en\")\n    \n>       assert client.get(\"/de/\").data == b\"/de/about\"\n\ntests/test_basic.py:1628: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n/opt/miniconda3/envs/testbed/lib/python3.9/site-packages/werkzeug/test.py:1243: in get\n    return self.open(*args, **kw)\nsrc/flask/testing.py:209: in open\n    builder = EnvironBuilder(self.application, *args, **kwargs)\nsrc/flask/testing.py:70: in __init__\n    url = url_parse(path)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nurl = '/de/', scheme = None, allow_fragments = True\n\n    def url_parse(\n        url: str, scheme: str | None = None, allow_fragments: bool = True\n    ) -> BaseURL:\n        \"\"\"Parses a URL from a string into a :class:`URL` tuple.  If the URL\n        is lacking a scheme it can be provided as second argument. Otherwise,\n        it is ignored.  Optionally fragments can be stripped from the URL\n        by setting `allow_fragments` to `False`.\n    \n        The inverse of this function is :func:`url_unparse`.\n    \n        :param url: the URL to parse.\n        :param scheme: the default schema to use if the URL is schemaless.\n        :param allow_fragments: if set to `False` a fragment will be removed\n                                from the URL.\n    \n        .. deprecated:: 2.3\n            Will be removed in Werkzeug 3.0. Use ``urllib.parse.urlsplit`` instead.\n        \"\"\"\n>       warnings.warn(\n            \"'werkzeug.urls.url_parse' is deprecated and will be removed in Werkzeug 3.0.\"\n            \" Use 'urllib.parse.urlsplit' instead.\",\n            DeprecationWarning,\n            stacklevel=2,\n        )\nE       DeprecationWarning: 'werkzeug.urls.url_parse' is deprecated and will be removed in Werkzeug 3.0. Use 'urllib.parse.urlsplit' instead.\n\n/opt/miniconda3/envs/testbed/lib/python3.9/site-packages/werkzeug/urls.py:505: DeprecationWarning\n______________________ test_inject_blueprint_url_defaults ______________________\n\napp = <Flask 'flask_test'>\n\n    def test_inject_blueprint_url_defaults(app):\n        bp = flask.Blueprint(\"foo\", __name__, template_folder=\"template\")\n    \n        @bp.url_defaults\n        def bp_defaults(endpoint, values):\n            values[\"page\"] = \"login\"\n    \n        @bp.route(\"/<page>\")\n        def view(page):\n            pass\n    \n        app.register_blueprint(bp)\n    \n        values = dict()\n        app.inject_url_defaults(\"foo.view\", values)\n        expected = dict(page=\"login\")\n        assert values == expected\n    \n>       with app.test_request_context(\"/somepage\"):\n\ntests/test_basic.py:1651: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \nsrc/flask/app.py:2015: in test_request_context\n    builder = EnvironBuilder(self, *args, **kwargs)\nsrc/flask/testing.py:70: in __init__\n    url = url_parse(path)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nurl = '/somepage', scheme = None, allow_fragments = True\n\n    def url_parse(\n        url: str, scheme: str | None = None, allow_fragments: bool = True\n    ) -> BaseURL:\n        \"\"\"Parses a URL from a string into a :class:`URL` tuple.  If the URL\n        is lacking a scheme it can be provided as second argument. Otherwise,\n        it is ignored.  Optionally fragments can be stripped from the URL\n        by setting `allow_fragments` to `False`.\n    \n        The inverse of this function is :func:`url_unparse`.\n    \n        :param url: the URL to parse.\n        :param scheme: the default schema to use if the URL is schemaless.\n        :param allow_fragments: if set to `False` a fragment will be removed\n                                from the URL.\n    \n        .. deprecated:: 2.3\n            Will be removed in Werkzeug 3.0. Use ``urllib.parse.urlsplit`` instead.\n        \"\"\"\n>       warnings.warn(\n            \"'werkzeug.urls.url_parse' is deprecated and will be removed in Werkzeug 3.0.\"\n            \" Use 'urllib.parse.urlsplit' instead.\",\n            DeprecationWarning,\n            stacklevel=2,\n        )\nE       DeprecationWarning: 'werkzeug.urls.url_parse' is deprecated and will be removed in Werkzeug 3.0. Use 'urllib.parse.urlsplit' instead.\n\n/opt/miniconda3/envs/testbed/lib/python3.9/site-packages/werkzeug/urls.py:505: DeprecationWarning\n____________________________ test_nonascii_pathinfo ____________________________\n\napp = <Flask 'flask_test'>, client = <FlaskClient <Flask 'flask_test'>>\n\n    def test_nonascii_pathinfo(app, client):\n        @app.route(\"/\u043a\u0438\u0440\u0442\u0435\u0441\u0442\")\n        def index():\n            return \"Hello World!\"\n    \n>       rv = client.get(\"/\u043a\u0438\u0440\u0442\u0435\u0441\u0442\")\n\ntests/test_basic.py:1662: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n/opt/miniconda3/envs/testbed/lib/python3.9/site-packages/werkzeug/test.py:1243: in get\n    return self.open(*args, **kw)\nsrc/flask/testing.py:209: in open\n    builder = EnvironBuilder(self.application, *args, **kwargs)\nsrc/flask/testing.py:70: in __init__\n    url = url_parse(path)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nurl = '/\u043a\u0438\u0440\u0442\u0435\u0441\u0442', scheme = None, allow_fragments = True\n\n    def url_parse(\n        url: str, scheme: str | None = None, allow_fragments: bool = True\n    ) -> BaseURL:\n        \"\"\"Parses a URL from a string into a :class:`URL` tuple.  If the URL\n        is lacking a scheme it can be provided as second argument. Otherwise,\n        it is ignored.  Optionally fragments can be stripped from the URL\n        by setting `allow_fragments` to `False`.\n    \n        The inverse of this function is :func:`url_unparse`.\n    \n        :param url: the URL to parse.\n        :param scheme: the default schema to use if the URL is schemaless.\n        :param allow_fragments: if set to `False` a fragment will be removed\n                                from the URL.\n    \n        .. deprecated:: 2.3\n            Will be removed in Werkzeug 3.0. Use ``urllib.parse.urlsplit`` instead.\n        \"\"\"\n>       warnings.warn(\n            \"'werkzeug.urls.url_parse' is deprecated and will be removed in Werkzeug 3.0.\"\n            \" Use 'urllib.parse.urlsplit' instead.\",\n            DeprecationWarning,\n            stacklevel=2,\n        )\nE       DeprecationWarning: 'werkzeug.urls.url_parse' is deprecated and will be removed in Werkzeug 3.0. Use 'urllib.parse.urlsplit' instead.\n\n/opt/miniconda3/envs/testbed/lib/python3.9/site-packages/werkzeug/urls.py:505: DeprecationWarning\n________________ test_debug_mode_complains_after_first_request _________________\n\napp = <Flask 'flask_test'>, client = <FlaskClient <Flask 'flask_test'>>\n\n    def test_debug_mode_complains_after_first_request(app, client):\n        app.debug = True\n    \n        @app.route(\"/\")\n        def index():\n            return \"Awesome\"\n    \n        assert not app.got_first_request\n>       assert client.get(\"/\").data == b\"Awesome\"\n\ntests/test_basic.py:1674: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n/opt/miniconda3/envs/testbed/lib/python3.9/site-packages/werkzeug/test.py:1243: in get\n    return self.open(*args, **kw)\nsrc/flask/testing.py:209: in open\n    builder = EnvironBuilder(self.application, *args, **kwargs)\nsrc/flask/testing.py:70: in __init__\n    url = url_parse(path)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nurl = '/', scheme = None, allow_fragments = True\n\n    def url_parse(\n        url: str, scheme: str | None = None, allow_fragments: bool = True\n    ) -> BaseURL:\n        \"\"\"Parses a URL from a string into a :class:`URL` tuple.  If the URL\n        is lacking a scheme it can be provided as second argument. Otherwise,\n        it is ignored.  Optionally fragments can be stripped from the URL\n        by setting `allow_fragments` to `False`.\n    \n        The inverse of this function is :func:`url_unparse`.\n    \n        :param url: the URL to parse.\n        :param scheme: the default schema to use if the URL is schemaless.\n        :param allow_fragments: if set to `False` a fragment will be removed\n                                from the URL.\n    \n        .. deprecated:: 2.3\n            Will be removed in Werkzeug 3.0. Use ``urllib.parse.urlsplit`` instead.\n        \"\"\"\n>       warnings.warn(\n            \"'werkzeug.urls.url_parse' is deprecated and will be removed in Werkzeug 3.0.\"\n            \" Use 'urllib.parse.urlsplit' instead.\",\n            DeprecationWarning,\n            stacklevel=2,\n        )\nE       DeprecationWarning: 'werkzeug.urls.url_parse' is deprecated and will be removed in Werkzeug 3.0. Use 'urllib.parse.urlsplit' instead.\n\n/opt/miniconda3/envs/testbed/lib/python3.9/site-packages/werkzeug/urls.py:505: DeprecationWarning\n_____________________ test_before_first_request_functions ______________________\n\napp = <Flask 'flask_test'>, client = <FlaskClient <Flask 'flask_test'>>\n\n    def test_before_first_request_functions(app, client):\n        got = []\n    \n        @app.before_first_request\n        def foo():\n            got.append(42)\n    \n>       client.get(\"/\")\n\ntests/test_basic.py:1700: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n/opt/miniconda3/envs/testbed/lib/python3.9/site-packages/werkzeug/test.py:1243: in get\n    return self.open(*args, **kw)\nsrc/flask/testing.py:209: in open\n    builder = EnvironBuilder(self.application, *args, **kwargs)\nsrc/flask/testing.py:70: in __init__\n    url = url_parse(path)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nurl = '/', scheme = None, allow_fragments = True\n\n    def url_parse(\n        url: str, scheme: str | None = None, allow_fragments: bool = True\n    ) -> BaseURL:\n        \"\"\"Parses a URL from a string into a :class:`URL` tuple.  If the URL\n        is lacking a scheme it can be provided as second argument. Otherwise,\n        it is ignored.  Optionally fragments can be stripped from the URL\n        by setting `allow_fragments` to `False`.\n    \n        The inverse of this function is :func:`url_unparse`.\n    \n        :param url: the URL to parse.\n        :param scheme: the default schema to use if the URL is schemaless.\n        :param allow_fragments: if set to `False` a fragment will be removed\n                                from the URL.\n    \n        .. deprecated:: 2.3\n            Will be removed in Werkzeug 3.0. Use ``urllib.parse.urlsplit`` instead.\n        \"\"\"\n>       warnings.warn(\n            \"'werkzeug.urls.url_parse' is deprecated and will be removed in Werkzeug 3.0.\"\n            \" Use 'urllib.parse.urlsplit' instead.\",\n            DeprecationWarning,\n            stacklevel=2,\n        )\nE       DeprecationWarning: 'werkzeug.urls.url_parse' is deprecated and will be removed in Werkzeug 3.0. Use 'urllib.parse.urlsplit' instead.\n\n/opt/miniconda3/envs/testbed/lib/python3.9/site-packages/werkzeug/urls.py:505: DeprecationWarning\n________________ test_before_first_request_functions_concurrent ________________\n\ncls = <class '_pytest.runner.CallInfo'>\nfunc = <function call_runtest_hook.<locals>.<lambda> at 0x7f487baea310>\nwhen = 'call'\nreraise = (<class '_pytest.outcomes.Exit'>, <class 'KeyboardInterrupt'>)\n\n    @classmethod\n    def from_call(\n        cls,\n        func: \"Callable[[], TResult]\",\n        when: \"Literal['collect', 'setup', 'call', 'teardown']\",\n        reraise: Optional[\n            Union[Type[BaseException], Tuple[Type[BaseException], ...]]\n        ] = None,\n    ) -> \"CallInfo[TResult]\":\n        excinfo = None\n        start = timing.time()\n        precise_start = timing.perf_counter()\n        try:\n>           result: Optional[TResult] = func()\n\n/opt/miniconda3/envs/testbed/lib/python3.9/site-packages/_pytest/runner.py:311: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n/opt/miniconda3/envs/testbed/lib/python3.9/site-packages/_pytest/runner.py:255: in <lambda>\n    lambda: ihook(item=item, **kwds), when=when, reraise=reraise\n/opt/miniconda3/envs/testbed/lib/python3.9/site-packages/pluggy/_hooks.py:265: in __call__\n    return self._hookexec(self.name, self.get_hookimpls(), kwargs, firstresult)\n/opt/miniconda3/envs/testbed/lib/python3.9/site-packages/pluggy/_manager.py:80: in _hookexec\n    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)\n/opt/miniconda3/envs/testbed/lib/python3.9/site-packages/_pytest/threadexception.py:85: in pytest_runtest_call\n    yield from thread_exception_runtest_hook()\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\n    def thread_exception_runtest_hook() -> Generator[None, None, None]:\n        with catch_threading_exception() as cm:\n            yield\n            if cm.args:\n                if cm.args.thread is not None:\n                    thread_name = cm.args.thread.name\n                else:\n                    thread_name = \"<unknown>\"\n                msg = f\"Exception in thread {thread_name}\\n\\n\"\n                msg += \"\".join(\n                    traceback.format_exception(\n                        cm.args.exc_type, cm.args.exc_value, cm.args.exc_traceback,\n                    )\n                )\n>               warnings.warn(pytest.PytestUnhandledThreadExceptionWarning(msg))\nE               pytest.PytestUnhandledThreadExceptionWarning: Exception in thread Thread-5\nE               \nE               Traceback (most recent call last):\nE                 File \"/opt/miniconda3/envs/testbed/lib/python3.9/threading.py\", line 980, in _bootstrap_inner\nE                   self.run()\nE                 File \"/opt/miniconda3/envs/testbed/lib/python3.9/threading.py\", line 917, in run\nE                   self._target(*self._args, **self._kwargs)\nE                 File \"/testbed/tests/test_basic.py\", line 1716, in get_and_assert\nE                   client.get(\"/\")\nE                 File \"/opt/miniconda3/envs/testbed/lib/python3.9/site-packages/werkzeug/test.py\", line 1243, in get\nE                   return self.open(*args, **kw)\nE                 File \"/testbed/src/flask/testing.py\", line 209, in open\nE                   builder = EnvironBuilder(self.application, *args, **kwargs)\nE                 File \"/testbed/src/flask/testing.py\", line 70, in __init__\nE                   url = url_parse(path)\nE                 File \"/opt/miniconda3/envs/testbed/lib/python3.9/site-packages/werkzeug/urls.py\", line 505, in url_parse\nE                   warnings.warn(\nE               DeprecationWarning: 'werkzeug.urls.url_parse' is deprecated and will be removed in Werkzeug 3.0. Use 'urllib.parse.urlsplit' instead.\n\n/opt/miniconda3/envs/testbed/lib/python3.9/site-packages/_pytest/threadexception.py:75: PytestUnhandledThreadExceptionWarning\n_______________________ test_routing_redirect_debugging ________________________\n\napp = <Flask 'flask_test'>, client = <FlaskClient <Flask 'flask_test'>>\n\n    def test_routing_redirect_debugging(app, client):\n        app.debug = True\n    \n        @app.route(\"/foo/\", methods=[\"GET\", \"POST\"])\n        def foo():\n            return \"success\"\n    \n        with client:\n            with pytest.raises(AssertionError) as e:\n>               client.post(\"/foo\", data={})\n\ntests/test_basic.py:1735: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n/opt/miniconda3/envs/testbed/lib/python3.9/site-packages/werkzeug/test.py:1248: in post\n    return self.open(*args, **kw)\nsrc/flask/testing.py:209: in open\n    builder = EnvironBuilder(self.application, *args, **kwargs)\nsrc/flask/testing.py:70: in __init__\n    url = url_parse(path)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nurl = '/foo', scheme = None, allow_fragments = True\n\n    def url_parse(\n        url: str, scheme: str | None = None, allow_fragments: bool = True\n    ) -> BaseURL:\n        \"\"\"Parses a URL from a string into a :class:`URL` tuple.  If the URL\n        is lacking a scheme it can be provided as second argument. Otherwise,\n        it is ignored.  Optionally fragments can be stripped from the URL\n        by setting `allow_fragments` to `False`.\n    \n        The inverse of this function is :func:`url_unparse`.\n    \n        :param url: the URL to parse.\n        :param scheme: the default schema to use if the URL is schemaless.\n        :param allow_fragments: if set to `False` a fragment will be removed\n                                from the URL.\n    \n        .. deprecated:: 2.3\n            Will be removed in Werkzeug 3.0. Use ``urllib.parse.urlsplit`` instead.\n        \"\"\"\n>       warnings.warn(\n            \"'werkzeug.urls.url_parse' is deprecated and will be removed in Werkzeug 3.0.\"\n            \" Use 'urllib.parse.urlsplit' instead.\",\n            DeprecationWarning,\n            stacklevel=2,\n        )\nE       DeprecationWarning: 'werkzeug.urls.url_parse' is deprecated and will be removed in Werkzeug 3.0. Use 'urllib.parse.urlsplit' instead.\n\n/opt/miniconda3/envs/testbed/lib/python3.9/site-packages/werkzeug/urls.py:505: DeprecationWarning\n_____________________ test_route_decorator_custom_endpoint _____________________\n\napp = <Flask 'flask_test'>, client = <FlaskClient <Flask 'flask_test'>>\n\n    def test_route_decorator_custom_endpoint(app, client):\n        app.debug = True\n    \n        @app.route(\"/foo/\")\n        def foo():\n            return flask.request.endpoint\n    \n        @app.route(\"/bar/\", endpoint=\"bar\")\n        def for_bar():\n            return flask.request.endpoint\n    \n        @app.route(\"/bar/123\", endpoint=\"123\")\n        def for_bar_foo():\n            return flask.request.endpoint\n    \n>       with app.test_request_context():\n\ntests/test_basic.py:1765: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \nsrc/flask/app.py:2015: in test_request_context\n    builder = EnvironBuilder(self, *args, **kwargs)\nsrc/flask/testing.py:70: in __init__\n    url = url_parse(path)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nurl = '/', scheme = None, allow_fragments = True\n\n    def url_parse(\n        url: str, scheme: str | None = None, allow_fragments: bool = True\n    ) -> BaseURL:\n        \"\"\"Parses a URL from a string into a :class:`URL` tuple.  If the URL\n        is lacking a scheme it can be provided as second argument. Otherwise,\n        it is ignored.  Optionally fragments can be stripped from the URL\n        by setting `allow_fragments` to `False`.\n    \n        The inverse of this function is :func:`url_unparse`.\n    \n        :param url: the URL to parse.\n        :param scheme: the default schema to use if the URL is schemaless.\n        :param allow_fragments: if set to `False` a fragment will be removed\n                                from the URL.\n    \n        .. deprecated:: 2.3\n            Will be removed in Werkzeug 3.0. Use ``urllib.parse.urlsplit`` instead.\n        \"\"\"\n>       warnings.warn(\n            \"'werkzeug.urls.url_parse' is deprecated and will be removed in Werkzeug 3.0.\"\n            \" Use 'urllib.parse.urlsplit' instead.\",\n            DeprecationWarning,\n            stacklevel=2,\n        )\nE       DeprecationWarning: 'werkzeug.urls.url_parse' is deprecated and will be removed in Werkzeug 3.0. Use 'urllib.parse.urlsplit' instead.\n\n/opt/miniconda3/envs/testbed/lib/python3.9/site-packages/werkzeug/urls.py:505: DeprecationWarning\n___________________________ test_preserve_only_once ____________________________\n\napp = <Flask 'flask_test'>, client = <FlaskClient <Flask 'flask_test'>>\n\n    def test_preserve_only_once(app, client):\n        app.debug = True\n    \n        @app.route(\"/fail\")\n        def fail_func():\n            1 // 0\n    \n        for _x in range(3):\n            with pytest.raises(ZeroDivisionError):\n>               client.get(\"/fail\")\n\ntests/test_basic.py:1784: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n/opt/miniconda3/envs/testbed/lib/python3.9/site-packages/werkzeug/test.py:1243: in get\n    return self.open(*args, **kw)\nsrc/flask/testing.py:209: in open\n    builder = EnvironBuilder(self.application, *args, **kwargs)\nsrc/flask/testing.py:70: in __init__\n    url = url_parse(path)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nurl = '/fail', scheme = None, allow_fragments = True\n\n    def url_parse(\n        url: str, scheme: str | None = None, allow_fragments: bool = True\n    ) -> BaseURL:\n        \"\"\"Parses a URL from a string into a :class:`URL` tuple.  If the URL\n        is lacking a scheme it can be provided as second argument. Otherwise,\n        it is ignored.  Optionally fragments can be stripped from the URL\n        by setting `allow_fragments` to `False`.\n    \n        The inverse of this function is :func:`url_unparse`.\n    \n        :param url: the URL to parse.\n        :param scheme: the default schema to use if the URL is schemaless.\n        :param allow_fragments: if set to `False` a fragment will be removed\n                                from the URL.\n    \n        .. deprecated:: 2.3\n            Will be removed in Werkzeug 3.0. Use ``urllib.parse.urlsplit`` instead.\n        \"\"\"\n>       warnings.warn(\n            \"'werkzeug.urls.url_parse' is deprecated and will be removed in Werkzeug 3.0.\"\n            \" Use 'urllib.parse.urlsplit' instead.\",\n            DeprecationWarning,\n            stacklevel=2,\n        )\nE       DeprecationWarning: 'werkzeug.urls.url_parse' is deprecated and will be removed in Werkzeug 3.0. Use 'urllib.parse.urlsplit' instead.\n\n/opt/miniconda3/envs/testbed/lib/python3.9/site-packages/werkzeug/urls.py:505: DeprecationWarning\n______________________ test_preserve_remembers_exception _______________________\n\napp = <Flask 'flask_test'>, client = <FlaskClient <Flask 'flask_test'>>\n\n    def test_preserve_remembers_exception(app, client):\n        app.debug = True\n        errors = []\n    \n        @app.route(\"/fail\")\n        def fail_func():\n            1 // 0\n    \n        @app.route(\"/success\")\n        def success_func():\n            return \"Okay\"\n    \n        @app.teardown_request\n        def teardown_handler(exc):\n            errors.append(exc)\n    \n        # After this failure we did not yet call the teardown handler\n        with pytest.raises(ZeroDivisionError):\n>           client.get(\"/fail\")\n\ntests/test_basic.py:1812: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n/opt/miniconda3/envs/testbed/lib/python3.9/site-packages/werkzeug/test.py:1243: in get\n    return self.open(*args, **kw)\nsrc/flask/testing.py:209: in open\n    builder = EnvironBuilder(self.application, *args, **kwargs)\nsrc/flask/testing.py:70: in __init__\n    url = url_parse(path)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nurl = '/fail', scheme = None, allow_fragments = True\n\n    def url_parse(\n        url: str, scheme: str | None = None, allow_fragments: bool = True\n    ) -> BaseURL:\n        \"\"\"Parses a URL from a string into a :class:`URL` tuple.  If the URL\n        is lacking a scheme it can be provided as second argument. Otherwise,\n        it is ignored.  Optionally fragments can be stripped from the URL\n        by setting `allow_fragments` to `False`.\n    \n        The inverse of this function is :func:`url_unparse`.\n    \n        :param url: the URL to parse.\n        :param scheme: the default schema to use if the URL is schemaless.\n        :param allow_fragments: if set to `False` a fragment will be removed\n                                from the URL.\n    \n        .. deprecated:: 2.3\n            Will be removed in Werkzeug 3.0. Use ``urllib.parse.urlsplit`` instead.\n        \"\"\"\n>       warnings.warn(\n            \"'werkzeug.urls.url_parse' is deprecated and will be removed in Werkzeug 3.0.\"\n            \" Use 'urllib.parse.urlsplit' instead.\",\n            DeprecationWarning,\n            stacklevel=2,\n        )\nE       DeprecationWarning: 'werkzeug.urls.url_parse' is deprecated and will be removed in Werkzeug 3.0. Use 'urllib.parse.urlsplit' instead.\n\n/opt/miniconda3/envs/testbed/lib/python3.9/site-packages/werkzeug/urls.py:505: DeprecationWarning\n_________________________ test_subdomain_basic_support _________________________\n\n    def test_subdomain_basic_support():\n        app = flask.Flask(__name__, subdomain_matching=True)\n        app.config[\"SERVER_NAME\"] = \"localhost.localdomain\"\n        client = app.test_client()\n    \n        @app.route(\"/\")\n        def normal_index():\n            return \"normal index\"\n    \n        @app.route(\"/\", subdomain=\"test\")\n        def test_index():\n            return \"test index\"\n    \n>       rv = client.get(\"/\", \"http://localhost.localdomain/\")\n\ntests/test_basic.py:1855: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n/opt/miniconda3/envs/testbed/lib/python3.9/site-packages/werkzeug/test.py:1243: in get\n    return self.open(*args, **kw)\nsrc/flask/testing.py:216: in open\n    return super().open(  # type: ignore\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <FlaskClient <Flask 'test_basic'>>, buffered = False\nfollow_redirects = False\nargs = (<Request 'http://localhost.localdomain/' [GET]>,)\nkwargs = {'as_tuple': False}, request = None\n\n    def open(\n        self,\n        *args: t.Any,\n        buffered: bool = False,\n        follow_redirects: bool = False,\n        **kwargs: t.Any,\n    ) -> TestResponse:\n        \"\"\"Generate an environ dict from the given arguments, make a\n        request to the application using it, and return the response.\n    \n        :param args: Passed to :class:`EnvironBuilder` to create the\n            environ for the request. If a single arg is passed, it can\n            be an existing :class:`EnvironBuilder` or an environ dict.\n        :param buffered: Convert the iterator returned by the app into\n            a list. If the iterator has a ``close()`` method, it is\n            called automatically.\n        :param follow_redirects: Make additional requests to follow HTTP\n            redirects until a non-redirect status is returned.\n            :attr:`TestResponse.history` lists the intermediate\n            responses.\n    \n        .. versionchanged:: 2.1\n            Removed the ``as_tuple`` parameter.\n    \n        .. versionchanged:: 2.0\n            The request input stream is closed when calling\n            ``response.close()``. Input streams for redirects are\n            automatically closed.\n    \n        .. versionchanged:: 0.5\n            If a dict is provided as file in the dict for the ``data``\n            parameter the content type has to be called ``content_type``\n            instead of ``mimetype``. This change was made for\n            consistency with :class:`werkzeug.FileWrapper`.\n    \n        .. versionchanged:: 0.5\n            Added the ``follow_redirects`` parameter.\n        \"\"\"\n        request: Request | None = None\n    \n        if not kwargs and len(args) == 1:\n            arg = args[0]\n    \n            if isinstance(arg, EnvironBuilder):\n                request = arg.get_request()\n            elif isinstance(arg, dict):\n                request = EnvironBuilder.from_environ(arg).get_request()\n            elif isinstance(arg, Request):\n                request = arg\n    \n        if request is None:\n>           builder = EnvironBuilder(*args, **kwargs)\nE           TypeError: __init__() got an unexpected keyword argument 'as_tuple'\n\n/opt/miniconda3/envs/testbed/lib/python3.9/site-packages/werkzeug/test.py:1190: TypeError\n___________________________ test_subdomain_matching ____________________________\n\n    def test_subdomain_matching():\n        app = flask.Flask(__name__, subdomain_matching=True)\n        client = app.test_client()\n        app.config[\"SERVER_NAME\"] = \"localhost.localdomain\"\n    \n        @app.route(\"/\", subdomain=\"<user>\")\n        def index(user):\n            return f\"index for {user}\"\n    \n>       rv = client.get(\"/\", \"http://mitsuhiko.localhost.localdomain/\")\n\ntests/test_basic.py:1871: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n/opt/miniconda3/envs/testbed/lib/python3.9/site-packages/werkzeug/test.py:1243: in get\n    return self.open(*args, **kw)\nsrc/flask/testing.py:216: in open\n    return super().open(  # type: ignore\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <FlaskClient <Flask 'test_basic'>>, buffered = False\nfollow_redirects = False\nargs = (<Request 'http://mitsuhiko.localhost.localdomain/' [GET]>,)\nkwargs = {'as_tuple': False}, request = None\n\n    def open(\n        self,\n        *args: t.Any,\n        buffered: bool = False,\n        follow_redirects: bool = False,\n        **kwargs: t.Any,\n    ) -> TestResponse:\n        \"\"\"Generate an environ dict from the given arguments, make a\n        request to the application using it, and return the response.\n    \n        :param args: Passed to :class:`EnvironBuilder` to create the\n            environ for the request. If a single arg is passed, it can\n            be an existing :class:`EnvironBuilder` or an environ dict.\n        :param buffered: Convert the iterator returned by the app into\n            a list. If the iterator has a ``close()`` method, it is\n            called automatically.\n        :param follow_redirects: Make additional requests to follow HTTP\n            redirects until a non-redirect status is returned.\n            :attr:`TestResponse.history` lists the intermediate\n            responses.\n    \n        .. versionchanged:: 2.1\n            Removed the ``as_tuple`` parameter.\n    \n        .. versionchanged:: 2.0\n            The request input stream is closed when calling\n            ``response.close()``. Input streams for redirects are\n            automatically closed.\n    \n        .. versionchanged:: 0.5\n            If a dict is provided as file in the dict for the ``data``\n            parameter the content type has to be called ``content_type``\n            instead of ``mimetype``. This change was made for\n            consistency with :class:`werkzeug.FileWrapper`.\n    \n        .. versionchanged:: 0.5\n            Added the ``follow_redirects`` parameter.\n        \"\"\"\n        request: Request | None = None\n    \n        if not kwargs and len(args) == 1:\n            arg = args[0]\n    \n            if isinstance(arg, EnvironBuilder):\n                request = arg.get_request()\n            elif isinstance(arg, dict):\n                request = EnvironBuilder.from_environ(arg).get_request()\n            elif isinstance(arg, Request):\n                request = arg\n    \n        if request is None:\n>           builder = EnvironBuilder(*args, **kwargs)\nE           TypeError: __init__() got an unexpected keyword argument 'as_tuple'\n\n/opt/miniconda3/envs/testbed/lib/python3.9/site-packages/werkzeug/test.py:1190: TypeError\n______________________ test_subdomain_matching_with_ports ______________________\n\n    def test_subdomain_matching_with_ports():\n        app = flask.Flask(__name__, subdomain_matching=True)\n        app.config[\"SERVER_NAME\"] = \"localhost.localdomain:3000\"\n        client = app.test_client()\n    \n        @app.route(\"/\", subdomain=\"<user>\")\n        def index(user):\n            return f\"index for {user}\"\n    \n>       rv = client.get(\"/\", \"http://mitsuhiko.localhost.localdomain:3000/\")\n\ntests/test_basic.py:1884: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n/opt/miniconda3/envs/testbed/lib/python3.9/site-packages/werkzeug/test.py:1243: in get\n    return self.open(*args, **kw)\nsrc/flask/testing.py:216: in open\n    return super().open(  # type: ignore\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <FlaskClient <Flask 'test_basic'>>, buffered = False\nfollow_redirects = False\nargs = (<Request 'http://mitsuhiko.localhost.localdomain:3000/' [GET]>,)\nkwargs = {'as_tuple': False}, request = None\n\n    def open(\n        self,\n        *args: t.Any,\n        buffered: bool = False,\n        follow_redirects: bool = False,\n        **kwargs: t.Any,\n    ) -> TestResponse:\n        \"\"\"Generate an environ dict from the given arguments, make a\n        request to the application using it, and return the response.\n    \n        :param args: Passed to :class:`EnvironBuilder` to create the\n            environ for the request. If a single arg is passed, it can\n            be an existing :class:`EnvironBuilder` or an environ dict.\n        :param buffered: Convert the iterator returned by the app into\n            a list. If the iterator has a ``close()`` method, it is\n            called automatically.\n        :param follow_redirects: Make additional requests to follow HTTP\n            redirects until a non-redirect status is returned.\n            :attr:`TestResponse.history` lists the intermediate\n            responses.\n    \n        .. versionchanged:: 2.1\n            Removed the ``as_tuple`` parameter.\n    \n        .. versionchanged:: 2.0\n            The request input stream is closed when calling\n            ``response.close()``. Input streams for redirects are\n            automatically closed.\n    \n        .. versionchanged:: 0.5\n            If a dict is provided as file in the dict for the ``data``\n            parameter the content type has to be called ``content_type``\n            instead of ``mimetype``. This change was made for\n            consistency with :class:`werkzeug.FileWrapper`.\n    \n        .. versionchanged:: 0.5\n            Added the ``follow_redirects`` parameter.\n        \"\"\"\n        request: Request | None = None\n    \n        if not kwargs and len(args) == 1:\n            arg = args[0]\n    \n            if isinstance(arg, EnvironBuilder):\n                request = arg.get_request()\n            elif isinstance(arg, dict):\n                request = EnvironBuilder.from_environ(arg).get_request()\n            elif isinstance(arg, Request):\n                request = arg\n    \n        if request is None:\n>           builder = EnvironBuilder(*args, **kwargs)\nE           TypeError: __init__() got an unexpected keyword argument 'as_tuple'\n\n/opt/miniconda3/envs/testbed/lib/python3.9/site-packages/werkzeug/test.py:1190: TypeError\n__________________ test_subdomain_matching_other_name[False] ___________________\n\nmatching = False\n\n    @pytest.mark.parametrize(\"matching\", (False, True))\n    def test_subdomain_matching_other_name(matching):\n        app = flask.Flask(__name__, subdomain_matching=matching)\n        app.config[\"SERVER_NAME\"] = \"localhost.localdomain:3000\"\n        client = app.test_client()\n    \n        @app.route(\"/\")\n        def index():\n            return \"\", 204\n    \n        # suppress Werkzeug 0.15 warning about name mismatch\n        with pytest.warns(None):\n            # ip address can't match name\n>           rv = client.get(\"/\", \"http://127.0.0.1:3000/\")\n\ntests/test_basic.py:1901: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n/opt/miniconda3/envs/testbed/lib/python3.9/site-packages/werkzeug/test.py:1243: in get\n    return self.open(*args, **kw)\nsrc/flask/testing.py:216: in open\n    return super().open(  # type: ignore\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <FlaskClient <Flask 'test_basic'>>, buffered = False\nfollow_redirects = False, args = (<Request 'http://127.0.0.1:3000/' [GET]>,)\nkwargs = {'as_tuple': False}, request = None\n\n    def open(\n        self,\n        *args: t.Any,\n        buffered: bool = False,\n        follow_redirects: bool = False,\n        **kwargs: t.Any,\n    ) -> TestResponse:\n        \"\"\"Generate an environ dict from the given arguments, make a\n        request to the application using it, and return the response.\n    \n        :param args: Passed to :class:`EnvironBuilder` to create the\n            environ for the request. If a single arg is passed, it can\n            be an existing :class:`EnvironBuilder` or an environ dict.\n        :param buffered: Convert the iterator returned by the app into\n            a list. If the iterator has a ``close()`` method, it is\n            called automatically.\n        :param follow_redirects: Make additional requests to follow HTTP\n            redirects until a non-redirect status is returned.\n            :attr:`TestResponse.history` lists the intermediate\n            responses.\n    \n        .. versionchanged:: 2.1\n            Removed the ``as_tuple`` parameter.\n    \n        .. versionchanged:: 2.0\n            The request input stream is closed when calling\n            ``response.close()``. Input streams for redirects are\n            automatically closed.\n    \n        .. versionchanged:: 0.5\n            If a dict is provided as file in the dict for the ``data``\n            parameter the content type has to be called ``content_type``\n            instead of ``mimetype``. This change was made for\n            consistency with :class:`werkzeug.FileWrapper`.\n    \n        .. versionchanged:: 0.5\n            Added the ``follow_redirects`` parameter.\n        \"\"\"\n        request: Request | None = None\n    \n        if not kwargs and len(args) == 1:\n            arg = args[0]\n    \n            if isinstance(arg, EnvironBuilder):\n                request = arg.get_request()\n            elif isinstance(arg, dict):\n                request = EnvironBuilder.from_environ(arg).get_request()\n            elif isinstance(arg, Request):\n                request = arg\n    \n        if request is None:\n>           builder = EnvironBuilder(*args, **kwargs)\nE           TypeError: __init__() got an unexpected keyword argument 'as_tuple'\n\n/opt/miniconda3/envs/testbed/lib/python3.9/site-packages/werkzeug/test.py:1190: TypeError\n___________________ test_subdomain_matching_other_name[True] ___________________\n\nmatching = True\n\n    @pytest.mark.parametrize(\"matching\", (False, True))\n    def test_subdomain_matching_other_name(matching):\n        app = flask.Flask(__name__, subdomain_matching=matching)\n        app.config[\"SERVER_NAME\"] = \"localhost.localdomain:3000\"\n        client = app.test_client()\n    \n        @app.route(\"/\")\n        def index():\n            return \"\", 204\n    \n        # suppress Werkzeug 0.15 warning about name mismatch\n        with pytest.warns(None):\n            # ip address can't match name\n>           rv = client.get(\"/\", \"http://127.0.0.1:3000/\")\n\ntests/test_basic.py:1901: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n/opt/miniconda3/envs/testbed/lib/python3.9/site-packages/werkzeug/test.py:1243: in get\n    return self.open(*args, **kw)\nsrc/flask/testing.py:216: in open\n    return super().open(  # type: ignore\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <FlaskClient <Flask 'test_basic'>>, buffered = False\nfollow_redirects = False, args = (<Request 'http://127.0.0.1:3000/' [GET]>,)\nkwargs = {'as_tuple': False}, request = None\n\n    def open(\n        self,\n        *args: t.Any,\n        buffered: bool = False,\n        follow_redirects: bool = False,\n        **kwargs: t.Any,\n    ) -> TestResponse:\n        \"\"\"Generate an environ dict from the given arguments, make a\n        request to the application using it, and return the response.\n    \n        :param args: Passed to :class:`EnvironBuilder` to create the\n            environ for the request. If a single arg is passed, it can\n            be an existing :class:`EnvironBuilder` or an environ dict.\n        :param buffered: Convert the iterator returned by the app into\n            a list. If the iterator has a ``close()`` method, it is\n            called automatically.\n        :param follow_redirects: Make additional requests to follow HTTP\n            redirects until a non-redirect status is returned.\n            :attr:`TestResponse.history` lists the intermediate\n            responses.\n    \n        .. versionchanged:: 2.1\n            Removed the ``as_tuple`` parameter.\n    \n        .. versionchanged:: 2.0\n            The request input stream is closed when calling\n            ``response.close()``. Input streams for redirects are\n            automatically closed.\n    \n        .. versionchanged:: 0.5\n            If a dict is provided as file in the dict for the ``data``\n            parameter the content type has to be called ``content_type``\n            instead of ``mimetype``. This change was made for\n            consistency with :class:`werkzeug.FileWrapper`.\n    \n        .. versionchanged:: 0.5\n            Added the ``follow_redirects`` parameter.\n        \"\"\"\n        request: Request | None = None\n    \n        if not kwargs and len(args) == 1:\n            arg = args[0]\n    \n            if isinstance(arg, EnvironBuilder):\n                request = arg.get_request()\n            elif isinstance(arg, dict):\n                request = EnvironBuilder.from_environ(arg).get_request()\n            elif isinstance(arg, Request):\n                request = arg\n    \n        if request is None:\n>           builder = EnvironBuilder(*args, **kwargs)\nE           TypeError: __init__() got an unexpected keyword argument 'as_tuple'\n\n/opt/miniconda3/envs/testbed/lib/python3.9/site-packages/werkzeug/test.py:1190: TypeError\n____________________________ test_multi_route_rules ____________________________\n\napp = <Flask 'flask_test'>, client = <FlaskClient <Flask 'flask_test'>>\n\n    def test_multi_route_rules(app, client):\n        @app.route(\"/\")\n        @app.route(\"/<test>/\")\n        def index(test=\"a\"):\n            return test\n    \n>       rv = client.open(\"/\")\n\ntests/test_basic.py:1915: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \nsrc/flask/testing.py:209: in open\n    builder = EnvironBuilder(self.application, *args, **kwargs)\nsrc/flask/testing.py:70: in __init__\n    url = url_parse(path)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nurl = '/', scheme = None, allow_fragments = True\n\n    def url_parse(\n        url: str, scheme: str | None = None, allow_fragments: bool = True\n    ) -> BaseURL:\n        \"\"\"Parses a URL from a string into a :class:`URL` tuple.  If the URL\n        is lacking a scheme it can be provided as second argument. Otherwise,\n        it is ignored.  Optionally fragments can be stripped from the URL\n        by setting `allow_fragments` to `False`.\n    \n        The inverse of this function is :func:`url_unparse`.\n    \n        :param url: the URL to parse.\n        :param scheme: the default schema to use if the URL is schemaless.\n        :param allow_fragments: if set to `False` a fragment will be removed\n                                from the URL.\n    \n        .. deprecated:: 2.3\n            Will be removed in Werkzeug 3.0. Use ``urllib.parse.urlsplit`` instead.\n        \"\"\"\n>       warnings.warn(\n            \"'werkzeug.urls.url_parse' is deprecated and will be removed in Werkzeug 3.0.\"\n            \" Use 'urllib.parse.urlsplit' instead.\",\n            DeprecationWarning,\n            stacklevel=2,\n        )\nE       DeprecationWarning: 'werkzeug.urls.url_parse' is deprecated and will be removed in Werkzeug 3.0. Use 'urllib.parse.urlsplit' instead.\n\n/opt/miniconda3/envs/testbed/lib/python3.9/site-packages/werkzeug/urls.py:505: DeprecationWarning\n_________________________ test_multi_route_class_views _________________________\n\napp = <Flask 'flask_test'>, client = <FlaskClient <Flask 'flask_test'>>\n\n    def test_multi_route_class_views(app, client):\n        class View:\n            def __init__(self, app):\n                app.add_url_rule(\"/\", \"index\", self.index)\n                app.add_url_rule(\"/<test>/\", \"index\", self.index)\n    \n            def index(self, test=\"a\"):\n                return test\n    \n        _ = View(app)\n>       rv = client.open(\"/\")\n\ntests/test_basic.py:1931: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \nsrc/flask/testing.py:209: in open\n    builder = EnvironBuilder(self.application, *args, **kwargs)\nsrc/flask/testing.py:70: in __init__\n    url = url_parse(path)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nurl = '/', scheme = None, allow_fragments = True\n\n    def url_parse(\n        url: str, scheme: str | None = None, allow_fragments: bool = True\n    ) -> BaseURL:\n        \"\"\"Parses a URL from a string into a :class:`URL` tuple.  If the URL\n        is lacking a scheme it can be provided as second argument. Otherwise,\n        it is ignored.  Optionally fragments can be stripped from the URL\n        by setting `allow_fragments` to `False`.\n    \n        The inverse of this function is :func:`url_unparse`.\n    \n        :param url: the URL to parse.\n        :param scheme: the default schema to use if the URL is schemaless.\n        :param allow_fragments: if set to `False` a fragment will be removed\n                                from the URL.\n    \n        .. deprecated:: 2.3\n            Will be removed in Werkzeug 3.0. Use ``urllib.parse.urlsplit`` instead.\n        \"\"\"\n>       warnings.warn(\n            \"'werkzeug.urls.url_parse' is deprecated and will be removed in Werkzeug 3.0.\"\n            \" Use 'urllib.parse.urlsplit' instead.\",\n            DeprecationWarning,\n            stacklevel=2,\n        )\nE       DeprecationWarning: 'werkzeug.urls.url_parse' is deprecated and will be removed in Werkzeug 3.0. Use 'urllib.parse.urlsplit' instead.\n\n/opt/miniconda3/envs/testbed/lib/python3.9/site-packages/werkzeug/urls.py:505: DeprecationWarning\n_____________________________ test_max_cookie_size _____________________________\n\napp = <Flask 'flask_test'>, client = <FlaskClient <Flask 'flask_test'>>\nrecwarn = WarningsRecorder(record=True)\n\n    def test_max_cookie_size(app, client, recwarn):\n        app.config[\"MAX_COOKIE_SIZE\"] = 100\n    \n        # outside app context, default to Werkzeug static value,\n        # which is also the default config\n        response = flask.Response()\n        default = flask.Flask.default_config[\"MAX_COOKIE_SIZE\"]\n        assert response.max_cookie_size == default\n    \n        # inside app context, use app config\n        with app.app_context():\n            assert flask.Response().max_cookie_size == 100\n    \n        @app.route(\"/\")\n        def index():\n            r = flask.Response(\"\", status=204)\n            r.set_cookie(\"foo\", \"bar\" * 100)\n            return r\n    \n>       client.get(\"/\")\n\ntests/test_basic.py:2005: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n/opt/miniconda3/envs/testbed/lib/python3.9/site-packages/werkzeug/test.py:1243: in get\n    return self.open(*args, **kw)\nsrc/flask/testing.py:216: in open\n    return super().open(  # type: ignore\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <FlaskClient <Flask 'flask_test'>>, buffered = False\nfollow_redirects = False, args = (<Request 'http://localhost/' [GET]>,)\nkwargs = {'as_tuple': False}, request = None\n\n    def open(\n        self,\n        *args: t.Any,\n        buffered: bool = False,\n        follow_redirects: bool = False,\n        **kwargs: t.Any,\n    ) -> TestResponse:\n        \"\"\"Generate an environ dict from the given arguments, make a\n        request to the application using it, and return the response.\n    \n        :param args: Passed to :class:`EnvironBuilder` to create the\n            environ for the request. If a single arg is passed, it can\n            be an existing :class:`EnvironBuilder` or an environ dict.\n        :param buffered: Convert the iterator returned by the app into\n            a list. If the iterator has a ``close()`` method, it is\n            called automatically.\n        :param follow_redirects: Make additional requests to follow HTTP\n            redirects until a non-redirect status is returned.\n            :attr:`TestResponse.history` lists the intermediate\n            responses.\n    \n        .. versionchanged:: 2.1\n            Removed the ``as_tuple`` parameter.\n    \n        .. versionchanged:: 2.0\n            The request input stream is closed when calling\n            ``response.close()``. Input streams for redirects are\n            automatically closed.\n    \n        .. versionchanged:: 0.5\n            If a dict is provided as file in the dict for the ``data``\n            parameter the content type has to be called ``content_type``\n            instead of ``mimetype``. This change was made for\n            consistency with :class:`werkzeug.FileWrapper`.\n    \n        .. versionchanged:: 0.5\n            Added the ``follow_redirects`` parameter.\n        \"\"\"\n        request: Request | None = None\n    \n        if not kwargs and len(args) == 1:\n            arg = args[0]\n    \n            if isinstance(arg, EnvironBuilder):\n                request = arg.get_request()\n            elif isinstance(arg, dict):\n                request = EnvironBuilder.from_environ(arg).get_request()\n            elif isinstance(arg, Request):\n                request = arg\n    \n        if request is None:\n>           builder = EnvironBuilder(*args, **kwargs)\nE           TypeError: __init__() got an unexpected keyword argument 'as_tuple'\n\n/opt/miniconda3/envs/testbed/lib/python3.9/site-packages/werkzeug/test.py:1190: TypeError\n____________________ test_blueprint_specific_error_handling ____________________\n\napp = <Flask 'flask_test'>, client = <FlaskClient <Flask 'flask_test'>>\n\n    def test_blueprint_specific_error_handling(app, client):\n        frontend = flask.Blueprint(\"frontend\", __name__)\n        backend = flask.Blueprint(\"backend\", __name__)\n        sideend = flask.Blueprint(\"sideend\", __name__)\n    \n        @frontend.errorhandler(403)\n        def frontend_forbidden(e):\n            return \"frontend says no\", 403\n    \n        @frontend.route(\"/frontend-no\")\n        def frontend_no():\n            flask.abort(403)\n    \n        @backend.errorhandler(403)\n        def backend_forbidden(e):\n            return \"backend says no\", 403\n    \n        @backend.route(\"/backend-no\")\n        def backend_no():\n            flask.abort(403)\n    \n        @sideend.route(\"/what-is-a-sideend\")\n        def sideend_no():\n            flask.abort(403)\n    \n        app.register_blueprint(frontend)\n        app.register_blueprint(backend)\n        app.register_blueprint(sideend)\n    \n        @app.errorhandler(403)\n        def app_forbidden(e):\n            return \"application itself says no\", 403\n    \n>       assert client.get(\"/frontend-no\").data == b\"frontend says no\"\n\ntests/test_blueprints.py:41: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n/opt/miniconda3/envs/testbed/lib/python3.9/site-packages/werkzeug/test.py:1243: in get\n    return self.open(*args, **kw)\nsrc/flask/testing.py:209: in open\n    builder = EnvironBuilder(self.application, *args, **kwargs)\nsrc/flask/testing.py:70: in __init__\n    url = url_parse(path)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nurl = '/frontend-no', scheme = None, allow_fragments = True\n\n    def url_parse(\n        url: str, scheme: str | None = None, allow_fragments: bool = True\n    ) -> BaseURL:\n        \"\"\"Parses a URL from a string into a :class:`URL` tuple.  If the URL\n        is lacking a scheme it can be provided as second argument. Otherwise,\n        it is ignored.  Optionally fragments can be stripped from the URL\n        by setting `allow_fragments` to `False`.\n    \n        The inverse of this function is :func:`url_unparse`.\n    \n        :param url: the URL to parse.\n        :param scheme: the default schema to use if the URL is schemaless.\n        :param allow_fragments: if set to `False` a fragment will be removed\n                                from the URL.\n    \n        .. deprecated:: 2.3\n            Will be removed in Werkzeug 3.0. Use ``urllib.parse.urlsplit`` instead.\n        \"\"\"\n>       warnings.warn(\n            \"'werkzeug.urls.url_parse' is deprecated and will be removed in Werkzeug 3.0.\"\n            \" Use 'urllib.parse.urlsplit' instead.\",\n            DeprecationWarning,\n            stacklevel=2,\n        )\nE       DeprecationWarning: 'werkzeug.urls.url_parse' is deprecated and will be removed in Werkzeug 3.0. Use 'urllib.parse.urlsplit' instead.\n\n/opt/miniconda3/envs/testbed/lib/python3.9/site-packages/werkzeug/urls.py:505: DeprecationWarning\n_________________ test_blueprint_specific_user_error_handling __________________\n\napp = <Flask 'flask_test'>, client = <FlaskClient <Flask 'flask_test'>>\n\n    def test_blueprint_specific_user_error_handling(app, client):\n        class MyDecoratorException(Exception):\n            pass\n    \n        class MyFunctionException(Exception):\n            pass\n    \n        blue = flask.Blueprint(\"blue\", __name__)\n    \n        @blue.errorhandler(MyDecoratorException)\n        def my_decorator_exception_handler(e):\n            assert isinstance(e, MyDecoratorException)\n            return \"boom\"\n    \n        def my_function_exception_handler(e):\n            assert isinstance(e, MyFunctionException)\n            return \"bam\"\n    \n        blue.register_error_handler(MyFunctionException, my_function_exception_handler)\n    \n        @blue.route(\"/decorator\")\n        def blue_deco_test():\n            raise MyDecoratorException()\n    \n        @blue.route(\"/function\")\n        def blue_func_test():\n            raise MyFunctionException()\n    \n        app.register_blueprint(blue)\n    \n>       assert client.get(\"/decorator\").data == b\"boom\"\n\ntests/test_blueprints.py:76: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n/opt/miniconda3/envs/testbed/lib/python3.9/site-packages/werkzeug/test.py:1243: in get\n    return self.open(*args, **kw)\nsrc/flask/testing.py:209: in open\n    builder = EnvironBuilder(self.application, *args, **kwargs)\nsrc/flask/testing.py:70: in __init__\n    url = url_parse(path)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nurl = '/decorator', scheme = None, allow_fragments = True\n\n    def url_parse(\n        url: str, scheme: str | None = None, allow_fragments: bool = True\n    ) -> BaseURL:\n        \"\"\"Parses a URL from a string into a :class:`URL` tuple.  If the URL\n        is lacking a scheme it can be provided as second argument. Otherwise,\n        it is ignored.  Optionally fragments can be stripped from the URL\n        by setting `allow_fragments` to `False`.\n    \n        The inverse of this function is :func:`url_unparse`.\n    \n        :param url: the URL to parse.\n        :param scheme: the default schema to use if the URL is schemaless.\n        :param allow_fragments: if set to `False` a fragment will be removed\n                                from the URL.\n    \n        .. deprecated:: 2.3\n            Will be removed in Werkzeug 3.0. Use ``urllib.parse.urlsplit`` instead.\n        \"\"\"\n>       warnings.warn(\n            \"'werkzeug.urls.url_parse' is deprecated and will be removed in Werkzeug 3.0.\"\n            \" Use 'urllib.parse.urlsplit' instead.\",\n            DeprecationWarning,\n            stacklevel=2,\n        )\nE       DeprecationWarning: 'werkzeug.urls.url_parse' is deprecated and will be removed in Werkzeug 3.0. Use 'urllib.parse.urlsplit' instead.\n\n/opt/miniconda3/envs/testbed/lib/python3.9/site-packages/werkzeug/urls.py:505: DeprecationWarning\n______________________ test_blueprint_app_error_handling _______________________\n\napp = <Flask 'flask_test'>, client = <FlaskClient <Flask 'flask_test'>>\n\n    def test_blueprint_app_error_handling(app, client):\n        errors = flask.Blueprint(\"errors\", __name__)\n    \n        @errors.app_errorhandler(403)\n        def forbidden_handler(e):\n            return \"you shall not pass\", 403\n    \n        @app.route(\"/forbidden\")\n        def app_forbidden():\n            flask.abort(403)\n    \n        forbidden_bp = flask.Blueprint(\"forbidden_bp\", __name__)\n    \n        @forbidden_bp.route(\"/nope\")\n        def bp_forbidden():\n            flask.abort(403)\n    \n        app.register_blueprint(errors)\n        app.register_blueprint(forbidden_bp)\n    \n>       assert client.get(\"/forbidden\").data == b\"you shall not pass\"\n\ntests/test_blueprints.py:100: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n/opt/miniconda3/envs/testbed/lib/python3.9/site-packages/werkzeug/test.py:1243: in get\n    return self.open(*args, **kw)\nsrc/flask/testing.py:209: in open\n    builder = EnvironBuilder(self.application, *args, **kwargs)\nsrc/flask/testing.py:70: in __init__\n    url = url_parse(path)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nurl = '/forbidden', scheme = None, allow_fragments = True\n\n    def url_parse(\n        url: str, scheme: str | None = None, allow_fragments: bool = True\n    ) -> BaseURL:\n        \"\"\"Parses a URL from a string into a :class:`URL` tuple.  If the URL\n        is lacking a scheme it can be provided as second argument. Otherwise,\n        it is ignored.  Optionally fragments can be stripped from the URL\n        by setting `allow_fragments` to `False`.\n    \n        The inverse of this function is :func:`url_unparse`.\n    \n        :param url: the URL to parse.\n        :param scheme: the default schema to use if the URL is schemaless.\n        :param allow_fragments: if set to `False` a fragment will be removed\n                                from the URL.\n    \n        .. deprecated:: 2.3\n            Will be removed in Werkzeug 3.0. Use ``urllib.parse.urlsplit`` instead.\n        \"\"\"\n>       warnings.warn(\n            \"'werkzeug.urls.url_parse' is deprecated and will be removed in Werkzeug 3.0.\"\n            \" Use 'urllib.parse.urlsplit' instead.\",\n            DeprecationWarning,\n            stacklevel=2,\n        )\nE       DeprecationWarning: 'werkzeug.urls.url_parse' is deprecated and will be removed in Werkzeug 3.0. Use 'urllib.parse.urlsplit' instead.\n\n/opt/miniconda3/envs/testbed/lib/python3.9/site-packages/werkzeug/urls.py:505: DeprecationWarning\n______________________ test_blueprint_prefix_slash[-/-/] _______________________\n\napp = <Flask 'flask_test'>, client = <FlaskClient <Flask 'flask_test'>>\nprefix = '', rule = '/', url = '/'\n\n    @pytest.mark.parametrize(\n        (\"prefix\", \"rule\", \"url\"),\n        (\n            (\"\", \"/\", \"/\"),\n            (\"/\", \"\", \"/\"),\n            (\"/\", \"/\", \"/\"),\n            (\"/foo\", \"\", \"/foo\"),\n            (\"/foo/\", \"\", \"/foo/\"),\n            (\"\", \"/bar\", \"/bar\"),\n            (\"/foo/\", \"/bar\", \"/foo/bar\"),\n            (\"/foo/\", \"bar\", \"/foo/bar\"),\n            (\"/foo\", \"/bar\", \"/foo/bar\"),\n            (\"/foo/\", \"//bar\", \"/foo/bar\"),\n            (\"/foo//\", \"/bar\", \"/foo/bar\"),\n        ),\n    )\n    def test_blueprint_prefix_slash(app, client, prefix, rule, url):\n        bp = flask.Blueprint(\"test\", __name__, url_prefix=prefix)\n    \n        @bp.route(rule)\n        def index():\n            return \"\", 204\n    \n        app.register_blueprint(bp)\n>       assert client.get(url).status_code == 204\n\ntests/test_blueprints.py:128: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n/opt/miniconda3/envs/testbed/lib/python3.9/site-packages/werkzeug/test.py:1243: in get\n    return self.open(*args, **kw)\nsrc/flask/testing.py:209: in open\n    builder = EnvironBuilder(self.application, *args, **kwargs)\nsrc/flask/testing.py:70: in __init__\n    url = url_parse(path)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nurl = '/', scheme = None, allow_fragments = True\n\n    def url_parse(\n        url: str, scheme: str | None = None, allow_fragments: bool = True\n    ) -> BaseURL:\n        \"\"\"Parses a URL from a string into a :class:`URL` tuple.  If the URL\n        is lacking a scheme it can be provided as second argument. Otherwise,\n        it is ignored.  Optionally fragments can be stripped from the URL\n        by setting `allow_fragments` to `False`.\n    \n        The inverse of this function is :func:`url_unparse`.\n    \n        :param url: the URL to parse.\n        :param scheme: the default schema to use if the URL is schemaless.\n        :param allow_fragments: if set to `False` a fragment will be removed\n                                from the URL.\n    \n        .. deprecated:: 2.3\n            Will be removed in Werkzeug 3.0. Use ``urllib.parse.urlsplit`` instead.\n        \"\"\"\n>       warnings.warn(\n            \"'werkzeug.urls.url_parse' is deprecated and will be removed in Werkzeug 3.0.\"\n            \" Use 'urllib.parse.urlsplit' instead.\",\n            DeprecationWarning,\n            stacklevel=2,\n        )\nE       DeprecationWarning: 'werkzeug.urls.url_parse' is deprecated and will be removed in Werkzeug 3.0. Use 'urllib.parse.urlsplit' instead.\n\n/opt/miniconda3/envs/testbed/lib/python3.9/site-packages/werkzeug/urls.py:505: DeprecationWarning\n______________________ test_blueprint_prefix_slash[/--/] _______________________\n\napp = <Flask 'flask_test'>, client = <FlaskClient <Flask 'flask_test'>>\nprefix = '/', rule = '', url = '/'\n\n    @pytest.mark.parametrize(\n        (\"prefix\", \"rule\", \"url\"),\n        (\n            (\"\", \"/\", \"/\"),\n            (\"/\", \"\", \"/\"),\n            (\"/\", \"/\", \"/\"),\n            (\"/foo\", \"\", \"/foo\"),\n            (\"/foo/\", \"\", \"/foo/\"),\n            (\"\", \"/bar\", \"/bar\"),\n            (\"/foo/\", \"/bar\", \"/foo/bar\"),\n            (\"/foo/\", \"bar\", \"/foo/bar\"),\n            (\"/foo\", \"/bar\", \"/foo/bar\"),\n            (\"/foo/\", \"//bar\", \"/foo/bar\"),\n            (\"/foo//\", \"/bar\", \"/foo/bar\"),\n        ),\n    )\n    def test_blueprint_prefix_slash(app, client, prefix, rule, url):\n        bp = flask.Blueprint(\"test\", __name__, url_prefix=prefix)\n    \n        @bp.route(rule)\n        def index():\n            return \"\", 204\n    \n        app.register_blueprint(bp)\n>       assert client.get(url).status_code == 204\n\ntests/test_blueprints.py:128: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n/opt/miniconda3/envs/testbed/lib/python3.9/site-packages/werkzeug/test.py:1243: in get\n    return self.open(*args, **kw)\nsrc/flask/testing.py:209: in open\n    builder = EnvironBuilder(self.application, *args, **kwargs)\nsrc/flask/testing.py:70: in __init__\n    url = url_parse(path)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nurl = '/', scheme = None, allow_fragments = True\n\n    def url_parse(\n        url: str, scheme: str | None = None, allow_fragments: bool = True\n    ) -> BaseURL:\n        \"\"\"Parses a URL from a string into a :class:`URL` tuple.  If the URL\n        is lacking a scheme it can be provided as second argument. Otherwise,\n        it is ignored.  Optionally fragments can be stripped from the URL\n        by setting `allow_fragments` to `False`.\n    \n        The inverse of this function is :func:`url_unparse`.\n    \n        :param url: the URL to parse.\n        :param scheme: the default schema to use if the URL is schemaless.\n        :param allow_fragments: if set to `False` a fragment will be removed\n                                from the URL.\n    \n        .. deprecated:: 2.3\n            Will be removed in Werkzeug 3.0. Use ``urllib.parse.urlsplit`` instead.\n        \"\"\"\n>       warnings.warn(\n            \"'werkzeug.urls.url_parse' is deprecated and will be removed in Werkzeug 3.0.\"\n            \" Use 'urllib.parse.urlsplit' instead.\",\n            DeprecationWarning,\n            stacklevel=2,\n        )\nE       DeprecationWarning: 'werkzeug.urls.url_parse' is deprecated and will be removed in Werkzeug 3.0. Use 'urllib.parse.urlsplit' instead.\n\n/opt/miniconda3/envs/testbed/lib/python3.9/site-packages/werkzeug/urls.py:505: DeprecationWarning\n______________________ test_blueprint_prefix_slash[/-/-/] ______________________\n\napp = <Flask 'flask_test'>, client = <FlaskClient <Flask 'flask_test'>>\nprefix = '/', rule = '/', url = '/'\n\n    @pytest.mark.parametrize(\n        (\"prefix\", \"rule\", \"url\"),\n        (\n            (\"\", \"/\", \"/\"),\n            (\"/\", \"\", \"/\"),\n            (\"/\", \"/\", \"/\"),\n            (\"/foo\", \"\", \"/foo\"),\n            (\"/foo/\", \"\", \"/foo/\"),\n            (\"\", \"/bar\", \"/bar\"),\n            (\"/foo/\", \"/bar\", \"/foo/bar\"),\n            (\"/foo/\", \"bar\", \"/foo/bar\"),\n            (\"/foo\", \"/bar\", \"/foo/bar\"),\n            (\"/foo/\", \"//bar\", \"/foo/bar\"),\n            (\"/foo//\", \"/bar\", \"/foo/bar\"),\n        ),\n    )\n    def test_blueprint_prefix_slash(app, client, prefix, rule, url):\n        bp = flask.Blueprint(\"test\", __name__, url_prefix=prefix)\n    \n        @bp.route(rule)\n        def index():\n            return \"\", 204\n    \n        app.register_blueprint(bp)\n>       assert client.get(url).status_code == 204\n\ntests/test_blueprints.py:128: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n/opt/miniconda3/envs/testbed/lib/python3.9/site-packages/werkzeug/test.py:1243: in get\n    return self.open(*args, **kw)\nsrc/flask/testing.py:209: in open\n    builder = EnvironBuilder(self.application, *args, **kwargs)\nsrc/flask/testing.py:70: in __init__\n    url = url_parse(path)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nurl = '/', scheme = None, allow_fragments = True\n\n    def url_parse(\n        url: str, scheme: str | None = None, allow_fragments: bool = True\n    ) -> BaseURL:\n        \"\"\"Parses a URL from a string into a :class:`URL` tuple.  If the URL\n        is lacking a scheme it can be provided as second argument. Otherwise,\n        it is ignored.  Optionally fragments can be stripped from the URL\n        by setting `allow_fragments` to `False`.\n    \n        The inverse of this function is :func:`url_unparse`.\n    \n        :param url: the URL to parse.\n        :param scheme: the default schema to use if the URL is schemaless.\n        :param allow_fragments: if set to `False` a fragment will be removed\n                                from the URL.\n    \n        .. deprecated:: 2.3\n            Will be removed in Werkzeug 3.0. Use ``urllib.parse.urlsplit`` instead.\n        \"\"\"\n>       warnings.warn(\n            \"'werkzeug.urls.url_parse' is deprecated and will be removed in Werkzeug 3.0.\"\n            \" Use 'urllib.parse.urlsplit' instead.\",\n            DeprecationWarning,\n            stacklevel=2,\n        )\nE       DeprecationWarning: 'werkzeug.urls.url_parse' is deprecated and will be removed in Werkzeug 3.0. Use 'urllib.parse.urlsplit' instead.\n\n/opt/miniconda3/envs/testbed/lib/python3.9/site-packages/werkzeug/urls.py:505: DeprecationWarning\n___________________ test_blueprint_prefix_slash[/foo--/foo] ____________________\n\napp = <Flask 'flask_test'>, client = <FlaskClient <Flask 'flask_test'>>\nprefix = '/foo', rule = '', url = '/foo'\n\n    @pytest.mark.parametrize(\n        (\"prefix\", \"rule\", \"url\"),\n        (\n            (\"\", \"/\", \"/\"),\n            (\"/\", \"\", \"/\"),\n            (\"/\", \"/\", \"/\"),\n            (\"/foo\", \"\", \"/foo\"),\n            (\"/foo/\", \"\", \"/foo/\"),\n            (\"\", \"/bar\", \"/bar\"),\n            (\"/foo/\", \"/bar\", \"/foo/bar\"),\n            (\"/foo/\", \"bar\", \"/foo/bar\"),\n            (\"/foo\", \"/bar\", \"/foo/bar\"),\n            (\"/foo/\", \"//bar\", \"/foo/bar\"),\n            (\"/foo//\", \"/bar\", \"/foo/bar\"),\n        ),\n    )\n    def test_blueprint_prefix_slash(app, client, prefix, rule, url):\n        bp = flask.Blueprint(\"test\", __name__, url_prefix=prefix)\n    \n        @bp.route(rule)\n        def index():\n            return \"\", 204\n    \n        app.register_blueprint(bp)\n>       assert client.get(url).status_code == 204\n\ntests/test_blueprints.py:128: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n/opt/miniconda3/envs/testbed/lib/python3.9/site-packages/werkzeug/test.py:1243: in get\n    return self.open(*args, **kw)\nsrc/flask/testing.py:209: in open\n    builder = EnvironBuilder(self.application, *args, **kwargs)\nsrc/flask/testing.py:70: in __init__\n    url = url_parse(path)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nurl = '/foo', scheme = None, allow_fragments = True\n\n    def url_parse(\n        url: str, scheme: str | None = None, allow_fragments: bool = True\n    ) -> BaseURL:\n        \"\"\"Parses a URL from a string into a :class:`URL` tuple.  If the URL\n        is lacking a scheme it can be provided as second argument. Otherwise,\n        it is ignored.  Optionally fragments can be stripped from the URL\n        by setting `allow_fragments` to `False`.\n    \n        The inverse of this function is :func:`url_unparse`.\n    \n        :param url: the URL to parse.\n        :param scheme: the default schema to use if the URL is schemaless.\n        :param allow_fragments: if set to `False` a fragment will be removed\n                                from the URL.\n    \n        .. deprecated:: 2.3\n            Will be removed in Werkzeug 3.0. Use ``urllib.parse.urlsplit`` instead.\n        \"\"\"\n>       warnings.warn(\n            \"'werkzeug.urls.url_parse' is deprecated and will be removed in Werkzeug 3.0.\"\n            \" Use 'urllib.parse.urlsplit' instead.\",\n            DeprecationWarning,\n            stacklevel=2,\n        )\nE       DeprecationWarning: 'werkzeug.urls.url_parse' is deprecated and will be removed in Werkzeug 3.0. Use 'urllib.parse.urlsplit' instead.\n\n/opt/miniconda3/envs/testbed/lib/python3.9/site-packages/werkzeug/urls.py:505: DeprecationWarning\n__________________ test_blueprint_prefix_slash[/foo/--/foo/] ___________________\n\napp = <Flask 'flask_test'>, client = <FlaskClient <Flask 'flask_test'>>\nprefix = '/foo/', rule = '', url = '/foo/'\n\n    @pytest.mark.parametrize(\n        (\"prefix\", \"rule\", \"url\"),\n        (\n            (\"\", \"/\", \"/\"),\n            (\"/\", \"\", \"/\"),\n            (\"/\", \"/\", \"/\"),\n            (\"/foo\", \"\", \"/foo\"),\n            (\"/foo/\", \"\", \"/foo/\"),\n            (\"\", \"/bar\", \"/bar\"),\n            (\"/foo/\", \"/bar\", \"/foo/bar\"),\n            (\"/foo/\", \"bar\", \"/foo/bar\"),\n            (\"/foo\", \"/bar\", \"/foo/bar\"),\n            (\"/foo/\", \"//bar\", \"/foo/bar\"),\n            (\"/foo//\", \"/bar\", \"/foo/bar\"),\n        ),\n    )\n    def test_blueprint_prefix_slash(app, client, prefix, rule, url):\n        bp = flask.Blueprint(\"test\", __name__, url_prefix=prefix)\n    \n        @bp.route(rule)\n        def index():\n            return \"\", 204\n    \n        app.register_blueprint(bp)\n>       assert client.get(url).status_code == 204\n\ntests/test_blueprints.py:128: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n/opt/miniconda3/envs/testbed/lib/python3.9/site-packages/werkzeug/test.py:1243: in get\n    return self.open(*args, **kw)\nsrc/flask/testing.py:209: in open\n    builder = EnvironBuilder(self.application, *args, **kwargs)\nsrc/flask/testing.py:70: in __init__\n    url = url_parse(path)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nurl = '/foo/', scheme = None, allow_fragments = True\n\n    def url_parse(\n        url: str, scheme: str | None = None, allow_fragments: bool = True\n    ) -> BaseURL:\n        \"\"\"Parses a URL from a string into a :class:`URL` tuple.  If the URL\n        is lacking a scheme it can be provided as second argument. Otherwise,\n        it is ignored.  Optionally fragments can be stripped from the URL\n        by setting `allow_fragments` to `False`.\n    \n        The inverse of this function is :func:`url_unparse`.\n    \n        :param url: the URL to parse.\n        :param scheme: the default schema to use if the URL is schemaless.\n        :param allow_fragments: if set to `False` a fragment will be removed\n                                from the URL.\n    \n        .. deprecated:: 2.3\n            Will be removed in Werkzeug 3.0. Use ``urllib.parse.urlsplit`` instead.\n        \"\"\"\n>       warnings.warn(\n            \"'werkzeug.urls.url_parse' is deprecated and will be removed in Werkzeug 3.0.\"\n            \" Use 'urllib.parse.urlsplit' instead.\",\n            DeprecationWarning,\n            stacklevel=2,\n        )\nE       DeprecationWarning: 'werkzeug.urls.url_parse' is deprecated and will be removed in Werkzeug 3.0. Use 'urllib.parse.urlsplit' instead.\n\n/opt/miniconda3/envs/testbed/lib/python3.9/site-packages/werkzeug/urls.py:505: DeprecationWarning\n___________________ test_blueprint_prefix_slash[-/bar-/bar] ____________________\n\napp = <Flask 'flask_test'>, client = <FlaskClient <Flask 'flask_test'>>\nprefix = '', rule = '/bar', url = '/bar'\n\n    @pytest.mark.parametrize(\n        (\"prefix\", \"rule\", \"url\"),\n        (\n            (\"\", \"/\", \"/\"),\n            (\"/\", \"\", \"/\"),\n            (\"/\", \"/\", \"/\"),\n            (\"/foo\", \"\", \"/foo\"),\n            (\"/foo/\", \"\", \"/foo/\"),\n            (\"\", \"/bar\", \"/bar\"),\n            (\"/foo/\", \"/bar\", \"/foo/bar\"),\n            (\"/foo/\", \"bar\", \"/foo/bar\"),\n            (\"/foo\", \"/bar\", \"/foo/bar\"),\n            (\"/foo/\", \"//bar\", \"/foo/bar\"),\n            (\"/foo//\", \"/bar\", \"/foo/bar\"),\n        ),\n    )\n    def test_blueprint_prefix_slash(app, client, prefix, rule, url):\n        bp = flask.Blueprint(\"test\", __name__, url_prefix=prefix)\n    \n        @bp.route(rule)\n        def index():\n            return \"\", 204\n    \n        app.register_blueprint(bp)\n>       assert client.get(url).status_code == 204\n\ntests/test_blueprints.py:128: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n/opt/miniconda3/envs/testbed/lib/python3.9/site-packages/werkzeug/test.py:1243: in get\n    return self.open(*args, **kw)\nsrc/flask/testing.py:209: in open\n    builder = EnvironBuilder(self.application, *args, **kwargs)\nsrc/flask/testing.py:70: in __init__\n    url = url_parse(path)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nurl = '/bar', scheme = None, allow_fragments = True\n\n    def url_parse(\n        url: str, scheme: str | None = None, allow_fragments: bool = True\n    ) -> BaseURL:\n        \"\"\"Parses a URL from a string into a :class:`URL` tuple.  If the URL\n        is lacking a scheme it can be provided as second argument. Otherwise,\n        it is ignored.  Optionally fragments can be stripped from the URL\n        by setting `allow_fragments` to `False`.\n    \n        The inverse of this function is :func:`url_unparse`.\n    \n        :param url: the URL to parse.\n        :param scheme: the default schema to use if the URL is schemaless.\n        :param allow_fragments: if set to `False` a fragment will be removed\n                                from the URL.\n    \n        .. deprecated:: 2.3\n            Will be removed in Werkzeug 3.0. Use ``urllib.parse.urlsplit`` instead.\n        \"\"\"\n>       warnings.warn(\n            \"'werkzeug.urls.url_parse' is deprecated and will be removed in Werkzeug 3.0.\"\n            \" Use 'urllib.parse.urlsplit' instead.\",\n            DeprecationWarning,\n            stacklevel=2,\n        )\nE       DeprecationWarning: 'werkzeug.urls.url_parse' is deprecated and will be removed in Werkzeug 3.0. Use 'urllib.parse.urlsplit' instead.\n\n/opt/miniconda3/envs/testbed/lib/python3.9/site-packages/werkzeug/urls.py:505: DeprecationWarning\n_______________ test_blueprint_prefix_slash[/foo/-/bar-/foo/bar] _______________\n\napp = <Flask 'flask_test'>, client = <FlaskClient <Flask 'flask_test'>>\nprefix = '/foo/', rule = '/bar', url = '/foo/bar'\n\n    @pytest.mark.parametrize(\n        (\"prefix\", \"rule\", \"url\"),\n        (\n            (\"\", \"/\", \"/\"),\n            (\"/\", \"\", \"/\"),\n            (\"/\", \"/\", \"/\"),\n            (\"/foo\", \"\", \"/foo\"),\n            (\"/foo/\", \"\", \"/foo/\"),\n            (\"\", \"/bar\", \"/bar\"),\n            (\"/foo/\", \"/bar\", \"/foo/bar\"),\n            (\"/foo/\", \"bar\", \"/foo/bar\"),\n            (\"/foo\", \"/bar\", \"/foo/bar\"),\n            (\"/foo/\", \"//bar\", \"/foo/bar\"),\n            (\"/foo//\", \"/bar\", \"/foo/bar\"),\n        ),\n    )\n    def test_blueprint_prefix_slash(app, client, prefix, rule, url):\n        bp = flask.Blueprint(\"test\", __name__, url_prefix=prefix)\n    \n        @bp.route(rule)\n        def index():\n            return \"\", 204\n    \n        app.register_blueprint(bp)\n>       assert client.get(url).status_code == 204\n\ntests/test_blueprints.py:128: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n/opt/miniconda3/envs/testbed/lib/python3.9/site-packages/werkzeug/test.py:1243: in get\n    return self.open(*args, **kw)\nsrc/flask/testing.py:209: in open\n    builder = EnvironBuilder(self.application, *args, **kwargs)\nsrc/flask/testing.py:70: in __init__\n    url = url_parse(path)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nurl = '/foo/bar', scheme = None, allow_fragments = True\n\n    def url_parse(\n        url: str, scheme: str | None = None, allow_fragments: bool = True\n    ) -> BaseURL:\n        \"\"\"Parses a URL from a string into a :class:`URL` tuple.  If the URL\n        is lacking a scheme it can be provided as second argument. Otherwise,\n        it is ignored.  Optionally fragments can be stripped from the URL\n        by setting `allow_fragments` to `False`.\n    \n        The inverse of this function is :func:`url_unparse`.\n    \n        :param url: the URL to parse.\n        :param scheme: the default schema to use if the URL is schemaless.\n        :param allow_fragments: if set to `False` a fragment will be removed\n                                from the URL.\n    \n        .. deprecated:: 2.3\n            Will be removed in Werkzeug 3.0. Use ``urllib.parse.urlsplit`` instead.\n        \"\"\"\n>       warnings.warn(\n            \"'werkzeug.urls.url_parse' is deprecated and will be removed in Werkzeug 3.0.\"\n            \" Use 'urllib.parse.urlsplit' instead.\",\n            DeprecationWarning,\n            stacklevel=2,\n        )\nE       DeprecationWarning: 'werkzeug.urls.url_parse' is deprecated and will be removed in Werkzeug 3.0. Use 'urllib.parse.urlsplit' instead.\n\n/opt/miniconda3/envs/testbed/lib/python3.9/site-packages/werkzeug/urls.py:505: DeprecationWarning\n_______________ test_blueprint_prefix_slash[/foo/-bar-/foo/bar] ________________\n\napp = <Flask 'flask_test'>, client = <FlaskClient <Flask 'flask_test'>>\nprefix = '/foo/', rule = 'bar', url = '/foo/bar'\n\n    @pytest.mark.parametrize(\n        (\"prefix\", \"rule\", \"url\"),\n        (\n            (\"\", \"/\", \"/\"),\n            (\"/\", \"\", \"/\"),\n            (\"/\", \"/\", \"/\"),\n            (\"/foo\", \"\", \"/foo\"),\n            (\"/foo/\", \"\", \"/foo/\"),\n            (\"\", \"/bar\", \"/bar\"),\n            (\"/foo/\", \"/bar\", \"/foo/bar\"),\n            (\"/foo/\", \"bar\", \"/foo/bar\"),\n            (\"/foo\", \"/bar\", \"/foo/bar\"),\n            (\"/foo/\", \"//bar\", \"/foo/bar\"),\n            (\"/foo//\", \"/bar\", \"/foo/bar\"),\n        ),\n    )\n    def test_blueprint_prefix_slash(app, client, prefix, rule, url):\n        bp = flask.Blueprint(\"test\", __name__, url_prefix=prefix)\n    \n        @bp.route(rule)\n        def index():\n            return \"\", 204\n    \n        app.register_blueprint(bp)\n>       assert client.get(url).status_code == 204\n\ntests/test_blueprints.py:128: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n/opt/miniconda3/envs/testbed/lib/python3.9/site-packages/werkzeug/test.py:1243: in get\n    return self.open(*args, **kw)\nsrc/flask/testing.py:209: in open\n    builder = EnvironBuilder(self.application, *args, **kwargs)\nsrc/flask/testing.py:70: in __init__\n    url = url_parse(path)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nurl = '/foo/bar', scheme = None, allow_fragments = True\n\n    def url_parse(\n        url: str, scheme: str | None = None, allow_fragments: bool = True\n    ) -> BaseURL:\n        \"\"\"Parses a URL from a string into a :class:`URL` tuple.  If the URL\n        is lacking a scheme it can be provided as second argument. Otherwise,\n        it is ignored.  Optionally fragments can be stripped from the URL\n        by setting `allow_fragments` to `False`.\n    \n        The inverse of this function is :func:`url_unparse`.\n    \n        :param url: the URL to parse.\n        :param scheme: the default schema to use if the URL is schemaless.\n        :param allow_fragments: if set to `False` a fragment will be removed\n                                from the URL.\n    \n        .. deprecated:: 2.3\n            Will be removed in Werkzeug 3.0. Use ``urllib.parse.urlsplit`` instead.\n        \"\"\"\n>       warnings.warn(\n            \"'werkzeug.urls.url_parse' is deprecated and will be removed in Werkzeug 3.0.\"\n            \" Use 'urllib.parse.urlsplit' instead.\",\n            DeprecationWarning,\n            stacklevel=2,\n        )\nE       DeprecationWarning: 'werkzeug.urls.url_parse' is deprecated and will be removed in Werkzeug 3.0. Use 'urllib.parse.urlsplit' instead.\n\n/opt/miniconda3/envs/testbed/lib/python3.9/site-packages/werkzeug/urls.py:505: DeprecationWarning\n_______________ test_blueprint_prefix_slash[/foo-/bar-/foo/bar] ________________\n\napp = <Flask 'flask_test'>, client = <FlaskClient <Flask 'flask_test'>>\nprefix = '/foo', rule = '/bar', url = '/foo/bar'\n\n    @pytest.mark.parametrize(\n        (\"prefix\", \"rule\", \"url\"),\n        (\n            (\"\", \"/\", \"/\"),\n            (\"/\", \"\", \"/\"),\n            (\"/\", \"/\", \"/\"),\n            (\"/foo\", \"\", \"/foo\"),\n            (\"/foo/\", \"\", \"/foo/\"),\n            (\"\", \"/bar\", \"/bar\"),\n            (\"/foo/\", \"/bar\", \"/foo/bar\"),\n            (\"/foo/\", \"bar\", \"/foo/bar\"),\n            (\"/foo\", \"/bar\", \"/foo/bar\"),\n            (\"/foo/\", \"//bar\", \"/foo/bar\"),\n            (\"/foo//\", \"/bar\", \"/foo/bar\"),\n        ),\n    )\n    def test_blueprint_prefix_slash(app, client, prefix, rule, url):\n        bp = flask.Blueprint(\"test\", __name__, url_prefix=prefix)\n    \n        @bp.route(rule)\n        def index():\n            return \"\", 204\n    \n        app.register_blueprint(bp)\n>       assert client.get(url).status_code == 204\n\ntests/test_blueprints.py:128: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n/opt/miniconda3/envs/testbed/lib/python3.9/site-packages/werkzeug/test.py:1243: in get\n    return self.open(*args, **kw)\nsrc/flask/testing.py:209: in open\n    builder = EnvironBuilder(self.application, *args, **kwargs)\nsrc/flask/testing.py:70: in __init__\n    url = url_parse(path)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nurl = '/foo/bar', scheme = None, allow_fragments = True\n\n    def url_parse(\n        url: str, scheme: str | None = None, allow_fragments: bool = True\n    ) -> BaseURL:\n        \"\"\"Parses a URL from a string into a :class:`URL` tuple.  If the URL\n        is lacking a scheme it can be provided as second argument. Otherwise,\n        it is ignored.  Optionally fragments can be stripped from the URL\n        by setting `allow_fragments` to `False`.\n    \n        The inverse of this function is :func:`url_unparse`.\n    \n        :param url: the URL to parse.\n        :param scheme: the default schema to use if the URL is schemaless.\n        :param allow_fragments: if set to `False` a fragment will be removed\n                                from the URL.\n    \n        .. deprecated:: 2.3\n            Will be removed in Werkzeug 3.0. Use ``urllib.parse.urlsplit`` instead.\n        \"\"\"\n>       warnings.warn(\n            \"'werkzeug.urls.url_parse' is deprecated and will be removed in Werkzeug 3.0.\"\n            \" Use 'urllib.parse.urlsplit' instead.\",\n            DeprecationWarning,\n            stacklevel=2,\n        )\nE       DeprecationWarning: 'werkzeug.urls.url_parse' is deprecated and will be removed in Werkzeug 3.0. Use 'urllib.parse.urlsplit' instead.\n\n/opt/miniconda3/envs/testbed/lib/python3.9/site-packages/werkzeug/urls.py:505: DeprecationWarning\n______________ test_blueprint_prefix_slash[/foo/-//bar-/foo/bar] _______________\n\napp = <Flask 'flask_test'>, client = <FlaskClient <Flask 'flask_test'>>\nprefix = '/foo/', rule = '//bar', url = '/foo/bar'\n\n    @pytest.mark.parametrize(\n        (\"prefix\", \"rule\", \"url\"),\n        (\n            (\"\", \"/\", \"/\"),\n            (\"/\", \"\", \"/\"),\n            (\"/\", \"/\", \"/\"),\n            (\"/foo\", \"\", \"/foo\"),\n            (\"/foo/\", \"\", \"/foo/\"),\n            (\"\", \"/bar\", \"/bar\"),\n            (\"/foo/\", \"/bar\", \"/foo/bar\"),\n            (\"/foo/\", \"bar\", \"/foo/bar\"),\n            (\"/foo\", \"/bar\", \"/foo/bar\"),\n            (\"/foo/\", \"//bar\", \"/foo/bar\"),\n            (\"/foo//\", \"/bar\", \"/foo/bar\"),\n        ),\n    )\n    def test_blueprint_prefix_slash(app, client, prefix, rule, url):\n        bp = flask.Blueprint(\"test\", __name__, url_prefix=prefix)\n    \n        @bp.route(rule)\n        def index():\n            return \"\", 204\n    \n        app.register_blueprint(bp)\n>       assert client.get(url).status_code == 204\n\ntests/test_blueprints.py:128: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n/opt/miniconda3/envs/testbed/lib/python3.9/site-packages/werkzeug/test.py:1243: in get\n    return self.open(*args, **kw)\nsrc/flask/testing.py:209: in open\n    builder = EnvironBuilder(self.application, *args, **kwargs)\nsrc/flask/testing.py:70: in __init__\n    url = url_parse(path)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nurl = '/foo/bar', scheme = None, allow_fragments = True\n\n    def url_parse(\n        url: str, scheme: str | None = None, allow_fragments: bool = True\n    ) -> BaseURL:\n        \"\"\"Parses a URL from a string into a :class:`URL` tuple.  If the URL\n        is lacking a scheme it can be provided as second argument. Otherwise,\n        it is ignored.  Optionally fragments can be stripped from the URL\n        by setting `allow_fragments` to `False`.\n    \n        The inverse of this function is :func:`url_unparse`.\n    \n        :param url: the URL to parse.\n        :param scheme: the default schema to use if the URL is schemaless.\n        :param allow_fragments: if set to `False` a fragment will be removed\n                                from the URL.\n    \n        .. deprecated:: 2.3\n            Will be removed in Werkzeug 3.0. Use ``urllib.parse.urlsplit`` instead.\n        \"\"\"\n>       warnings.warn(\n            \"'werkzeug.urls.url_parse' is deprecated and will be removed in Werkzeug 3.0.\"\n            \" Use 'urllib.parse.urlsplit' instead.\",\n            DeprecationWarning,\n            stacklevel=2,\n        )\nE       DeprecationWarning: 'werkzeug.urls.url_parse' is deprecated and will be removed in Werkzeug 3.0. Use 'urllib.parse.urlsplit' instead.\n\n/opt/miniconda3/envs/testbed/lib/python3.9/site-packages/werkzeug/urls.py:505: DeprecationWarning\n______________ test_blueprint_prefix_slash[/foo//-/bar-/foo/bar] _______________\n\napp = <Flask 'flask_test'>, client = <FlaskClient <Flask 'flask_test'>>\nprefix = '/foo//', rule = '/bar', url = '/foo/bar'\n\n    @pytest.mark.parametrize(\n        (\"prefix\", \"rule\", \"url\"),\n        (\n            (\"\", \"/\", \"/\"),\n            (\"/\", \"\", \"/\"),\n            (\"/\", \"/\", \"/\"),\n            (\"/foo\", \"\", \"/foo\"),\n            (\"/foo/\", \"\", \"/foo/\"),\n            (\"\", \"/bar\", \"/bar\"),\n            (\"/foo/\", \"/bar\", \"/foo/bar\"),\n            (\"/foo/\", \"bar\", \"/foo/bar\"),\n            (\"/foo\", \"/bar\", \"/foo/bar\"),\n            (\"/foo/\", \"//bar\", \"/foo/bar\"),\n            (\"/foo//\", \"/bar\", \"/foo/bar\"),\n        ),\n    )\n    def test_blueprint_prefix_slash(app, client, prefix, rule, url):\n        bp = flask.Blueprint(\"test\", __name__, url_prefix=prefix)\n    \n        @bp.route(rule)\n        def index():\n            return \"\", 204\n    \n        app.register_blueprint(bp)\n>       assert client.get(url).status_code == 204\n\ntests/test_blueprints.py:128: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n/opt/miniconda3/envs/testbed/lib/python3.9/site-packages/werkzeug/test.py:1243: in get\n    return self.open(*args, **kw)\nsrc/flask/testing.py:209: in open\n    builder = EnvironBuilder(self.application, *args, **kwargs)\nsrc/flask/testing.py:70: in __init__\n    url = url_parse(path)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nurl = '/foo/bar', scheme = None, allow_fragments = True\n\n    def url_parse(\n        url: str, scheme: str | None = None, allow_fragments: bool = True\n    ) -> BaseURL:\n        \"\"\"Parses a URL from a string into a :class:`URL` tuple.  If the URL\n        is lacking a scheme it can be provided as second argument. Otherwise,\n        it is ignored.  Optionally fragments can be stripped from the URL\n        by setting `allow_fragments` to `False`.\n    \n        The inverse of this function is :func:`url_unparse`.\n    \n        :param url: the URL to parse.\n        :param scheme: the default schema to use if the URL is schemaless.\n        :param allow_fragments: if set to `False` a fragment will be removed\n                                from the URL.\n    \n        .. deprecated:: 2.3\n            Will be removed in Werkzeug 3.0. Use ``urllib.parse.urlsplit`` instead.\n        \"\"\"\n>       warnings.warn(\n            \"'werkzeug.urls.url_parse' is deprecated and will be removed in Werkzeug 3.0.\"\n            \" Use 'urllib.parse.urlsplit' instead.\",\n            DeprecationWarning,\n            stacklevel=2,\n        )\nE       DeprecationWarning: 'werkzeug.urls.url_parse' is deprecated and will be removed in Werkzeug 3.0. Use 'urllib.parse.urlsplit' instead.\n\n/opt/miniconda3/envs/testbed/lib/python3.9/site-packages/werkzeug/urls.py:505: DeprecationWarning\n_________________________ test_blueprint_url_defaults __________________________\n\napp = <Flask 'flask_test'>, client = <FlaskClient <Flask 'flask_test'>>\n\n    def test_blueprint_url_defaults(app, client):\n        bp = flask.Blueprint(\"test\", __name__)\n    \n        @bp.route(\"/foo\", defaults={\"baz\": 42})\n        def foo(bar, baz):\n            return f\"{bar}/{baz:d}\"\n    \n        @bp.route(\"/bar\")\n        def bar(bar):\n            return str(bar)\n    \n        app.register_blueprint(bp, url_prefix=\"/1\", url_defaults={\"bar\": 23})\n        app.register_blueprint(bp, url_prefix=\"/2\", url_defaults={\"bar\": 19})\n    \n>       assert client.get(\"/1/foo\").data == b\"23/42\"\n\ntests/test_blueprints.py:145: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n/opt/miniconda3/envs/testbed/lib/python3.9/site-packages/werkzeug/test.py:1243: in get\n    return self.open(*args, **kw)\nsrc/flask/testing.py:209: in open\n    builder = EnvironBuilder(self.application, *args, **kwargs)\nsrc/flask/testing.py:70: in __init__\n    url = url_parse(path)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nurl = '/1/foo', scheme = None, allow_fragments = True\n\n    def url_parse(\n        url: str, scheme: str | None = None, allow_fragments: bool = True\n    ) -> BaseURL:\n        \"\"\"Parses a URL from a string into a :class:`URL` tuple.  If the URL\n        is lacking a scheme it can be provided as second argument. Otherwise,\n        it is ignored.  Optionally fragments can be stripped from the URL\n        by setting `allow_fragments` to `False`.\n    \n        The inverse of this function is :func:`url_unparse`.\n    \n        :param url: the URL to parse.\n        :param scheme: the default schema to use if the URL is schemaless.\n        :param allow_fragments: if set to `False` a fragment will be removed\n                                from the URL.\n    \n        .. deprecated:: 2.3\n            Will be removed in Werkzeug 3.0. Use ``urllib.parse.urlsplit`` instead.\n        \"\"\"\n>       warnings.warn(\n            \"'werkzeug.urls.url_parse' is deprecated and will be removed in Werkzeug 3.0.\"\n            \" Use 'urllib.parse.urlsplit' instead.\",\n            DeprecationWarning,\n            stacklevel=2,\n        )\nE       DeprecationWarning: 'werkzeug.urls.url_parse' is deprecated and will be removed in Werkzeug 3.0. Use 'urllib.parse.urlsplit' instead.\n\n/opt/miniconda3/envs/testbed/lib/python3.9/site-packages/werkzeug/urls.py:505: DeprecationWarning\n________________________ test_blueprint_url_processors _________________________\n\napp = <Flask 'flask_test'>, client = <FlaskClient <Flask 'flask_test'>>\n\n    def test_blueprint_url_processors(app, client):\n        bp = flask.Blueprint(\"frontend\", __name__, url_prefix=\"/<lang_code>\")\n    \n        @bp.url_defaults\n        def add_language_code(endpoint, values):\n            values.setdefault(\"lang_code\", flask.g.lang_code)\n    \n        @bp.url_value_preprocessor\n        def pull_lang_code(endpoint, values):\n            flask.g.lang_code = values.pop(\"lang_code\")\n    \n        @bp.route(\"/\")\n        def index():\n            return flask.url_for(\".about\")\n    \n        @bp.route(\"/about\")\n        def about():\n            return flask.url_for(\".index\")\n    \n        app.register_blueprint(bp)\n    \n>       assert client.get(\"/de/\").data == b\"/de/about\"\n\ntests/test_blueprints.py:172: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n/opt/miniconda3/envs/testbed/lib/python3.9/site-packages/werkzeug/test.py:1243: in get\n    return self.open(*args, **kw)\nsrc/flask/testing.py:209: in open\n    builder = EnvironBuilder(self.application, *args, **kwargs)\nsrc/flask/testing.py:70: in __init__\n    url = url_parse(path)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nurl = '/de/', scheme = None, allow_fragments = True\n\n    def url_parse(\n        url: str, scheme: str | None = None, allow_fragments: bool = True\n    ) -> BaseURL:\n        \"\"\"Parses a URL from a string into a :class:`URL` tuple.  If the URL\n        is lacking a scheme it can be provided as second argument. Otherwise,\n        it is ignored.  Optionally fragments can be stripped from the URL\n        by setting `allow_fragments` to `False`.\n    \n        The inverse of this function is :func:`url_unparse`.\n    \n        :param url: the URL to parse.\n        :param scheme: the default schema to use if the URL is schemaless.\n        :param allow_fragments: if set to `False` a fragment will be removed\n                                from the URL.\n    \n        .. deprecated:: 2.3\n            Will be removed in Werkzeug 3.0. Use ``urllib.parse.urlsplit`` instead.\n        \"\"\"\n>       warnings.warn(\n            \"'werkzeug.urls.url_parse' is deprecated and will be removed in Werkzeug 3.0.\"\n            \" Use 'urllib.parse.urlsplit' instead.\",\n            DeprecationWarning,\n            stacklevel=2,\n        )\nE       DeprecationWarning: 'werkzeug.urls.url_parse' is deprecated and will be removed in Werkzeug 3.0. Use 'urllib.parse.urlsplit' instead.\n\n/opt/miniconda3/envs/testbed/lib/python3.9/site-packages/werkzeug/urls.py:505: DeprecationWarning\n_________________________ test_default_static_max_age __________________________\n\napp = <Flask 'flask_test'>\n\n    def test_default_static_max_age(app):\n        class MyBlueprint(flask.Blueprint):\n            def get_send_file_max_age(self, filename):\n                return 100\n    \n        blueprint = MyBlueprint(\"blueprint\", __name__, static_folder=\"static\")\n        app.register_blueprint(blueprint)\n    \n        # try/finally, in case other tests use this app for Blueprint tests.\n        max_age_default = app.config[\"SEND_FILE_MAX_AGE_DEFAULT\"]\n        try:\n>           with app.test_request_context():\n\ntests/test_blueprints.py:234: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \nsrc/flask/app.py:2015: in test_request_context\n    builder = EnvironBuilder(self, *args, **kwargs)\nsrc/flask/testing.py:70: in __init__\n    url = url_parse(path)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nurl = '/', scheme = None, allow_fragments = True\n\n    def url_parse(\n        url: str, scheme: str | None = None, allow_fragments: bool = True\n    ) -> BaseURL:\n        \"\"\"Parses a URL from a string into a :class:`URL` tuple.  If the URL\n        is lacking a scheme it can be provided as second argument. Otherwise,\n        it is ignored.  Optionally fragments can be stripped from the URL\n        by setting `allow_fragments` to `False`.\n    \n        The inverse of this function is :func:`url_unparse`.\n    \n        :param url: the URL to parse.\n        :param scheme: the default schema to use if the URL is schemaless.\n        :param allow_fragments: if set to `False` a fragment will be removed\n                                from the URL.\n    \n        .. deprecated:: 2.3\n            Will be removed in Werkzeug 3.0. Use ``urllib.parse.urlsplit`` instead.\n        \"\"\"\n>       warnings.warn(\n            \"'werkzeug.urls.url_parse' is deprecated and will be removed in Werkzeug 3.0.\"\n            \" Use 'urllib.parse.urlsplit' instead.\",\n            DeprecationWarning,\n            stacklevel=2,\n        )\nE       DeprecationWarning: 'werkzeug.urls.url_parse' is deprecated and will be removed in Werkzeug 3.0. Use 'urllib.parse.urlsplit' instead.\n\n/opt/miniconda3/envs/testbed/lib/python3.9/site-packages/werkzeug/urls.py:505: DeprecationWarning\n__________________________ test_dotted_names_from_app __________________________\n\napp = <Flask 'flask_test'>, client = <FlaskClient <Flask 'flask_test'>>\n\n    def test_dotted_names_from_app(app, client):\n        test = flask.Blueprint(\"test\", __name__)\n    \n        @app.route(\"/\")\n        def app_index():\n            return flask.url_for(\"test.index\")\n    \n        @test.route(\"/test/\")\n        def index():\n            return flask.url_for(\"app_index\")\n    \n        app.register_blueprint(test)\n    \n>       rv = client.get(\"/\")\n\ntests/test_blueprints.py:272: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n/opt/miniconda3/envs/testbed/lib/python3.9/site-packages/werkzeug/test.py:1243: in get\n    return self.open(*args, **kw)\nsrc/flask/testing.py:209: in open\n    builder = EnvironBuilder(self.application, *args, **kwargs)\nsrc/flask/testing.py:70: in __init__\n    url = url_parse(path)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nurl = '/', scheme = None, allow_fragments = True\n\n    def url_parse(\n        url: str, scheme: str | None = None, allow_fragments: bool = True\n    ) -> BaseURL:\n        \"\"\"Parses a URL from a string into a :class:`URL` tuple.  If the URL\n        is lacking a scheme it can be provided as second argument. Otherwise,\n        it is ignored.  Optionally fragments can be stripped from the URL\n        by setting `allow_fragments` to `False`.\n    \n        The inverse of this function is :func:`url_unparse`.\n    \n        :param url: the URL to parse.\n        :param scheme: the default schema to use if the URL is schemaless.\n        :param allow_fragments: if set to `False` a fragment will be removed\n                                from the URL.\n    \n        .. deprecated:: 2.3\n            Will be removed in Werkzeug 3.0. Use ``urllib.parse.urlsplit`` instead.\n        \"\"\"\n>       warnings.warn(\n            \"'werkzeug.urls.url_parse' is deprecated and will be removed in Werkzeug 3.0.\"\n            \" Use 'urllib.parse.urlsplit' instead.\",\n            DeprecationWarning,\n            stacklevel=2,\n        )\nE       DeprecationWarning: 'werkzeug.urls.url_parse' is deprecated and will be removed in Werkzeug 3.0. Use 'urllib.parse.urlsplit' instead.\n\n/opt/miniconda3/envs/testbed/lib/python3.9/site-packages/werkzeug/urls.py:505: DeprecationWarning\n___________________________ test_empty_url_defaults ____________________________\n\napp = <Flask 'flask_test'>, client = <FlaskClient <Flask 'flask_test'>>\n\n    def test_empty_url_defaults(app, client):\n        bp = flask.Blueprint(\"bp\", __name__)\n    \n        @bp.route(\"/\", defaults={\"page\": 1})\n        @bp.route(\"/page/<int:page>\")\n        def something(page):\n            return str(page)\n    \n        app.register_blueprint(bp)\n    \n>       assert client.get(\"/\").data == b\"1\"\n\ntests/test_blueprints.py:286: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n/opt/miniconda3/envs/testbed/lib/python3.9/site-packages/werkzeug/test.py:1243: in get\n    return self.open(*args, **kw)\nsrc/flask/testing.py:209: in open\n    builder = EnvironBuilder(self.application, *args, **kwargs)\nsrc/flask/testing.py:70: in __init__\n    url = url_parse(path)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nurl = '/', scheme = None, allow_fragments = True\n\n    def url_parse(\n        url: str, scheme: str | None = None, allow_fragments: bool = True\n    ) -> BaseURL:\n        \"\"\"Parses a URL from a string into a :class:`URL` tuple.  If the URL\n        is lacking a scheme it can be provided as second argument. Otherwise,\n        it is ignored.  Optionally fragments can be stripped from the URL\n        by setting `allow_fragments` to `False`.\n    \n        The inverse of this function is :func:`url_unparse`.\n    \n        :param url: the URL to parse.\n        :param scheme: the default schema to use if the URL is schemaless.\n        :param allow_fragments: if set to `False` a fragment will be removed\n                                from the URL.\n    \n        .. deprecated:: 2.3\n            Will be removed in Werkzeug 3.0. Use ``urllib.parse.urlsplit`` instead.\n        \"\"\"\n>       warnings.warn(\n            \"'werkzeug.urls.url_parse' is deprecated and will be removed in Werkzeug 3.0.\"\n            \" Use 'urllib.parse.urlsplit' instead.\",\n            DeprecationWarning,\n            stacklevel=2,\n        )\nE       DeprecationWarning: 'werkzeug.urls.url_parse' is deprecated and will be removed in Werkzeug 3.0. Use 'urllib.parse.urlsplit' instead.\n\n/opt/miniconda3/envs/testbed/lib/python3.9/site-packages/werkzeug/urls.py:505: DeprecationWarning\n_____________________ test_route_decorator_custom_endpoint _____________________\n\napp = <Flask 'flask_test'>, client = <FlaskClient <Flask 'flask_test'>>\n\n    def test_route_decorator_custom_endpoint(app, client):\n        bp = flask.Blueprint(\"bp\", __name__)\n    \n        @bp.route(\"/foo\")\n        def foo():\n            return flask.request.endpoint\n    \n        @bp.route(\"/bar\", endpoint=\"bar\")\n        def foo_bar():\n            return flask.request.endpoint\n    \n        @bp.route(\"/bar/123\", endpoint=\"123\")\n        def foo_bar_foo():\n            return flask.request.endpoint\n    \n        @bp.route(\"/bar/foo\")\n        def bar_foo():\n            return flask.request.endpoint\n    \n        app.register_blueprint(bp, url_prefix=\"/py\")\n    \n        @app.route(\"/\")\n        def index():\n            return flask.request.endpoint\n    \n>       assert client.get(\"/\").data == b\"index\"\n\ntests/test_blueprints.py:315: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n/opt/miniconda3/envs/testbed/lib/python3.9/site-packages/werkzeug/test.py:1243: in get\n    return self.open(*args, **kw)\nsrc/flask/testing.py:209: in open\n    builder = EnvironBuilder(self.application, *args, **kwargs)\nsrc/flask/testing.py:70: in __init__\n    url = url_parse(path)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nurl = '/', scheme = None, allow_fragments = True\n\n    def url_parse(\n        url: str, scheme: str | None = None, allow_fragments: bool = True\n    ) -> BaseURL:\n        \"\"\"Parses a URL from a string into a :class:`URL` tuple.  If the URL\n        is lacking a scheme it can be provided as second argument. Otherwise,\n        it is ignored.  Optionally fragments can be stripped from the URL\n        by setting `allow_fragments` to `False`.\n    \n        The inverse of this function is :func:`url_unparse`.\n    \n        :param url: the URL to parse.\n        :param scheme: the default schema to use if the URL is schemaless.\n        :param allow_fragments: if set to `False` a fragment will be removed\n                                from the URL.\n    \n        .. deprecated:: 2.3\n            Will be removed in Werkzeug 3.0. Use ``urllib.parse.urlsplit`` instead.\n        \"\"\"\n>       warnings.warn(\n            \"'werkzeug.urls.url_parse' is deprecated and will be removed in Werkzeug 3.0.\"\n            \" Use 'urllib.parse.urlsplit' instead.\",\n            DeprecationWarning,\n            stacklevel=2,\n        )\nE       DeprecationWarning: 'werkzeug.urls.url_parse' is deprecated and will be removed in Werkzeug 3.0. Use 'urllib.parse.urlsplit' instead.\n\n/opt/miniconda3/envs/testbed/lib/python3.9/site-packages/werkzeug/urls.py:505: DeprecationWarning\n___________________________ test_endpoint_decorator ____________________________\n\napp = <Flask 'flask_test'>, client = <FlaskClient <Flask 'flask_test'>>\n\n    def test_endpoint_decorator(app, client):\n        from werkzeug.routing import Rule\n    \n        app.url_map.add(Rule(\"/foo\", endpoint=\"bar\"))\n    \n        bp = flask.Blueprint(\"bp\", __name__)\n    \n        @bp.endpoint(\"bar\")\n        def foobar():\n            return flask.request.endpoint\n    \n        app.register_blueprint(bp, url_prefix=\"/bp_prefix\")\n    \n>       assert client.get(\"/foo\").data == b\"bar\"\n\ntests/test_blueprints.py:353: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n/opt/miniconda3/envs/testbed/lib/python3.9/site-packages/werkzeug/test.py:1243: in get\n    return self.open(*args, **kw)\nsrc/flask/testing.py:209: in open\n    builder = EnvironBuilder(self.application, *args, **kwargs)\nsrc/flask/testing.py:70: in __init__\n    url = url_parse(path)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nurl = '/foo', scheme = None, allow_fragments = True\n\n    def url_parse(\n        url: str, scheme: str | None = None, allow_fragments: bool = True\n    ) -> BaseURL:\n        \"\"\"Parses a URL from a string into a :class:`URL` tuple.  If the URL\n        is lacking a scheme it can be provided as second argument. Otherwise,\n        it is ignored.  Optionally fragments can be stripped from the URL\n        by setting `allow_fragments` to `False`.\n    \n        The inverse of this function is :func:`url_unparse`.\n    \n        :param url: the URL to parse.\n        :param scheme: the default schema to use if the URL is schemaless.\n        :param allow_fragments: if set to `False` a fragment will be removed\n                                from the URL.\n    \n        .. deprecated:: 2.3\n            Will be removed in Werkzeug 3.0. Use ``urllib.parse.urlsplit`` instead.\n        \"\"\"\n>       warnings.warn(\n            \"'werkzeug.urls.url_parse' is deprecated and will be removed in Werkzeug 3.0.\"\n            \" Use 'urllib.parse.urlsplit' instead.\",\n            DeprecationWarning,\n            stacklevel=2,\n        )\nE       DeprecationWarning: 'werkzeug.urls.url_parse' is deprecated and will be removed in Werkzeug 3.0. Use 'urllib.parse.urlsplit' instead.\n\n/opt/miniconda3/envs/testbed/lib/python3.9/site-packages/werkzeug/urls.py:505: DeprecationWarning\n______________________ test_template_filter_with_template ______________________\n\napp = <Flask 'flask_test'>, client = <FlaskClient <Flask 'flask_test'>>\n\n    def test_template_filter_with_template(app, client):\n        bp = flask.Blueprint(\"bp\", __name__)\n    \n        @bp.app_template_filter()\n        def super_reverse(s):\n            return s[::-1]\n    \n        app.register_blueprint(bp, url_prefix=\"/py\")\n    \n        @app.route(\"/\")\n        def index():\n            return flask.render_template(\"template_filter.html\", value=\"abcd\")\n    \n>       rv = client.get(\"/\")\n\ntests/test_blueprints.py:422: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n/opt/miniconda3/envs/testbed/lib/python3.9/site-packages/werkzeug/test.py:1243: in get\n    return self.open(*args, **kw)\nsrc/flask/testing.py:209: in open\n    builder = EnvironBuilder(self.application, *args, **kwargs)\nsrc/flask/testing.py:70: in __init__\n    url = url_parse(path)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nurl = '/', scheme = None, allow_fragments = True\n\n    def url_parse(\n        url: str, scheme: str | None = None, allow_fragments: bool = True\n    ) -> BaseURL:\n        \"\"\"Parses a URL from a string into a :class:`URL` tuple.  If the URL\n        is lacking a scheme it can be provided as second argument. Otherwise,\n        it is ignored.  Optionally fragments can be stripped from the URL\n        by setting `allow_fragments` to `False`.\n    \n        The inverse of this function is :func:`url_unparse`.\n    \n        :param url: the URL to parse.\n        :param scheme: the default schema to use if the URL is schemaless.\n        :param allow_fragments: if set to `False` a fragment will be removed\n                                from the URL.\n    \n        .. deprecated:: 2.3\n            Will be removed in Werkzeug 3.0. Use ``urllib.parse.urlsplit`` instead.\n        \"\"\"\n>       warnings.warn(\n            \"'werkzeug.urls.url_parse' is deprecated and will be removed in Werkzeug 3.0.\"\n            \" Use 'urllib.parse.urlsplit' instead.\",\n            DeprecationWarning,\n            stacklevel=2,\n        )\nE       DeprecationWarning: 'werkzeug.urls.url_parse' is deprecated and will be removed in Werkzeug 3.0. Use 'urllib.parse.urlsplit' instead.\n\n/opt/miniconda3/envs/testbed/lib/python3.9/site-packages/werkzeug/urls.py:505: DeprecationWarning\n________________ test_template_filter_after_route_with_template ________________\n\napp = <Flask 'flask_test'>, client = <FlaskClient <Flask 'flask_test'>>\n\n    def test_template_filter_after_route_with_template(app, client):\n        @app.route(\"/\")\n        def index():\n            return flask.render_template(\"template_filter.html\", value=\"abcd\")\n    \n        bp = flask.Blueprint(\"bp\", __name__)\n    \n        @bp.app_template_filter()\n        def super_reverse(s):\n            return s[::-1]\n    \n        app.register_blueprint(bp, url_prefix=\"/py\")\n>       rv = client.get(\"/\")\n\ntests/test_blueprints.py:438: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n/opt/miniconda3/envs/testbed/lib/python3.9/site-packages/werkzeug/test.py:1243: in get\n    return self.open(*args, **kw)\nsrc/flask/testing.py:209: in open\n    builder = EnvironBuilder(self.application, *args, **kwargs)\nsrc/flask/testing.py:70: in __init__\n    url = url_parse(path)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nurl = '/', scheme = None, allow_fragments = True\n\n    def url_parse(\n        url: str, scheme: str | None = None, allow_fragments: bool = True\n    ) -> BaseURL:\n        \"\"\"Parses a URL from a string into a :class:`URL` tuple.  If the URL\n        is lacking a scheme it can be provided as second argument. Otherwise,\n        it is ignored.  Optionally fragments can be stripped from the URL\n        by setting `allow_fragments` to `False`.\n    \n        The inverse of this function is :func:`url_unparse`.\n    \n        :param url: the URL to parse.\n        :param scheme: the default schema to use if the URL is schemaless.\n        :param allow_fragments: if set to `False` a fragment will be removed\n                                from the URL.\n    \n        .. deprecated:: 2.3\n            Will be removed in Werkzeug 3.0. Use ``urllib.parse.urlsplit`` instead.\n        \"\"\"\n>       warnings.warn(\n            \"'werkzeug.urls.url_parse' is deprecated and will be removed in Werkzeug 3.0.\"\n            \" Use 'urllib.parse.urlsplit' instead.\",\n            DeprecationWarning,\n            stacklevel=2,\n        )\nE       DeprecationWarning: 'werkzeug.urls.url_parse' is deprecated and will be removed in Werkzeug 3.0. Use 'urllib.parse.urlsplit' instead.\n\n/opt/miniconda3/envs/testbed/lib/python3.9/site-packages/werkzeug/urls.py:505: DeprecationWarning\n____________________ test_add_template_filter_with_template ____________________\n\napp = <Flask 'flask_test'>, client = <FlaskClient <Flask 'flask_test'>>\n\n    def test_add_template_filter_with_template(app, client):\n        bp = flask.Blueprint(\"bp\", __name__)\n    \n        def super_reverse(s):\n            return s[::-1]\n    \n        bp.add_app_template_filter(super_reverse)\n        app.register_blueprint(bp, url_prefix=\"/py\")\n    \n        @app.route(\"/\")\n        def index():\n            return flask.render_template(\"template_filter.html\", value=\"abcd\")\n    \n>       rv = client.get(\"/\")\n\ntests/test_blueprints.py:455: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n/opt/miniconda3/envs/testbed/lib/python3.9/site-packages/werkzeug/test.py:1243: in get\n    return self.open(*args, **kw)\nsrc/flask/testing.py:209: in open\n    builder = EnvironBuilder(self.application, *args, **kwargs)\nsrc/flask/testing.py:70: in __init__\n    url = url_parse(path)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nurl = '/', scheme = None, allow_fragments = True\n\n    def url_parse(\n        url: str, scheme: str | None = None, allow_fragments: bool = True\n    ) -> BaseURL:\n        \"\"\"Parses a URL from a string into a :class:`URL` tuple.  If the URL\n        is lacking a scheme it can be provided as second argument. Otherwise,\n        it is ignored.  Optionally fragments can be stripped from the URL\n        by setting `allow_fragments` to `False`.\n    \n        The inverse of this function is :func:`url_unparse`.\n    \n        :param url: the URL to parse.\n        :param scheme: the default schema to use if the URL is schemaless.\n        :param allow_fragments: if set to `False` a fragment will be removed\n                                from the URL.\n    \n        .. deprecated:: 2.3\n            Will be removed in Werkzeug 3.0. Use ``urllib.parse.urlsplit`` instead.\n        \"\"\"\n>       warnings.warn(\n            \"'werkzeug.urls.url_parse' is deprecated and will be removed in Werkzeug 3.0.\"\n            \" Use 'urllib.parse.urlsplit' instead.\",\n            DeprecationWarning,\n            stacklevel=2,\n        )\nE       DeprecationWarning: 'werkzeug.urls.url_parse' is deprecated and will be removed in Werkzeug 3.0. Use 'urllib.parse.urlsplit' instead.\n\n/opt/miniconda3/envs/testbed/lib/python3.9/site-packages/werkzeug/urls.py:505: DeprecationWarning\n_________________ test_template_filter_with_name_and_template __________________\n\napp = <Flask 'flask_test'>, client = <FlaskClient <Flask 'flask_test'>>\n\n    def test_template_filter_with_name_and_template(app, client):\n        bp = flask.Blueprint(\"bp\", __name__)\n    \n        @bp.app_template_filter(\"super_reverse\")\n        def my_reverse(s):\n            return s[::-1]\n    \n        app.register_blueprint(bp, url_prefix=\"/py\")\n    \n        @app.route(\"/\")\n        def index():\n            return flask.render_template(\"template_filter.html\", value=\"abcd\")\n    \n>       rv = client.get(\"/\")\n\ntests/test_blueprints.py:472: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n/opt/miniconda3/envs/testbed/lib/python3.9/site-packages/werkzeug/test.py:1243: in get\n    return self.open(*args, **kw)\nsrc/flask/testing.py:209: in open\n    builder = EnvironBuilder(self.application, *args, **kwargs)\nsrc/flask/testing.py:70: in __init__\n    url = url_parse(path)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nurl = '/', scheme = None, allow_fragments = True\n\n    def url_parse(\n        url: str, scheme: str | None = None, allow_fragments: bool = True\n    ) -> BaseURL:\n        \"\"\"Parses a URL from a string into a :class:`URL` tuple.  If the URL\n        is lacking a scheme it can be provided as second argument. Otherwise,\n        it is ignored.  Optionally fragments can be stripped from the URL\n        by setting `allow_fragments` to `False`.\n    \n        The inverse of this function is :func:`url_unparse`.\n    \n        :param url: the URL to parse.\n        :param scheme: the default schema to use if the URL is schemaless.\n        :param allow_fragments: if set to `False` a fragment will be removed\n                                from the URL.\n    \n        .. deprecated:: 2.3\n            Will be removed in Werkzeug 3.0. Use ``urllib.parse.urlsplit`` instead.\n        \"\"\"\n>       warnings.warn(\n            \"'werkzeug.urls.url_parse' is deprecated and will be removed in Werkzeug 3.0.\"\n            \" Use 'urllib.parse.urlsplit' instead.\",\n            DeprecationWarning,\n            stacklevel=2,\n        )\nE       DeprecationWarning: 'werkzeug.urls.url_parse' is deprecated and will be removed in Werkzeug 3.0. Use 'urllib.parse.urlsplit' instead.\n\n/opt/miniconda3/envs/testbed/lib/python3.9/site-packages/werkzeug/urls.py:505: DeprecationWarning\n_______________ test_add_template_filter_with_name_and_template ________________\n\napp = <Flask 'flask_test'>, client = <FlaskClient <Flask 'flask_test'>>\n\n    def test_add_template_filter_with_name_and_template(app, client):\n        bp = flask.Blueprint(\"bp\", __name__)\n    \n        def my_reverse(s):\n            return s[::-1]\n    \n        bp.add_app_template_filter(my_reverse, \"super_reverse\")\n        app.register_blueprint(bp, url_prefix=\"/py\")\n    \n        @app.route(\"/\")\n        def index():\n            return flask.render_template(\"template_filter.html\", value=\"abcd\")\n    \n>       rv = client.get(\"/\")\n\ntests/test_blueprints.py:489: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n/opt/miniconda3/envs/testbed/lib/python3.9/site-packages/werkzeug/test.py:1243: in get\n    return self.open(*args, **kw)\nsrc/flask/testing.py:209: in open\n    builder = EnvironBuilder(self.application, *args, **kwargs)\nsrc/flask/testing.py:70: in __init__\n    url = url_parse(path)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nurl = '/', scheme = None, allow_fragments = True\n\n    def url_parse(\n        url: str, scheme: str | None = None, allow_fragments: bool = True\n    ) -> BaseURL:\n        \"\"\"Parses a URL from a string into a :class:`URL` tuple.  If the URL\n        is lacking a scheme it can be provided as second argument. Otherwise,\n        it is ignored.  Optionally fragments can be stripped from the URL\n        by setting `allow_fragments` to `False`.\n    \n        The inverse of this function is :func:`url_unparse`.\n    \n        :param url: the URL to parse.\n        :param scheme: the default schema to use if the URL is schemaless.\n        :param allow_fragments: if set to `False` a fragment will be removed\n                                from the URL.\n    \n        .. deprecated:: 2.3\n            Will be removed in Werkzeug 3.0. Use ``urllib.parse.urlsplit`` instead.\n        \"\"\"\n>       warnings.warn(\n            \"'werkzeug.urls.url_parse' is deprecated and will be removed in Werkzeug 3.0.\"\n            \" Use 'urllib.parse.urlsplit' instead.\",\n            DeprecationWarning,\n            stacklevel=2,\n        )\nE       DeprecationWarning: 'werkzeug.urls.url_parse' is deprecated and will be removed in Werkzeug 3.0. Use 'urllib.parse.urlsplit' instead.\n\n/opt/miniconda3/envs/testbed/lib/python3.9/site-packages/werkzeug/urls.py:505: DeprecationWarning\n_______________________ test_template_test_with_template _______________________\n\napp = <Flask 'flask_test'>, client = <FlaskClient <Flask 'flask_test'>>\n\n    def test_template_test_with_template(app, client):\n        bp = flask.Blueprint(\"bp\", __name__)\n    \n        @bp.app_template_test()\n        def boolean(value):\n            return isinstance(value, bool)\n    \n        app.register_blueprint(bp, url_prefix=\"/py\")\n    \n        @app.route(\"/\")\n        def index():\n            return flask.render_template(\"template_test.html\", value=False)\n    \n>       rv = client.get(\"/\")\n\ntests/test_blueprints.py:558: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n/opt/miniconda3/envs/testbed/lib/python3.9/site-packages/werkzeug/test.py:1243: in get\n    return self.open(*args, **kw)\nsrc/flask/testing.py:209: in open\n    builder = EnvironBuilder(self.application, *args, **kwargs)\nsrc/flask/testing.py:70: in __init__\n    url = url_parse(path)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nurl = '/', scheme = None, allow_fragments = True\n\n    def url_parse(\n        url: str, scheme: str | None = None, allow_fragments: bool = True\n    ) -> BaseURL:\n        \"\"\"Parses a URL from a string into a :class:`URL` tuple.  If the URL\n        is lacking a scheme it can be provided as second argument. Otherwise,\n        it is ignored.  Optionally fragments can be stripped from the URL\n        by setting `allow_fragments` to `False`.\n    \n        The inverse of this function is :func:`url_unparse`.\n    \n        :param url: the URL to parse.\n        :param scheme: the default schema to use if the URL is schemaless.\n        :param allow_fragments: if set to `False` a fragment will be removed\n                                from the URL.\n    \n        .. deprecated:: 2.3\n            Will be removed in Werkzeug 3.0. Use ``urllib.parse.urlsplit`` instead.\n        \"\"\"\n>       warnings.warn(\n            \"'werkzeug.urls.url_parse' is deprecated and will be removed in Werkzeug 3.0.\"\n            \" Use 'urllib.parse.urlsplit' instead.\",\n            DeprecationWarning,\n            stacklevel=2,\n        )\nE       DeprecationWarning: 'werkzeug.urls.url_parse' is deprecated and will be removed in Werkzeug 3.0. Use 'urllib.parse.urlsplit' instead.\n\n/opt/miniconda3/envs/testbed/lib/python3.9/site-packages/werkzeug/urls.py:505: DeprecationWarning\n_________________ test_template_test_after_route_with_template _________________\n\napp = <Flask 'flask_test'>, client = <FlaskClient <Flask 'flask_test'>>\n\n    def test_template_test_after_route_with_template(app, client):\n        @app.route(\"/\")\n        def index():\n            return flask.render_template(\"template_test.html\", value=False)\n    \n        bp = flask.Blueprint(\"bp\", __name__)\n    \n        @bp.app_template_test()\n        def boolean(value):\n            return isinstance(value, bool)\n    \n        app.register_blueprint(bp, url_prefix=\"/py\")\n>       rv = client.get(\"/\")\n\ntests/test_blueprints.py:574: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n/opt/miniconda3/envs/testbed/lib/python3.9/site-packages/werkzeug/test.py:1243: in get\n    return self.open(*args, **kw)\nsrc/flask/testing.py:209: in open\n    builder = EnvironBuilder(self.application, *args, **kwargs)\nsrc/flask/testing.py:70: in __init__\n    url = url_parse(path)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nurl = '/', scheme = None, allow_fragments = True\n\n    def url_parse(\n        url: str, scheme: str | None = None, allow_fragments: bool = True\n    ) -> BaseURL:\n        \"\"\"Parses a URL from a string into a :class:`URL` tuple.  If the URL\n        is lacking a scheme it can be provided as second argument. Otherwise,\n        it is ignored.  Optionally fragments can be stripped from the URL\n        by setting `allow_fragments` to `False`.\n    \n        The inverse of this function is :func:`url_unparse`.\n    \n        :param url: the URL to parse.\n        :param scheme: the default schema to use if the URL is schemaless.\n        :param allow_fragments: if set to `False` a fragment will be removed\n                                from the URL.\n    \n        .. deprecated:: 2.3\n            Will be removed in Werkzeug 3.0. Use ``urllib.parse.urlsplit`` instead.\n        \"\"\"\n>       warnings.warn(\n            \"'werkzeug.urls.url_parse' is deprecated and will be removed in Werkzeug 3.0.\"\n            \" Use 'urllib.parse.urlsplit' instead.\",\n            DeprecationWarning,\n            stacklevel=2,\n        )\nE       DeprecationWarning: 'werkzeug.urls.url_parse' is deprecated and will be removed in Werkzeug 3.0. Use 'urllib.parse.urlsplit' instead.\n\n/opt/miniconda3/envs/testbed/lib/python3.9/site-packages/werkzeug/urls.py:505: DeprecationWarning\n_____________________ test_add_template_test_with_template _____________________\n\napp = <Flask 'flask_test'>, client = <FlaskClient <Flask 'flask_test'>>\n\n    def test_add_template_test_with_template(app, client):\n        bp = flask.Blueprint(\"bp\", __name__)\n    \n        def boolean(value):\n            return isinstance(value, bool)\n    \n        bp.add_app_template_test(boolean)\n        app.register_blueprint(bp, url_prefix=\"/py\")\n    \n        @app.route(\"/\")\n        def index():\n            return flask.render_template(\"template_test.html\", value=False)\n    \n>       rv = client.get(\"/\")\n\ntests/test_blueprints.py:591: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n/opt/miniconda3/envs/testbed/lib/python3.9/site-packages/werkzeug/test.py:1243: in get\n    return self.open(*args, **kw)\nsrc/flask/testing.py:209: in open\n    builder = EnvironBuilder(self.application, *args, **kwargs)\nsrc/flask/testing.py:70: in __init__\n    url = url_parse(path)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nurl = '/', scheme = None, allow_fragments = True\n\n    def url_parse(\n        url: str, scheme: str | None = None, allow_fragments: bool = True\n    ) -> BaseURL:\n        \"\"\"Parses a URL from a string into a :class:`URL` tuple.  If the URL\n        is lacking a scheme it can be provided as second argument. Otherwise,\n        it is ignored.  Optionally fragments can be stripped from the URL\n        by setting `allow_fragments` to `False`.\n    \n        The inverse of this function is :func:`url_unparse`.\n    \n        :param url: the URL to parse.\n        :param scheme: the default schema to use if the URL is schemaless.\n        :param allow_fragments: if set to `False` a fragment will be removed\n                                from the URL.\n    \n        .. deprecated:: 2.3\n            Will be removed in Werkzeug 3.0. Use ``urllib.parse.urlsplit`` instead.\n        \"\"\"\n>       warnings.warn(\n            \"'werkzeug.urls.url_parse' is deprecated and will be removed in Werkzeug 3.0.\"\n            \" Use 'urllib.parse.urlsplit' instead.\",\n            DeprecationWarning,\n            stacklevel=2,\n        )\nE       DeprecationWarning: 'werkzeug.urls.url_parse' is deprecated and will be removed in Werkzeug 3.0. Use 'urllib.parse.urlsplit' instead.\n\n/opt/miniconda3/envs/testbed/lib/python3.9/site-packages/werkzeug/urls.py:505: DeprecationWarning\n__________________ test_template_test_with_name_and_template ___________________\n\napp = <Flask 'flask_test'>, client = <FlaskClient <Flask 'flask_test'>>\n\n    def test_template_test_with_name_and_template(app, client):\n        bp = flask.Blueprint(\"bp\", __name__)\n    \n        @bp.app_template_test(\"boolean\")\n        def is_boolean(value):\n            return isinstance(value, bool)\n    \n        app.register_blueprint(bp, url_prefix=\"/py\")\n    \n        @app.route(\"/\")\n        def index():\n            return flask.render_template(\"template_test.html\", value=False)\n    \n>       rv = client.get(\"/\")\n\ntests/test_blueprints.py:608: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n/opt/miniconda3/envs/testbed/lib/python3.9/site-packages/werkzeug/test.py:1243: in get\n    return self.open(*args, **kw)\nsrc/flask/testing.py:209: in open\n    builder = EnvironBuilder(self.application, *args, **kwargs)\nsrc/flask/testing.py:70: in __init__\n    url = url_parse(path)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nurl = '/', scheme = None, allow_fragments = True\n\n    def url_parse(\n        url: str, scheme: str | None = None, allow_fragments: bool = True\n    ) -> BaseURL:\n        \"\"\"Parses a URL from a string into a :class:`URL` tuple.  If the URL\n        is lacking a scheme it can be provided as second argument. Otherwise,\n        it is ignored.  Optionally fragments can be stripped from the URL\n        by setting `allow_fragments` to `False`.\n    \n        The inverse of this function is :func:`url_unparse`.\n    \n        :param url: the URL to parse.\n        :param scheme: the default schema to use if the URL is schemaless.\n        :param allow_fragments: if set to `False` a fragment will be removed\n                                from the URL.\n    \n        .. deprecated:: 2.3\n            Will be removed in Werkzeug 3.0. Use ``urllib.parse.urlsplit`` instead.\n        \"\"\"\n>       warnings.warn(\n            \"'werkzeug.urls.url_parse' is deprecated and will be removed in Werkzeug 3.0.\"\n            \" Use 'urllib.parse.urlsplit' instead.\",\n            DeprecationWarning,\n            stacklevel=2,\n        )\nE       DeprecationWarning: 'werkzeug.urls.url_parse' is deprecated and will be removed in Werkzeug 3.0. Use 'urllib.parse.urlsplit' instead.\n\n/opt/miniconda3/envs/testbed/lib/python3.9/site-packages/werkzeug/urls.py:505: DeprecationWarning\n________________ test_add_template_test_with_name_and_template _________________\n\napp = <Flask 'flask_test'>, client = <FlaskClient <Flask 'flask_test'>>\n\n    def test_add_template_test_with_name_and_template(app, client):\n        bp = flask.Blueprint(\"bp\", __name__)\n    \n        def is_boolean(value):\n            return isinstance(value, bool)\n    \n        bp.add_app_template_test(is_boolean, \"boolean\")\n        app.register_blueprint(bp, url_prefix=\"/py\")\n    \n        @app.route(\"/\")\n        def index():\n            return flask.render_template(\"template_test.html\", value=False)\n    \n>       rv = client.get(\"/\")\n\ntests/test_blueprints.py:625: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n/opt/miniconda3/envs/testbed/lib/python3.9/site-packages/werkzeug/test.py:1243: in get\n    return self.open(*args, **kw)\nsrc/flask/testing.py:209: in open\n    builder = EnvironBuilder(self.application, *args, **kwargs)\nsrc/flask/testing.py:70: in __init__\n    url = url_parse(path)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nurl = '/', scheme = None, allow_fragments = True\n\n    def url_parse(\n        url: str, scheme: str | None = None, allow_fragments: bool = True\n    ) -> BaseURL:\n        \"\"\"Parses a URL from a string into a :class:`URL` tuple.  If the URL\n        is lacking a scheme it can be provided as second argument. Otherwise,\n        it is ignored.  Optionally fragments can be stripped from the URL\n        by setting `allow_fragments` to `False`.\n    \n        The inverse of this function is :func:`url_unparse`.\n    \n        :param url: the URL to parse.\n        :param scheme: the default schema to use if the URL is schemaless.\n        :param allow_fragments: if set to `False` a fragment will be removed\n                                from the URL.\n    \n        .. deprecated:: 2.3\n            Will be removed in Werkzeug 3.0. Use ``urllib.parse.urlsplit`` instead.\n        \"\"\"\n>       warnings.warn(\n            \"'werkzeug.urls.url_parse' is deprecated and will be removed in Werkzeug 3.0.\"\n            \" Use 'urllib.parse.urlsplit' instead.\",\n            DeprecationWarning,\n            stacklevel=2,\n        )\nE       DeprecationWarning: 'werkzeug.urls.url_parse' is deprecated and will be removed in Werkzeug 3.0. Use 'urllib.parse.urlsplit' instead.\n\n/opt/miniconda3/envs/testbed/lib/python3.9/site-packages/werkzeug/urls.py:505: DeprecationWarning\n___________________________ test_context_processing ____________________________\n\napp = <Flask 'flask_test'>, client = <FlaskClient <Flask 'flask_test'>>\n\n    def test_context_processing(app, client):\n        answer_bp = flask.Blueprint(\"answer_bp\", __name__)\n    \n        template_string = lambda: flask.render_template_string(  # noqa: E731\n            \"{% if notanswer %}{{ notanswer }} is not the answer. {% endif %}\"\n            \"{% if answer %}{{ answer }} is the answer.{% endif %}\"\n        )\n    \n        # App global context processor\n        @answer_bp.app_context_processor\n        def not_answer_context_processor():\n            return {\"notanswer\": 43}\n    \n        # Blueprint local context processor\n        @answer_bp.context_processor\n        def answer_context_processor():\n            return {\"answer\": 42}\n    \n        # Setup endpoints for testing\n        @answer_bp.route(\"/bp\")\n        def bp_page():\n            return template_string()\n    \n        @app.route(\"/\")\n        def app_page():\n            return template_string()\n    \n        # Register the blueprint\n        app.register_blueprint(answer_bp)\n    \n>       app_page_bytes = client.get(\"/\").data\n\ntests/test_blueprints.py:659: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n/opt/miniconda3/envs/testbed/lib/python3.9/site-packages/werkzeug/test.py:1243: in get\n    return self.open(*args, **kw)\nsrc/flask/testing.py:209: in open\n    builder = EnvironBuilder(self.application, *args, **kwargs)\nsrc/flask/testing.py:70: in __init__\n    url = url_parse(path)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nurl = '/', scheme = None, allow_fragments = True\n\n    def url_parse(\n        url: str, scheme: str | None = None, allow_fragments: bool = True\n    ) -> BaseURL:\n        \"\"\"Parses a URL from a string into a :class:`URL` tuple.  If the URL\n        is lacking a scheme it can be provided as second argument. Otherwise,\n        it is ignored.  Optionally fragments can be stripped from the URL\n        by setting `allow_fragments` to `False`.\n    \n        The inverse of this function is :func:`url_unparse`.\n    \n        :param url: the URL to parse.\n        :param scheme: the default schema to use if the URL is schemaless.\n        :param allow_fragments: if set to `False` a fragment will be removed\n                                from the URL.\n    \n        .. deprecated:: 2.3\n            Will be removed in Werkzeug 3.0. Use ``urllib.parse.urlsplit`` instead.\n        \"\"\"\n>       warnings.warn(\n            \"'werkzeug.urls.url_parse' is deprecated and will be removed in Werkzeug 3.0.\"\n            \" Use 'urllib.parse.urlsplit' instead.\",\n            DeprecationWarning,\n            stacklevel=2,\n        )\nE       DeprecationWarning: 'werkzeug.urls.url_parse' is deprecated and will be removed in Werkzeug 3.0. Use 'urllib.parse.urlsplit' instead.\n\n/opt/miniconda3/envs/testbed/lib/python3.9/site-packages/werkzeug/urls.py:505: DeprecationWarning\n___________________________ test_request_processing ____________________________\n\napp = <Flask 'flask_test'>, client = <FlaskClient <Flask 'flask_test'>>\n\n    def test_request_processing(app, client):\n        bp = flask.Blueprint(\"bp\", __name__)\n        evts = []\n    \n        @bp.before_request\n        def before_bp():\n            evts.append(\"before\")\n    \n        @bp.after_request\n        def after_bp(response):\n            response.data += b\"|after\"\n            evts.append(\"after\")\n            return response\n    \n        @bp.teardown_request\n        def teardown_bp(exc):\n            evts.append(\"teardown\")\n    \n        # Setup routes for testing\n        @bp.route(\"/bp\")\n        def bp_endpoint():\n            return \"request\"\n    \n        app.register_blueprint(bp)\n    \n        assert evts == []\n>       rv = client.get(\"/bp\")\n\ntests/test_blueprints.py:716: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n/opt/miniconda3/envs/testbed/lib/python3.9/site-packages/werkzeug/test.py:1243: in get\n    return self.open(*args, **kw)\nsrc/flask/testing.py:209: in open\n    builder = EnvironBuilder(self.application, *args, **kwargs)\nsrc/flask/testing.py:70: in __init__\n    url = url_parse(path)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nurl = '/bp', scheme = None, allow_fragments = True\n\n    def url_parse(\n        url: str, scheme: str | None = None, allow_fragments: bool = True\n    ) -> BaseURL:\n        \"\"\"Parses a URL from a string into a :class:`URL` tuple.  If the URL\n        is lacking a scheme it can be provided as second argument. Otherwise,\n        it is ignored.  Optionally fragments can be stripped from the URL\n        by setting `allow_fragments` to `False`.\n    \n        The inverse of this function is :func:`url_unparse`.\n    \n        :param url: the URL to parse.\n        :param scheme: the default schema to use if the URL is schemaless.\n        :param allow_fragments: if set to `False` a fragment will be removed\n                                from the URL.\n    \n        .. deprecated:: 2.3\n            Will be removed in Werkzeug 3.0. Use ``urllib.parse.urlsplit`` instead.\n        \"\"\"\n>       warnings.warn(\n            \"'werkzeug.urls.url_parse' is deprecated and will be removed in Werkzeug 3.0.\"\n            \" Use 'urllib.parse.urlsplit' instead.\",\n            DeprecationWarning,\n            stacklevel=2,\n        )\nE       DeprecationWarning: 'werkzeug.urls.url_parse' is deprecated and will be removed in Werkzeug 3.0. Use 'urllib.parse.urlsplit' instead.\n\n/opt/miniconda3/envs/testbed/lib/python3.9/site-packages/werkzeug/urls.py:505: DeprecationWarning\n_________________________ test_app_request_processing __________________________\n\napp = <Flask 'flask_test'>, client = <FlaskClient <Flask 'flask_test'>>\n\n    def test_app_request_processing(app, client):\n        bp = flask.Blueprint(\"bp\", __name__)\n        evts = []\n    \n        @bp.before_app_first_request\n        def before_first_request():\n            evts.append(\"first\")\n    \n        @bp.before_app_request\n        def before_app():\n            evts.append(\"before\")\n    \n        @bp.after_app_request\n        def after_app(response):\n            response.data += b\"|after\"\n            evts.append(\"after\")\n            return response\n    \n        @bp.teardown_app_request\n        def teardown_app(exc):\n            evts.append(\"teardown\")\n    \n        app.register_blueprint(bp)\n    \n        # Setup routes for testing\n        @app.route(\"/\")\n        def bp_endpoint():\n            return \"request\"\n    \n        # before first request\n        assert evts == []\n    \n        # first request\n>       resp = client.get(\"/\").data\n\ntests/test_blueprints.py:754: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n/opt/miniconda3/envs/testbed/lib/python3.9/site-packages/werkzeug/test.py:1243: in get\n    return self.open(*args, **kw)\nsrc/flask/testing.py:209: in open\n    builder = EnvironBuilder(self.application, *args, **kwargs)\nsrc/flask/testing.py:70: in __init__\n    url = url_parse(path)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nurl = '/', scheme = None, allow_fragments = True\n\n    def url_parse(\n        url: str, scheme: str | None = None, allow_fragments: bool = True\n    ) -> BaseURL:\n        \"\"\"Parses a URL from a string into a :class:`URL` tuple.  If the URL\n        is lacking a scheme it can be provided as second argument. Otherwise,\n        it is ignored.  Optionally fragments can be stripped from the URL\n        by setting `allow_fragments` to `False`.\n    \n        The inverse of this function is :func:`url_unparse`.\n    \n        :param url: the URL to parse.\n        :param scheme: the default schema to use if the URL is schemaless.\n        :param allow_fragments: if set to `False` a fragment will be removed\n                                from the URL.\n    \n        .. deprecated:: 2.3\n            Will be removed in Werkzeug 3.0. Use ``urllib.parse.urlsplit`` instead.\n        \"\"\"\n>       warnings.warn(\n            \"'werkzeug.urls.url_parse' is deprecated and will be removed in Werkzeug 3.0.\"\n            \" Use 'urllib.parse.urlsplit' instead.\",\n            DeprecationWarning,\n            stacklevel=2,\n        )\nE       DeprecationWarning: 'werkzeug.urls.url_parse' is deprecated and will be removed in Werkzeug 3.0. Use 'urllib.parse.urlsplit' instead.\n\n/opt/miniconda3/envs/testbed/lib/python3.9/site-packages/werkzeug/urls.py:505: DeprecationWarning\n___________________________ test_app_url_processors ____________________________\n\napp = <Flask 'flask_test'>, client = <FlaskClient <Flask 'flask_test'>>\n\n    def test_app_url_processors(app, client):\n        bp = flask.Blueprint(\"bp\", __name__)\n    \n        # Register app-wide url defaults and preprocessor on blueprint\n        @bp.app_url_defaults\n        def add_language_code(endpoint, values):\n            values.setdefault(\"lang_code\", flask.g.lang_code)\n    \n        @bp.app_url_value_preprocessor\n        def pull_lang_code(endpoint, values):\n            flask.g.lang_code = values.pop(\"lang_code\")\n    \n        # Register route rules at the app level\n        @app.route(\"/<lang_code>/\")\n        def index():\n            return flask.url_for(\"about\")\n    \n        @app.route(\"/<lang_code>/about\")\n        def about():\n            return flask.url_for(\"index\")\n    \n        app.register_blueprint(bp)\n    \n>       assert client.get(\"/de/\").data == b\"/de/about\"\n\ntests/test_blueprints.py:787: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n/opt/miniconda3/envs/testbed/lib/python3.9/site-packages/werkzeug/test.py:1243: in get\n    return self.open(*args, **kw)\nsrc/flask/testing.py:209: in open\n    builder = EnvironBuilder(self.application, *args, **kwargs)\nsrc/flask/testing.py:70: in __init__\n    url = url_parse(path)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nurl = '/de/', scheme = None, allow_fragments = True\n\n    def url_parse(\n        url: str, scheme: str | None = None, allow_fragments: bool = True\n    ) -> BaseURL:\n        \"\"\"Parses a URL from a string into a :class:`URL` tuple.  If the URL\n        is lacking a scheme it can be provided as second argument. Otherwise,\n        it is ignored.  Optionally fragments can be stripped from the URL\n        by setting `allow_fragments` to `False`.\n    \n        The inverse of this function is :func:`url_unparse`.\n    \n        :param url: the URL to parse.\n        :param scheme: the default schema to use if the URL is schemaless.\n        :param allow_fragments: if set to `False` a fragment will be removed\n                                from the URL.\n    \n        .. deprecated:: 2.3\n            Will be removed in Werkzeug 3.0. Use ``urllib.parse.urlsplit`` instead.\n        \"\"\"\n>       warnings.warn(\n            \"'werkzeug.urls.url_parse' is deprecated and will be removed in Werkzeug 3.0.\"\n            \" Use 'urllib.parse.urlsplit' instead.\",\n            DeprecationWarning,\n            stacklevel=2,\n        )\nE       DeprecationWarning: 'werkzeug.urls.url_parse' is deprecated and will be removed in Werkzeug 3.0. Use 'urllib.parse.urlsplit' instead.\n\n/opt/miniconda3/envs/testbed/lib/python3.9/site-packages/werkzeug/urls.py:505: DeprecationWarning\n____________________________ test_nested_blueprint _____________________________\n\napp = <Flask 'flask_test'>, client = <FlaskClient <Flask 'flask_test'>>\n\n    def test_nested_blueprint(app, client):\n        parent = flask.Blueprint(\"parent\", __name__)\n        child = flask.Blueprint(\"child\", __name__)\n        grandchild = flask.Blueprint(\"grandchild\", __name__)\n    \n        @parent.errorhandler(403)\n        def forbidden(e):\n            return \"Parent no\", 403\n    \n        @parent.route(\"/\")\n        def parent_index():\n            return \"Parent yes\"\n    \n        @parent.route(\"/no\")\n        def parent_no():\n            flask.abort(403)\n    \n        @child.route(\"/\")\n        def child_index():\n            return \"Child yes\"\n    \n        @child.route(\"/no\")\n        def child_no():\n            flask.abort(403)\n    \n        @grandchild.errorhandler(403)\n        def grandchild_forbidden(e):\n            return \"Grandchild no\", 403\n    \n        @grandchild.route(\"/\")\n        def grandchild_index():\n            return \"Grandchild yes\"\n    \n        @grandchild.route(\"/no\")\n        def grandchild_no():\n            flask.abort(403)\n    \n        child.register_blueprint(grandchild, url_prefix=\"/grandchild\")\n        parent.register_blueprint(child, url_prefix=\"/child\")\n        app.register_blueprint(parent, url_prefix=\"/parent\")\n    \n>       assert client.get(\"/parent/\").data == b\"Parent yes\"\n\ntests/test_blueprints.py:832: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n/opt/miniconda3/envs/testbed/lib/python3.9/site-packages/werkzeug/test.py:1243: in get\n    return self.open(*args, **kw)\nsrc/flask/testing.py:209: in open\n    builder = EnvironBuilder(self.application, *args, **kwargs)\nsrc/flask/testing.py:70: in __init__\n    url = url_parse(path)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nurl = '/parent/', scheme = None, allow_fragments = True\n\n    def url_parse(\n        url: str, scheme: str | None = None, allow_fragments: bool = True\n    ) -> BaseURL:\n        \"\"\"Parses a URL from a string into a :class:`URL` tuple.  If the URL\n        is lacking a scheme it can be provided as second argument. Otherwise,\n        it is ignored.  Optionally fragments can be stripped from the URL\n        by setting `allow_fragments` to `False`.\n    \n        The inverse of this function is :func:`url_unparse`.\n    \n        :param url: the URL to parse.\n        :param scheme: the default schema to use if the URL is schemaless.\n        :param allow_fragments: if set to `False` a fragment will be removed\n                                from the URL.\n    \n        .. deprecated:: 2.3\n            Will be removed in Werkzeug 3.0. Use ``urllib.parse.urlsplit`` instead.\n        \"\"\"\n>       warnings.warn(\n            \"'werkzeug.urls.url_parse' is deprecated and will be removed in Werkzeug 3.0.\"\n            \" Use 'urllib.parse.urlsplit' instead.\",\n            DeprecationWarning,\n            stacklevel=2,\n        )\nE       DeprecationWarning: 'werkzeug.urls.url_parse' is deprecated and will be removed in Werkzeug 3.0. Use 'urllib.parse.urlsplit' instead.\n\n/opt/miniconda3/envs/testbed/lib/python3.9/site-packages/werkzeug/urls.py:505: DeprecationWarning\n==================================== PASSES ====================================\n____________ test_werkzeug_passthrough_errors[None-True-True-True] _____________\n----------------------------- Captured stdout call -----------------------------\n * Serving Flask app 'flask_test' (lazy loading)\n * Environment: production\n   WARNING: This is a development server. Do not use it in a production deployment.\n   Use a production WSGI server instead.\n * Debug mode: on\n____________ test_werkzeug_passthrough_errors[None-True-True-False] ____________\n----------------------------- Captured stdout call -----------------------------\n * Serving Flask app 'flask_test' (lazy loading)\n * Environment: production\n   WARNING: This is a development server. Do not use it in a production deployment.\n   Use a production WSGI server instead.\n * Debug mode: off\n____________ test_werkzeug_passthrough_errors[None-True-False-True] ____________\n----------------------------- Captured stdout call -----------------------------\n * Serving Flask app 'flask_test' (lazy loading)\n * Environment: production\n   WARNING: This is a development server. Do not use it in a production deployment.\n   Use a production WSGI server instead.\n * Debug mode: on\n___________ test_werkzeug_passthrough_errors[None-True-False-False] ____________\n----------------------------- Captured stdout call -----------------------------\n * Serving Flask app 'flask_test' (lazy loading)\n * Environment: production\n   WARNING: This is a development server. Do not use it in a production deployment.\n   Use a production WSGI server instead.\n * Debug mode: off\n____________ test_werkzeug_passthrough_errors[None-False-True-True] ____________\n----------------------------- Captured stdout call -----------------------------\n * Serving Flask app 'flask_test' (lazy loading)\n * Environment: production\n   WARNING: This is a development server. Do not use it in a production deployment.\n   Use a production WSGI server instead.\n * Debug mode: on\n___________ test_werkzeug_passthrough_errors[None-False-True-False] ____________\n----------------------------- Captured stdout call -----------------------------\n * Serving Flask app 'flask_test' (lazy loading)\n * Environment: production\n   WARNING: This is a development server. Do not use it in a production deployment.\n   Use a production WSGI server instead.\n * Debug mode: off\n___________ test_werkzeug_passthrough_errors[None-False-False-True] ____________\n----------------------------- Captured stdout call -----------------------------\n * Serving Flask app 'flask_test' (lazy loading)\n * Environment: production\n   WARNING: This is a development server. Do not use it in a production deployment.\n   Use a production WSGI server instead.\n * Debug mode: on\n___________ test_werkzeug_passthrough_errors[None-False-False-False] ___________\n----------------------------- Captured stdout call -----------------------------\n * Serving Flask app 'flask_test' (lazy loading)\n * Environment: production\n   WARNING: This is a development server. Do not use it in a production deployment.\n   Use a production WSGI server instead.\n * Debug mode: off\n____________ test_werkzeug_passthrough_errors[True-True-True-True] _____________\n----------------------------- Captured stdout call -----------------------------\n * Serving Flask app 'flask_test' (lazy loading)\n * Environment: production\n   WARNING: This is a development server. Do not use it in a production deployment.\n   Use a production WSGI server instead.\n * Debug mode: on\n____________ test_werkzeug_passthrough_errors[True-True-True-False] ____________\n----------------------------- Captured stdout call -----------------------------\n * Serving Flask app 'flask_test' (lazy loading)\n * Environment: production\n   WARNING: This is a development server. Do not use it in a production deployment.\n   Use a production WSGI server instead.\n * Debug mode: off\n____________ test_werkzeug_passthrough_errors[True-True-False-True] ____________\n----------------------------- Captured stdout call -----------------------------\n * Serving Flask app 'flask_test' (lazy loading)\n * Environment: production\n   WARNING: This is a development server. Do not use it in a production deployment.\n   Use a production WSGI server instead.\n * Debug mode: on\n___________ test_werkzeug_passthrough_errors[True-True-False-False] ____________\n----------------------------- Captured stdout call -----------------------------\n * Serving Flask app 'flask_test' (lazy loading)\n * Environment: production\n   WARNING: This is a development server. Do not use it in a production deployment.\n   Use a production WSGI server instead.\n * Debug mode: off\n____________ test_werkzeug_passthrough_errors[True-False-True-True] ____________\n----------------------------- Captured stdout call -----------------------------\n * Serving Flask app 'flask_test' (lazy loading)\n * Environment: production\n   WARNING: This is a development server. Do not use it in a production deployment.\n   Use a production WSGI server instead.\n * Debug mode: on\n___________ test_werkzeug_passthrough_errors[True-False-True-False] ____________\n----------------------------- Captured stdout call -----------------------------\n * Serving Flask app 'flask_test' (lazy loading)\n * Environment: production\n   WARNING: This is a development server. Do not use it in a production deployment.\n   Use a production WSGI server instead.\n * Debug mode: off\n___________ test_werkzeug_passthrough_errors[True-False-False-True] ____________\n----------------------------- Captured stdout call -----------------------------\n * Serving Flask app 'flask_test' (lazy loading)\n * Environment: production\n   WARNING: This is a development server. Do not use it in a production deployment.\n   Use a production WSGI server instead.\n * Debug mode: on\n___________ test_werkzeug_passthrough_errors[True-False-False-False] ___________\n----------------------------- Captured stdout call -----------------------------\n * Serving Flask app 'flask_test' (lazy loading)\n * Environment: production\n   WARNING: This is a development server. Do not use it in a production deployment.\n   Use a production WSGI server instead.\n * Debug mode: off\n____________ test_werkzeug_passthrough_errors[False-True-True-True] ____________\n----------------------------- Captured stdout call -----------------------------\n * Serving Flask app 'flask_test' (lazy loading)\n * Environment: production\n   WARNING: This is a development server. Do not use it in a production deployment.\n   Use a production WSGI server instead.\n * Debug mode: on\n___________ test_werkzeug_passthrough_errors[False-True-True-False] ____________\n----------------------------- Captured stdout call -----------------------------\n * Serving Flask app 'flask_test' (lazy loading)\n * Environment: production\n   WARNING: This is a development server. Do not use it in a production deployment.\n   Use a production WSGI server instead.\n * Debug mode: off\n___________ test_werkzeug_passthrough_errors[False-True-False-True] ____________\n----------------------------- Captured stdout call -----------------------------\n * Serving Flask app 'flask_test' (lazy loading)\n * Environment: production\n   WARNING: This is a development server. Do not use it in a production deployment.\n   Use a production WSGI server instead.\n * Debug mode: on\n___________ test_werkzeug_passthrough_errors[False-True-False-False] ___________\n----------------------------- Captured stdout call -----------------------------\n * Serving Flask app 'flask_test' (lazy loading)\n * Environment: production\n   WARNING: This is a development server. Do not use it in a production deployment.\n   Use a production WSGI server instead.\n * Debug mode: off\n___________ test_werkzeug_passthrough_errors[False-False-True-True] ____________\n----------------------------- Captured stdout call -----------------------------\n * Serving Flask app 'flask_test' (lazy loading)\n * Environment: production\n   WARNING: This is a development server. Do not use it in a production deployment.\n   Use a production WSGI server instead.\n * Debug mode: on\n___________ test_werkzeug_passthrough_errors[False-False-True-False] ___________\n----------------------------- Captured stdout call -----------------------------\n * Serving Flask app 'flask_test' (lazy loading)\n * Environment: production\n   WARNING: This is a development server. Do not use it in a production deployment.\n   Use a production WSGI server instead.\n * Debug mode: off\n___________ test_werkzeug_passthrough_errors[False-False-False-True] ___________\n----------------------------- Captured stdout call -----------------------------\n * Serving Flask app 'flask_test' (lazy loading)\n * Environment: production\n   WARNING: This is a development server. Do not use it in a production deployment.\n   Use a production WSGI server instead.\n * Debug mode: on\n__________ test_werkzeug_passthrough_errors[False-False-False-False] ___________\n----------------------------- Captured stdout call -----------------------------\n * Serving Flask app 'flask_test' (lazy loading)\n * Environment: production\n   WARNING: This is a development server. Do not use it in a production deployment.\n   Use a production WSGI server instead.\n * Debug mode: off\n______________________________ test_run_defaults _______________________________\n----------------------------- Captured stdout call -----------------------------\n * Serving Flask app 'flask_test' (lazy loading)\n * Environment: production\n   WARNING: This is a development server. Do not use it in a production deployment.\n   Use a production WSGI server instead.\n * Debug mode: off\n_____________________________ test_run_server_port _____________________________\n----------------------------- Captured stdout call -----------------------------\n * Serving Flask app 'flask_test' (lazy loading)\n * Environment: production\n   WARNING: This is a development server. Do not use it in a production deployment.\n   Use a production WSGI server instead.\n * Debug mode: on\n________ test_run_from_config[None-None-pocoo.org:8080-pocoo.org-8080] _________\n----------------------------- Captured stdout call -----------------------------\n * Serving Flask app 'flask_test' (lazy loading)\n * Environment: production\n   WARNING: This is a development server. Do not use it in a production deployment.\n   Use a production WSGI server instead.\n * Debug mode: off\n______ test_run_from_config[localhost-None-pocoo.org:8080-localhost-8080] ______\n----------------------------- Captured stdout call -----------------------------\n * Serving Flask app 'flask_test' (lazy loading)\n * Environment: production\n   WARNING: This is a development server. Do not use it in a production deployment.\n   Use a production WSGI server instead.\n * Debug mode: off\n__________ test_run_from_config[None-80-pocoo.org:8080-pocoo.org-80] ___________\n----------------------------- Captured stdout call -----------------------------\n * Serving Flask app 'flask_test' (lazy loading)\n * Environment: production\n   WARNING: This is a development server. Do not use it in a production deployment.\n   Use a production WSGI server instead.\n * Debug mode: off\n________ test_run_from_config[localhost-80-pocoo.org:8080-localhost-80] ________\n----------------------------- Captured stdout call -----------------------------\n * Serving Flask app 'flask_test' (lazy loading)\n * Environment: production\n   WARNING: This is a development server. Do not use it in a production deployment.\n   Use a production WSGI server instead.\n * Debug mode: off\n_________ test_run_from_config[localhost-0-localhost:8080-localhost-0] _________\n----------------------------- Captured stdout call -----------------------------\n * Serving Flask app 'flask_test' (lazy loading)\n * Environment: production\n   WARNING: This is a development server. Do not use it in a production deployment.\n   Use a production WSGI server instead.\n * Debug mode: off\n________ test_run_from_config[None-None-localhost:8080-localhost-8080] _________\n----------------------------- Captured stdout call -----------------------------\n * Serving Flask app 'flask_test' (lazy loading)\n * Environment: production\n   WARNING: This is a development server. Do not use it in a production deployment.\n   Use a production WSGI server instead.\n * Debug mode: off\n___________ test_run_from_config[None-None-localhost:0-localhost-0] ____________\n----------------------------- Captured stdout call -----------------------------\n * Serving Flask app 'flask_test' (lazy loading)\n * Environment: production\n   WARNING: This is a development server. Do not use it in a production deployment.\n   Use a production WSGI server instead.\n * Debug mode: off\n=========================== short test summary info ============================\nPASSED tests/test_basic.py::test_method_route_no_methods\nPASSED tests/test_basic.py::test_disallow_string_for_allowed_methods\nPASSED tests/test_basic.py::test_error_handler_unknown_code\nPASSED tests/test_basic.py::test_request_locals\nPASSED tests/test_basic.py::test_exception_propagation\nPASSED tests/test_basic.py::test_werkzeug_passthrough_errors[None-True-True-True]\nPASSED tests/test_basic.py::test_werkzeug_passthrough_errors[None-True-True-False]\nPASSED tests/test_basic.py::test_werkzeug_passthrough_errors[None-True-False-True]\nPASSED tests/test_basic.py::test_werkzeug_passthrough_errors[None-True-False-False]\nPASSED tests/test_basic.py::test_werkzeug_passthrough_errors[None-False-True-True]\nPASSED tests/test_basic.py::test_werkzeug_passthrough_errors[None-False-True-False]\nPASSED tests/test_basic.py::test_werkzeug_passthrough_errors[None-False-False-True]\nPASSED tests/test_basic.py::test_werkzeug_passthrough_errors[None-False-False-False]\nPASSED tests/test_basic.py::test_werkzeug_passthrough_errors[True-True-True-True]\nPASSED tests/test_basic.py::test_werkzeug_passthrough_errors[True-True-True-False]\nPASSED tests/test_basic.py::test_werkzeug_passthrough_errors[True-True-False-True]\nPASSED tests/test_basic.py::test_werkzeug_passthrough_errors[True-True-False-False]\nPASSED tests/test_basic.py::test_werkzeug_passthrough_errors[True-False-True-True]\nPASSED tests/test_basic.py::test_werkzeug_passthrough_errors[True-False-True-False]\nPASSED tests/test_basic.py::test_werkzeug_passthrough_errors[True-False-False-True]\nPASSED tests/test_basic.py::test_werkzeug_passthrough_errors[True-False-False-False]\nPASSED tests/test_basic.py::test_werkzeug_passthrough_errors[False-True-True-True]\nPASSED tests/test_basic.py::test_werkzeug_passthrough_errors[False-True-True-False]\nPASSED tests/test_basic.py::test_werkzeug_passthrough_errors[False-True-False-True]\nPASSED tests/test_basic.py::test_werkzeug_passthrough_errors[False-True-False-False]\nPASSED tests/test_basic.py::test_werkzeug_passthrough_errors[False-False-True-True]\nPASSED tests/test_basic.py::test_werkzeug_passthrough_errors[False-False-True-False]\nPASSED tests/test_basic.py::test_werkzeug_passthrough_errors[False-False-False-True]\nPASSED tests/test_basic.py::test_werkzeug_passthrough_errors[False-False-False-False]\nPASSED tests/test_basic.py::test_get_method_on_g\nPASSED tests/test_basic.py::test_g_iteration_protocol\nPASSED tests/test_basic.py::test_run_defaults\nPASSED tests/test_basic.py::test_run_server_port\nPASSED tests/test_basic.py::test_run_from_config[None-None-pocoo.org:8080-pocoo.org-8080]\nPASSED tests/test_basic.py::test_run_from_config[localhost-None-pocoo.org:8080-localhost-8080]\nPASSED tests/test_basic.py::test_run_from_config[None-80-pocoo.org:8080-pocoo.org-80]\nPASSED tests/test_basic.py::test_run_from_config[localhost-80-pocoo.org:8080-localhost-80]\nPASSED tests/test_basic.py::test_run_from_config[localhost-0-localhost:8080-localhost-0]\nPASSED tests/test_basic.py::test_run_from_config[None-None-localhost:8080-localhost-8080]\nPASSED tests/test_basic.py::test_run_from_config[None-None-localhost:0-localhost-0]\nPASSED tests/test_basic.py::test_app_freed_on_zero_refcount\nPASSED tests/test_blueprints.py::test_dotted_name_not_allowed\nPASSED tests/test_blueprints.py::test_route_decorator_custom_endpoint_with_dots\nPASSED tests/test_blueprints.py::test_template_filter\nPASSED tests/test_blueprints.py::test_add_template_filter\nPASSED tests/test_blueprints.py::test_template_filter_with_name\nPASSED tests/test_blueprints.py::test_add_template_filter_with_name\nPASSED tests/test_blueprints.py::test_template_test\nPASSED tests/test_blueprints.py::test_add_template_test\nPASSED tests/test_blueprints.py::test_template_test_with_name\nPASSED tests/test_blueprints.py::test_add_template_test_with_name\nPASSED tests/test_blueprints.py::test_template_global\nERROR tests/test_basic.py::test_flashes - DeprecationWarning: 'werkzeug.urls....\nERROR tests/test_basic.py::test_make_response - DeprecationWarning: 'werkzeug...\nERROR tests/test_basic.py::test_make_response_with_response_instance - Deprec...\nERROR tests/test_basic.py::test_jsonify_no_prettyprint - DeprecationWarning: ...\nERROR tests/test_basic.py::test_jsonify_prettyprint - DeprecationWarning: 'we...\nERROR tests/test_basic.py::test_jsonify_mimetype - DeprecationWarning: 'werkz...\nERROR tests/test_basic.py::test_json_dump_dataclass - DeprecationWarning: 'we...\nERROR tests/test_basic.py::test_jsonify_args_and_kwargs_check - DeprecationWa...\nERROR tests/test_basic.py::test_url_generation - DeprecationWarning: 'werkzeu...\nERROR tests/test_blueprints.py::test_templates_and_static - DeprecationWarnin...\nERROR tests/test_blueprints.py::test_templates_list - DeprecationWarning: pkg...\nFAILED tests/test_basic.py::test_options_work - DeprecationWarning: 'werkzeug...\nFAILED tests/test_basic.py::test_options_on_multiple_rules - DeprecationWarni...\nFAILED tests/test_basic.py::test_method_route[get] - DeprecationWarning: 'wer...\nFAILED tests/test_basic.py::test_method_route[post] - DeprecationWarning: 'we...\nFAILED tests/test_basic.py::test_method_route[put] - DeprecationWarning: 'wer...\nFAILED tests/test_basic.py::test_method_route[delete] - DeprecationWarning: '...\nFAILED tests/test_basic.py::test_method_route[patch] - DeprecationWarning: 'w...\nFAILED tests/test_basic.py::test_provide_automatic_options_attr - Deprecation...\nFAILED tests/test_basic.py::test_provide_automatic_options_kwarg - Deprecatio...\nFAILED tests/test_basic.py::test_request_dispatching - DeprecationWarning: 'w...\nFAILED tests/test_basic.py::test_url_mapping - DeprecationWarning: 'werkzeug....\nFAILED tests/test_basic.py::test_werkzeug_routing - DeprecationWarning: 'werk...\nFAILED tests/test_basic.py::test_endpoint_decorator - DeprecationWarning: 'we...\nFAILED tests/test_basic.py::test_session - DeprecationWarning: 'werkzeug.urls...\nFAILED tests/test_basic.py::test_session_using_server_name - TypeError: __ini...\nFAILED tests/test_basic.py::test_session_using_server_name_and_port - TypeErr...\nFAILED tests/test_basic.py::test_session_using_server_name_port_and_path - Ty...\nFAILED tests/test_basic.py::test_session_using_application_root - TypeError: ...\nFAILED tests/test_basic.py::test_session_using_session_settings - TypeError: ...\nFAILED tests/test_basic.py::test_session_using_samesite_attribute - Deprecati...\nFAILED tests/test_basic.py::test_session_localhost_warning - TypeError: __ini...\nFAILED tests/test_basic.py::test_session_ip_warning - TypeError: __init__() g...\nFAILED tests/test_basic.py::test_missing_session - DeprecationWarning: 'werkz...\nFAILED tests/test_basic.py::test_session_expiration - DeprecationWarning: 'we...\nFAILED tests/test_basic.py::test_session_stored_last - DeprecationWarning: 'w...\nFAILED tests/test_basic.py::test_session_special_types - DeprecationWarning: ...\nFAILED tests/test_basic.py::test_session_cookie_setting - DeprecationWarning:...\nFAILED tests/test_basic.py::test_session_vary_cookie - DeprecationWarning: 'w...\nFAILED tests/test_basic.py::test_extended_flashing - DeprecationWarning: 'wer...\nFAILED tests/test_basic.py::test_request_processing - DeprecationWarning: 'we...\nFAILED tests/test_basic.py::test_request_preprocessing_early_return - Depreca...\nFAILED tests/test_basic.py::test_after_request_processing - DeprecationWarnin...\nFAILED tests/test_basic.py::test_teardown_request_handler - DeprecationWarnin...\nFAILED tests/test_basic.py::test_teardown_request_handler_debug_mode - Deprec...\nFAILED tests/test_basic.py::test_teardown_request_handler_error - Deprecation...\nFAILED tests/test_basic.py::test_before_after_request_order - DeprecationWarn...\nFAILED tests/test_basic.py::test_error_handling - DeprecationWarning: 'werkze...\nFAILED tests/test_basic.py::test_error_handling_processing - DeprecationWarni...\nFAILED tests/test_basic.py::test_baseexception_error_handling - DeprecationWa...\nFAILED tests/test_basic.py::test_before_request_and_routing_errors - Deprecat...\nFAILED tests/test_basic.py::test_user_error_handling - DeprecationWarning: 'w...\nFAILED tests/test_basic.py::test_http_error_subclass_handling - DeprecationWa...\nFAILED tests/test_basic.py::test_errorhandler_precedence - DeprecationWarning...\nFAILED tests/test_basic.py::test_trapping_of_bad_request_key_errors - Depreca...\nFAILED tests/test_basic.py::test_trapping_of_all_http_exceptions - Deprecatio...\nFAILED tests/test_basic.py::test_error_handler_after_processor_error - Deprec...\nFAILED tests/test_basic.py::test_enctype_debug_helper - DeprecationWarning: '...\nFAILED tests/test_basic.py::test_response_types - DeprecationWarning: 'werkze...\nFAILED tests/test_basic.py::test_response_type_errors - DeprecationWarning: '...\nFAILED tests/test_basic.py::test_build_error_handler - DeprecationWarning: 'w...\nFAILED tests/test_basic.py::test_build_error_handler_reraise - DeprecationWar...\nFAILED tests/test_basic.py::test_url_for_passes_special_values_to_build_error_handler\nFAILED tests/test_basic.py::test_static_files - DeprecationWarning: 'werkzeug...\nFAILED tests/test_basic.py::test_static_url_path - DeprecationWarning: 'werkz...\nFAILED tests/test_basic.py::test_static_url_path_with_ending_slash - Deprecat...\nFAILED tests/test_basic.py::test_static_url_empty_path - DeprecationWarning: ...\nFAILED tests/test_basic.py::test_static_url_empty_path_default - DeprecationW...\nFAILED tests/test_basic.py::test_static_folder_with_pathlib_path - Deprecatio...\nFAILED tests/test_basic.py::test_static_folder_with_ending_slash - Deprecatio...\nFAILED tests/test_basic.py::test_static_route_with_host_matching - Deprecatio...\nFAILED tests/test_basic.py::test_server_name_subdomain - DeprecationWarning: ...\nFAILED tests/test_basic.py::test_max_content_length - DeprecationWarning: 'we...\nFAILED tests/test_basic.py::test_url_processors - DeprecationWarning: 'werkze...\nFAILED tests/test_basic.py::test_inject_blueprint_url_defaults - DeprecationW...\nFAILED tests/test_basic.py::test_nonascii_pathinfo - DeprecationWarning: 'wer...\nFAILED tests/test_basic.py::test_debug_mode_complains_after_first_request - D...\nFAILED tests/test_basic.py::test_before_first_request_functions - Deprecation...\nFAILED tests/test_basic.py::test_before_first_request_functions_concurrent - ...\nFAILED tests/test_basic.py::test_routing_redirect_debugging - DeprecationWarn...\nFAILED tests/test_basic.py::test_route_decorator_custom_endpoint - Deprecatio...\nFAILED tests/test_basic.py::test_preserve_only_once - DeprecationWarning: 'we...\nFAILED tests/test_basic.py::test_preserve_remembers_exception - DeprecationWa...\nFAILED tests/test_basic.py::test_subdomain_basic_support - TypeError: __init_...\nFAILED tests/test_basic.py::test_subdomain_matching - TypeError: __init__() g...\nFAILED tests/test_basic.py::test_subdomain_matching_with_ports - TypeError: _...\nFAILED tests/test_basic.py::test_subdomain_matching_other_name[False] - TypeE...\nFAILED tests/test_basic.py::test_subdomain_matching_other_name[True] - TypeEr...\nFAILED tests/test_basic.py::test_multi_route_rules - DeprecationWarning: 'wer...\nFAILED tests/test_basic.py::test_multi_route_class_views - DeprecationWarning...\nFAILED tests/test_basic.py::test_max_cookie_size - TypeError: __init__() got ...\nFAILED tests/test_blueprints.py::test_blueprint_specific_error_handling - Dep...\nFAILED tests/test_blueprints.py::test_blueprint_specific_user_error_handling\nFAILED tests/test_blueprints.py::test_blueprint_app_error_handling - Deprecat...\nFAILED tests/test_blueprints.py::test_blueprint_prefix_slash[-/-/] - Deprecat...\nFAILED tests/test_blueprints.py::test_blueprint_prefix_slash[/--/] - Deprecat...\nFAILED tests/test_blueprints.py::test_blueprint_prefix_slash[/-/-/] - Depreca...\nFAILED tests/test_blueprints.py::test_blueprint_prefix_slash[/foo--/foo] - De...\nFAILED tests/test_blueprints.py::test_blueprint_prefix_slash[/foo/--/foo/] - ...\nFAILED tests/test_blueprints.py::test_blueprint_prefix_slash[-/bar-/bar] - De...\nFAILED tests/test_blueprints.py::test_blueprint_prefix_slash[/foo/-/bar-/foo/bar]\nFAILED tests/test_blueprints.py::test_blueprint_prefix_slash[/foo/-bar-/foo/bar]\nFAILED tests/test_blueprints.py::test_blueprint_prefix_slash[/foo-/bar-/foo/bar]\nFAILED tests/test_blueprints.py::test_blueprint_prefix_slash[/foo/-//bar-/foo/bar]\nFAILED tests/test_blueprints.py::test_blueprint_prefix_slash[/foo//-/bar-/foo/bar]\nFAILED tests/test_blueprints.py::test_blueprint_url_defaults - DeprecationWar...\nFAILED tests/test_blueprints.py::test_blueprint_url_processors - DeprecationW...\nFAILED tests/test_blueprints.py::test_default_static_max_age - DeprecationWar...\nFAILED tests/test_blueprints.py::test_dotted_names_from_app - DeprecationWarn...\nFAILED tests/test_blueprints.py::test_empty_url_defaults - DeprecationWarning...\nFAILED tests/test_blueprints.py::test_route_decorator_custom_endpoint - Depre...\nFAILED tests/test_blueprints.py::test_endpoint_decorator - DeprecationWarning...\nFAILED tests/test_blueprints.py::test_template_filter_with_template - Depreca...\nFAILED tests/test_blueprints.py::test_template_filter_after_route_with_template\nFAILED tests/test_blueprints.py::test_add_template_filter_with_template - Dep...\nFAILED tests/test_blueprints.py::test_template_filter_with_name_and_template\nFAILED tests/test_blueprints.py::test_add_template_filter_with_name_and_template\nFAILED tests/test_blueprints.py::test_template_test_with_template - Deprecati...\nFAILED tests/test_blueprints.py::test_template_test_after_route_with_template\nFAILED tests/test_blueprints.py::test_add_template_test_with_template - Depre...\nFAILED tests/test_blueprints.py::test_template_test_with_name_and_template - ...\nFAILED tests/test_blueprints.py::test_add_template_test_with_name_and_template\nFAILED tests/test_blueprints.py::test_context_processing - DeprecationWarning...\nFAILED tests/test_blueprints.py::test_request_processing - DeprecationWarning...\nFAILED tests/test_blueprints.py::test_app_request_processing - DeprecationWar...\nFAILED tests/test_blueprints.py::test_app_url_processors - DeprecationWarning...\nFAILED tests/test_blueprints.py::test_nested_blueprint - DeprecationWarning: ...\n================== 116 failed, 52 passed, 11 errors in 6.36s ===================\n", {"tests/test_basic.py::test_method_route_no_methods": "PASSED", "tests/test_basic.py::test_disallow_string_for_allowed_methods": "PASSED", "tests/test_basic.py::test_error_handler_unknown_code": "PASSED", "tests/test_basic.py::test_request_locals": "PASSED", "tests/test_basic.py::test_exception_propagation": "PASSED", "tests/test_basic.py::test_werkzeug_passthrough_errors[None-True-True-True]": "PASSED", "tests/test_basic.py::test_werkzeug_passthrough_errors[None-True-True-False]": "PASSED", "tests/test_basic.py::test_werkzeug_passthrough_errors[None-True-False-True]": "PASSED", "tests/test_basic.py::test_werkzeug_passthrough_errors[None-True-False-False]": "PASSED", "tests/test_basic.py::test_werkzeug_passthrough_errors[None-False-True-True]": "PASSED", "tests/test_basic.py::test_werkzeug_passthrough_errors[None-False-True-False]": "PASSED", "tests/test_basic.py::test_werkzeug_passthrough_errors[None-False-False-True]": "PASSED", "tests/test_basic.py::test_werkzeug_passthrough_errors[None-False-False-False]": "PASSED", "tests/test_basic.py::test_werkzeug_passthrough_errors[True-True-True-True]": "PASSED", "tests/test_basic.py::test_werkzeug_passthrough_errors[True-True-True-False]": "PASSED", "tests/test_basic.py::test_werkzeug_passthrough_errors[True-True-False-True]": "PASSED", "tests/test_basic.py::test_werkzeug_passthrough_errors[True-True-False-False]": "PASSED", "tests/test_basic.py::test_werkzeug_passthrough_errors[True-False-True-True]": "PASSED", "tests/test_basic.py::test_werkzeug_passthrough_errors[True-False-True-False]": "PASSED", "tests/test_basic.py::test_werkzeug_passthrough_errors[True-False-False-True]": "PASSED", "tests/test_basic.py::test_werkzeug_passthrough_errors[True-False-False-False]": "PASSED", "tests/test_basic.py::test_werkzeug_passthrough_errors[False-True-True-True]": "PASSED", "tests/test_basic.py::test_werkzeug_passthrough_errors[False-True-True-False]": "PASSED", "tests/test_basic.py::test_werkzeug_passthrough_errors[False-True-False-True]": "PASSED", "tests/test_basic.py::test_werkzeug_passthrough_errors[False-True-False-False]": "PASSED", "tests/test_basic.py::test_werkzeug_passthrough_errors[False-False-True-True]": "PASSED", "tests/test_basic.py::test_werkzeug_passthrough_errors[False-False-True-False]": "PASSED", "tests/test_basic.py::test_werkzeug_passthrough_errors[False-False-False-True]": "PASSED", "tests/test_basic.py::test_werkzeug_passthrough_errors[False-False-False-False]": "PASSED", "tests/test_basic.py::test_get_method_on_g": "PASSED", "tests/test_basic.py::test_g_iteration_protocol": "PASSED", "tests/test_basic.py::test_run_defaults": "PASSED", "tests/test_basic.py::test_run_server_port": "PASSED", "tests/test_basic.py::test_run_from_config[None-None-pocoo.org:8080-pocoo.org-8080]": "PASSED", "tests/test_basic.py::test_run_from_config[localhost-None-pocoo.org:8080-localhost-8080]": "PASSED", "tests/test_basic.py::test_run_from_config[None-80-pocoo.org:8080-pocoo.org-80]": "PASSED", "tests/test_basic.py::test_run_from_config[localhost-80-pocoo.org:8080-localhost-80]": "PASSED", "tests/test_basic.py::test_run_from_config[localhost-0-localhost:8080-localhost-0]": "PASSED", "tests/test_basic.py::test_run_from_config[None-None-localhost:8080-localhost-8080]": "PASSED", "tests/test_basic.py::test_run_from_config[None-None-localhost:0-localhost-0]": "PASSED", "tests/test_basic.py::test_app_freed_on_zero_refcount": "PASSED", "tests/test_blueprints.py::test_dotted_name_not_allowed": "PASSED", "tests/test_blueprints.py::test_route_decorator_custom_endpoint_with_dots": "PASSED", "tests/test_blueprints.py::test_template_filter": "PASSED", "tests/test_blueprints.py::test_add_template_filter": "PASSED", "tests/test_blueprints.py::test_template_filter_with_name": "PASSED", "tests/test_blueprints.py::test_add_template_filter_with_name": "PASSED", "tests/test_blueprints.py::test_template_test": "PASSED", "tests/test_blueprints.py::test_add_template_test": "PASSED", "tests/test_blueprints.py::test_template_test_with_name": "PASSED", "tests/test_blueprints.py::test_add_template_test_with_name": "PASSED", "tests/test_blueprints.py::test_template_global": "PASSED", "tests/test_basic.py::test_flashes": "ERROR", "tests/test_basic.py::test_make_response": "ERROR", "tests/test_basic.py::test_make_response_with_response_instance": "ERROR", "tests/test_basic.py::test_jsonify_no_prettyprint": "ERROR", "tests/test_basic.py::test_jsonify_prettyprint": "ERROR", "tests/test_basic.py::test_jsonify_mimetype": "ERROR", "tests/test_basic.py::test_json_dump_dataclass": "ERROR", "tests/test_basic.py::test_jsonify_args_and_kwargs_check": "ERROR", "tests/test_basic.py::test_url_generation": "ERROR", "tests/test_blueprints.py::test_templates_and_static": "ERROR", "tests/test_blueprints.py::test_templates_list": "ERROR", "tests/test_basic.py::test_options_work": "FAILED", "tests/test_basic.py::test_options_on_multiple_rules": "FAILED", "tests/test_basic.py::test_method_route[get]": "FAILED", "tests/test_basic.py::test_method_route[post]": "FAILED", "tests/test_basic.py::test_method_route[put]": "FAILED", "tests/test_basic.py::test_method_route[delete]": "FAILED", "tests/test_basic.py::test_method_route[patch]": "FAILED", "tests/test_basic.py::test_provide_automatic_options_attr": "FAILED", "tests/test_basic.py::test_provide_automatic_options_kwarg": "FAILED", "tests/test_basic.py::test_request_dispatching": "FAILED", "tests/test_basic.py::test_url_mapping": "FAILED", "tests/test_basic.py::test_werkzeug_routing": "FAILED", "tests/test_basic.py::test_endpoint_decorator": "FAILED", "tests/test_basic.py::test_session": "FAILED", "tests/test_basic.py::test_session_using_server_name": "FAILED", "tests/test_basic.py::test_session_using_server_name_and_port": "FAILED", "tests/test_basic.py::test_session_using_server_name_port_and_path": "FAILED", "tests/test_basic.py::test_session_using_application_root": "FAILED", "tests/test_basic.py::test_session_using_session_settings": "FAILED", "tests/test_basic.py::test_session_using_samesite_attribute": "FAILED", "tests/test_basic.py::test_session_localhost_warning": "FAILED", "tests/test_basic.py::test_session_ip_warning": "FAILED", "tests/test_basic.py::test_missing_session": "FAILED", "tests/test_basic.py::test_session_expiration": "FAILED", "tests/test_basic.py::test_session_stored_last": "FAILED", "tests/test_basic.py::test_session_special_types": "FAILED", "tests/test_basic.py::test_session_cookie_setting": "FAILED", "tests/test_basic.py::test_session_vary_cookie": "FAILED", "tests/test_basic.py::test_extended_flashing": "FAILED", "tests/test_basic.py::test_request_processing": "FAILED", "tests/test_basic.py::test_request_preprocessing_early_return": "FAILED", "tests/test_basic.py::test_after_request_processing": "FAILED", "tests/test_basic.py::test_teardown_request_handler": "FAILED", "tests/test_basic.py::test_teardown_request_handler_debug_mode": "FAILED", "tests/test_basic.py::test_teardown_request_handler_error": "FAILED", "tests/test_basic.py::test_before_after_request_order": "FAILED", "tests/test_basic.py::test_error_handling": "FAILED", "tests/test_basic.py::test_error_handling_processing": "FAILED", "tests/test_basic.py::test_baseexception_error_handling": "FAILED", "tests/test_basic.py::test_before_request_and_routing_errors": "FAILED", "tests/test_basic.py::test_user_error_handling": "FAILED", "tests/test_basic.py::test_http_error_subclass_handling": "FAILED", "tests/test_basic.py::test_errorhandler_precedence": "FAILED", "tests/test_basic.py::test_trapping_of_bad_request_key_errors": "FAILED", "tests/test_basic.py::test_trapping_of_all_http_exceptions": "FAILED", "tests/test_basic.py::test_error_handler_after_processor_error": "FAILED", "tests/test_basic.py::test_enctype_debug_helper": "FAILED", "tests/test_basic.py::test_response_types": "FAILED", "tests/test_basic.py::test_response_type_errors": "FAILED", "tests/test_basic.py::test_build_error_handler": "FAILED", "tests/test_basic.py::test_build_error_handler_reraise": "FAILED", "tests/test_basic.py::test_url_for_passes_special_values_to_build_error_handler": "FAILED", "tests/test_basic.py::test_static_files": "FAILED", "tests/test_basic.py::test_static_url_path": "FAILED", "tests/test_basic.py::test_static_url_path_with_ending_slash": "FAILED", "tests/test_basic.py::test_static_url_empty_path": "FAILED", "tests/test_basic.py::test_static_url_empty_path_default": "FAILED", "tests/test_basic.py::test_static_folder_with_pathlib_path": "FAILED", "tests/test_basic.py::test_static_folder_with_ending_slash": "FAILED", "tests/test_basic.py::test_static_route_with_host_matching": "FAILED", "tests/test_basic.py::test_server_name_subdomain": "FAILED", "tests/test_basic.py::test_max_content_length": "FAILED", "tests/test_basic.py::test_url_processors": "FAILED", "tests/test_basic.py::test_inject_blueprint_url_defaults": "FAILED", "tests/test_basic.py::test_nonascii_pathinfo": "FAILED", "tests/test_basic.py::test_debug_mode_complains_after_first_request": "FAILED", "tests/test_basic.py::test_before_first_request_functions": "FAILED", "tests/test_basic.py::test_before_first_request_functions_concurrent": "FAILED", "tests/test_basic.py::test_routing_redirect_debugging": "FAILED", "tests/test_basic.py::test_route_decorator_custom_endpoint": "FAILED", "tests/test_basic.py::test_preserve_only_once": "FAILED", "tests/test_basic.py::test_preserve_remembers_exception": "FAILED", "tests/test_basic.py::test_subdomain_basic_support": "FAILED", "tests/test_basic.py::test_subdomain_matching": "FAILED", "tests/test_basic.py::test_subdomain_matching_with_ports": "FAILED", "tests/test_basic.py::test_subdomain_matching_other_name[False]": "FAILED", "tests/test_basic.py::test_subdomain_matching_other_name[True]": "FAILED", "tests/test_basic.py::test_multi_route_rules": "FAILED", "tests/test_basic.py::test_multi_route_class_views": "FAILED", "tests/test_basic.py::test_max_cookie_size": "FAILED", "tests/test_blueprints.py::test_blueprint_specific_error_handling": "FAILED", "tests/test_blueprints.py::test_blueprint_specific_user_error_handling": "FAILED", "tests/test_blueprints.py::test_blueprint_app_error_handling": "FAILED", "tests/test_blueprints.py::test_blueprint_prefix_slash[-/-/]": "FAILED", "tests/test_blueprints.py::test_blueprint_prefix_slash[/--/]": "FAILED", "tests/test_blueprints.py::test_blueprint_prefix_slash[/-/-/]": "FAILED", "tests/test_blueprints.py::test_blueprint_prefix_slash[/foo--/foo]": "FAILED", "tests/test_blueprints.py::test_blueprint_prefix_slash[/foo/--/foo/]": "FAILED", "tests/test_blueprints.py::test_blueprint_prefix_slash[-/bar-/bar]": "FAILED", "tests/test_blueprints.py::test_blueprint_prefix_slash[/foo/-/bar-/foo/bar]": "FAILED", "tests/test_blueprints.py::test_blueprint_prefix_slash[/foo/-bar-/foo/bar]": "FAILED", "tests/test_blueprints.py::test_blueprint_prefix_slash[/foo-/bar-/foo/bar]": "FAILED", "tests/test_blueprints.py::test_blueprint_prefix_slash[/foo/-//bar-/foo/bar]": "FAILED", "tests/test_blueprints.py::test_blueprint_prefix_slash[/foo//-/bar-/foo/bar]": "FAILED", "tests/test_blueprints.py::test_blueprint_url_defaults": "FAILED", "tests/test_blueprints.py::test_blueprint_url_processors": "FAILED", "tests/test_blueprints.py::test_default_static_max_age": "FAILED", "tests/test_blueprints.py::test_dotted_names_from_app": "FAILED", "tests/test_blueprints.py::test_empty_url_defaults": "FAILED", "tests/test_blueprints.py::test_route_decorator_custom_endpoint": "FAILED", "tests/test_blueprints.py::test_endpoint_decorator": "FAILED", "tests/test_blueprints.py::test_template_filter_with_template": "FAILED", "tests/test_blueprints.py::test_template_filter_after_route_with_template": "FAILED", "tests/test_blueprints.py::test_add_template_filter_with_template": "FAILED", "tests/test_blueprints.py::test_template_filter_with_name_and_template": "FAILED", "tests/test_blueprints.py::test_add_template_filter_with_name_and_template": "FAILED", "tests/test_blueprints.py::test_template_test_with_template": "FAILED", "tests/test_blueprints.py::test_template_test_after_route_with_template": "FAILED", "tests/test_blueprints.py::test_add_template_test_with_template": "FAILED", "tests/test_blueprints.py::test_template_test_with_name_and_template": "FAILED", "tests/test_blueprints.py::test_add_template_test_with_name_and_template": "FAILED", "tests/test_blueprints.py::test_context_processing": "FAILED", "tests/test_blueprints.py::test_request_processing": "FAILED", "tests/test_blueprints.py::test_app_request_processing": "FAILED", "tests/test_blueprints.py::test_app_url_processors": "FAILED", "tests/test_blueprints.py::test_nested_blueprint": "FAILED"}]