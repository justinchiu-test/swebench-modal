[{"repo": "django/django", "instance_id": "django__django-15819", "base_commit": "877c800f255ccaa7abde1fb944de45d1616f5cc9", "patch": "diff --git a/django/core/management/commands/inspectdb.py b/django/core/management/commands/inspectdb.py\n--- a/django/core/management/commands/inspectdb.py\n+++ b/django/core/management/commands/inspectdb.py\n@@ -127,12 +127,14 @@ def table2model(table_name):\n                     yield \"# The error was: %s\" % e\n                     continue\n \n+                model_name = table2model(table_name)\n                 yield \"\"\n                 yield \"\"\n-                yield \"class %s(models.Model):\" % table2model(table_name)\n-                known_models.append(table2model(table_name))\n+                yield \"class %s(models.Model):\" % model_name\n+                known_models.append(model_name)\n                 used_column_names = []  # Holds column names used in the table so far\n                 column_to_field_name = {}  # Maps column names to names of model fields\n+                used_relations = set()  # Holds foreign relations used in the table.\n                 for row in table_description:\n                     comment_notes = (\n                         []\n@@ -186,6 +188,12 @@ def table2model(table_name):\n                             field_type = \"%s(%s\" % (rel_type, rel_to)\n                         else:\n                             field_type = \"%s('%s'\" % (rel_type, rel_to)\n+                        if rel_to in used_relations:\n+                            extra_params[\"related_name\"] = \"%s_%s_set\" % (\n+                                model_name.lower(),\n+                                att_name,\n+                            )\n+                        used_relations.add(rel_to)\n                     else:\n                         # Calling `get_field_type` to get the field type string and any\n                         # additional parameters and notes.\n", "test_patch": "diff --git a/tests/inspectdb/models.py b/tests/inspectdb/models.py\n--- a/tests/inspectdb/models.py\n+++ b/tests/inspectdb/models.py\n@@ -9,6 +9,7 @@ class People(models.Model):\n \n class Message(models.Model):\n     from_field = models.ForeignKey(People, models.CASCADE, db_column=\"from_id\")\n+    author = models.ForeignKey(People, models.CASCADE, related_name=\"message_authors\")\n \n \n class PeopleData(models.Model):\ndiff --git a/tests/inspectdb/tests.py b/tests/inspectdb/tests.py\n--- a/tests/inspectdb/tests.py\n+++ b/tests/inspectdb/tests.py\n@@ -433,6 +433,15 @@ def test_introspection_errors(self):\n         # The error message depends on the backend\n         self.assertIn(\"# The error was:\", output)\n \n+    def test_same_relations(self):\n+        out = StringIO()\n+        call_command(\"inspectdb\", \"inspectdb_message\", stdout=out)\n+        self.assertIn(\n+            \"author = models.ForeignKey('InspectdbPeople', models.DO_NOTHING, \"\n+            \"related_name='inspectdbmessage_author_set')\",\n+            out.getvalue(),\n+        )\n+\n \n class InspectDBTransactionalTests(TransactionTestCase):\n     available_apps = [\"inspectdb\"]\n", "problem_statement": "inspectdb should generate related_name on same relation links.\nDescription\n\t\nHi!\nAfter models generation with inspectdb command we have issue with relations to same enities\nmodule.Model.field1: (fields.E304) Reverse accessor for 'module.Model.field1' clashes with reverse accessor for 'module.Model.field2'.\nHINT: Add or change a related_name argument to the definition for 'module.Model.field1' or 'module.Model.field2'.\n*\nMaybe we can autogenerate\nrelated_name='attribute_name'\nto all fields in model if related Model was used for this table\n", "hints_text": "FIrst solution variant was - \u200bhttps://github.com/django/django/pull/15816 But now I see it is not correct. I'll be back with new pull request", "created_at": "2022-07-04T18:29:53Z", "version": "4.2", "FAIL_TO_PASS": "[\"test_same_relations (inspectdb.tests.InspectDBTestCase)\"]", "PASS_TO_PASS": "[\"test_composite_primary_key (inspectdb.tests.InspectDBTransactionalTests)\", \"inspectdb --include-views creates models for database views.\", \"test_attribute_name_not_python_keyword (inspectdb.tests.InspectDBTestCase)\", \"test_char_field_db_collation (inspectdb.tests.InspectDBTestCase)\", \"Introspection of columns with a custom field (#21090)\", \"Introspection of column names consist/start with digits (#16536/#17676)\", \"Test introspection of various Django field types\", \"test_foreign_key_to_field (inspectdb.tests.InspectDBTestCase)\", \"Introspection errors should not crash the command, and the error should\", \"test_json_field (inspectdb.tests.InspectDBTestCase)\", \"By default the command generates models with `Meta.managed = False`.\", \"Introspection of column names containing special characters,\", \"test_stealth_table_name_filter_option (inspectdb.tests.InspectDBTestCase)\", \"Introspection of table names containing special characters,\", \"inspectdb can inspect a subset of tables by passing the table names as\", \"test_table_with_func_unique_constraint (inspectdb.tests.InspectDBTestCase)\", \"test_text_field_db_collation (inspectdb.tests.InspectDBTestCase)\", \"test_unique_together_meta (inspectdb.tests.InspectDBTestCase)\"]", "environment_setup_commit": "0fbdb9784da915fce5dcc1fe82bac9b4785749e5"}, "On branch main\nChanges not staged for commit:\n  (use \"git add <file>...\" to update what will be committed)\n  (use \"git restore <file>...\" to discard changes in working directory)\n\tmodified:   django/core/management/commands/inspectdb.py\n\nno changes added to commit (use \"git add\" and/or \"git commit -a\")\ncommit 877c800f255ccaa7abde1fb944de45d1616f5cc9\nAuthor: Simon Charette <charette.s@gmail.com>\nDate:   Sun Jun 19 23:46:22 2022 -0400\n\n    Refs CVE-2022-34265 -- Properly escaped Extract() and Trunc() parameters.\n    \n    Co-authored-by: Mariusz Felisiak <felisiak.mariusz@gmail.com>\n\ndiff --git a/django/db/backends/base/operations.py b/django/db/backends/base/operations.py\nindex 680ea1fc50..dd29068495 100644\n--- a/django/db/backends/base/operations.py\n+++ b/django/db/backends/base/operations.py\n@@ -9,7 +9,6 @@ from django.db import NotSupportedError, transaction\n from django.db.backends import utils\n from django.utils import timezone\n from django.utils.encoding import force_str\n-from django.utils.regex_helper import _lazy_re_compile\n \n \n class BaseDatabaseOperations:\n@@ -55,8 +54,6 @@ class BaseDatabaseOperations:\n     # Prefix for EXPLAIN queries, or None EXPLAIN isn't supported.\n     explain_prefix = None\n \n-    extract_trunc_lookup_pattern = _lazy_re_compile(r\"[\\w\\-_()]+\")\n-\n     def __init__(self, connection):\n         self.connection = connection\n         self._cache = None\n@@ -103,7 +100,7 @@ class BaseDatabaseOperations:\n         \"\"\"\n         return \"%s\"\n \n-    def date_extract_sql(self, lookup_type, field_name):\n+    def date_extract_sql(self, lookup_type, sql, params):\n         \"\"\"\n         Given a lookup_type of 'year', 'month', or 'day', return the SQL that\n         extracts a value from the given date field field_name.\n@@ -113,7 +110,7 @@ class BaseDatabaseOperations:\n             \"method\"\n         )\n \n-    def date_trunc_sql(self, lookup_type, field_name, tzname=None):\n+    def date_trunc_sql(self, lookup_type, sql, params, tzname=None):\n         \"\"\"\n         Given a lookup_type of 'year', 'month', or 'day', return the SQL that\n         truncates the given date or datetime field field_name to a date object\n@@ -127,7 +124,7 @@ class BaseDatabaseOperations:\n             \"method.\"\n         )\n \n-    def datetime_cast_date_sql(self, field_name, tzname):\n+    def datetime_cast_date_sql(self, sql, params, tzname):\n         \"\"\"\n         Return the SQL to cast a datetime value to date value.\n         \"\"\"\n@@ -136,7 +133,7 @@ class BaseDatabaseOperations:\n             \"datetime_cast_date_sql() method.\"\n         )\n \n-    def datetime_cast_time_sql(self, field_name, tzname):\n+    def datetime_cast_time_sql(self, sql, params, tzname):\n         \"\"\"\n         Return the SQL to cast a datetime value to time value.\n         \"\"\"\n@@ -145,7 +142,7 @@ class BaseDatabaseOperations:\n             \"datetime_cast_time_sql() method\"\n         )\n \n-    def datetime_extract_sql(self, lookup_type, field_name, tzname):\n+    def datetime_extract_sql(self, lookup_type, sql, params, tzname):\n         \"\"\"\n         Given a lookup_type of 'year', 'month', 'day', 'hour', 'minute', or\n         'second', return the SQL that extracts a value from the given\n@@ -156,7 +153,7 @@ class BaseDatabaseOperations:\n             \"method\"\n         )\n \n-    def datetime_trunc_sql(self, lookup_type, field_name, tzname):\n+    def datetime_trunc_sql(self, lookup_type, sql, params, tzname):\n         \"\"\"\n         Given a lookup_type of 'year', 'month', 'day', 'hour', 'minute', or\n         'second', return the SQL that truncates the given datetime field\n@@ -167,7 +164,7 @@ class BaseDatabaseOperations:\n             \"method\"\n         )\n \n-    def time_trunc_sql(self, lookup_type, field_name, tzname=None):\n+    def time_trunc_sql(self, lookup_type, sql, params, tzname=None):\n         \"\"\"\n         Given a lookup_type of 'hour', 'minute' or 'second', return the SQL\n         that truncates the given time or datetime field field_name to a time\n@@ -180,12 +177,12 @@ class BaseDatabaseOperations:\n             \"subclasses of BaseDatabaseOperations may require a time_trunc_sql() method\"\n         )\n \n-    def time_extract_sql(self, lookup_type, field_name):\n+    def time_extract_sql(self, lookup_type, sql, params):\n         \"\"\"\n         Given a lookup_type of 'hour', 'minute', or 'second', return the SQL\n         that extracts a value from the given time field field_name.\n         \"\"\"\n-        return self.date_extract_sql(lookup_type, field_name)\n+        return self.date_extract_sql(lookup_type, sql, params)\n \n     def deferrable_sql(self):\n         \"\"\"\ndiff --git a/django/db/backends/mysql/operations.py b/django/db/backends/mysql/operations.py\nindex 7c4e21671b..34cdfc0292 100644\n--- a/django/db/backends/mysql/operations.py\n+++ b/django/db/backends/mysql/operations.py\n@@ -7,6 +7,7 @@ from django.db.models import Exists, ExpressionWrapper, Lookup\n from django.db.models.constants import OnConflict\n from django.utils import timezone\n from django.utils.encoding import force_str\n+from django.utils.regex_helper import _lazy_re_compile\n \n \n class DatabaseOperations(BaseDatabaseOperations):\n@@ -37,117 +38,115 @@ class DatabaseOperations(BaseDatabaseOperations):\n     cast_char_field_without_max_length = \"char\"\n     explain_prefix = \"EXPLAIN\"\n \n-    def date_extract_sql(self, lookup_type, field_name):\n+    # EXTRACT format cannot be passed in parameters.\n+    _extract_format_re = _lazy_re_compile(r\"[A-Z_]+\")\n+\n+    def date_extract_sql(self, lookup_type, sql, params):\n         # https://dev.mysql.com/doc/mysql/en/date-and-time-functions.html\n         if lookup_type == \"week_day\":\n             # DAYOFWEEK() returns an integer, 1-7, Sunday=1.\n-            return \"DAYOFWEEK(%s)\" % field_name\n+            return f\"DAYOFWEEK({sql})\", params\n         elif lookup_type == \"iso_week_day\":\n             # WEEKDAY() returns an integer, 0-6, Monday=0.\n-            return \"WEEKDAY(%s) + 1\" % field_name\n+            return f\"WEEKDAY({sql}) + 1\", params\n         elif lookup_type == \"week\":\n             # Override the value of default_week_format for consistency with\n             # other database backends.\n             # Mode 3: Monday, 1-53, with 4 or more days this year.\n-            return \"WEEK(%s, 3)\" % field_name\n+            return f\"WEEK({sql}, 3)\", params\n         elif lookup_type == \"iso_year\":\n             # Get the year part from the YEARWEEK function, which returns a\n             # number as year * 100 + week.\n-            return \"TRUNCATE(YEARWEEK(%s, 3), -2) / 100\" % field_name\n+            return f\"TRUNCATE(YEARWEEK({sql}, 3), -2) / 100\", params\n         else:\n             # EXTRACT returns 1-53 based on ISO-8601 for the week number.\n-            return \"EXTRACT(%s FROM %s)\" % (lookup_type.upper(), field_name)\n+            lookup_type = lookup_type.upper()\n+            if not self._extract_format_re.fullmatch(lookup_type):\n+                raise ValueError(f\"Invalid loookup type: {lookup_type!r}\")\n+            return f\"EXTRACT({lookup_type} FROM {sql})\", params\n \n-    def date_trunc_sql(self, lookup_type, field_name, tzname=None):\n-        field_name = self._convert_field_to_tz(field_name, tzname)\n+    def date_trunc_sql(self, lookup_type, sql, params, tzname=None):\n+        sql, params = self._convert_field_to_tz(sql, params, tzname)\n         fields = {\n-            \"year\": \"%%Y-01-01\",\n-            \"month\": \"%%Y-%%m-01\",\n-        }  # Use double percents to escape.\n+            \"year\": \"%Y-01-01\",\n+            \"month\": \"%Y-%m-01\",\n+        }\n         if lookup_type in fields:\n             format_str = fields[lookup_type]\n-            return \"CAST(DATE_FORMAT(%s, '%s') AS DATE)\" % (field_name, format_str)\n+            return f\"CAST(DATE_FORMAT({sql}, %s) AS DATE)\", (*params, format_str)\n         elif lookup_type == \"quarter\":\n             return (\n-                \"MAKEDATE(YEAR(%s), 1) + \"\n-                \"INTERVAL QUARTER(%s) QUARTER - INTERVAL 1 QUARTER\"\n-                % (field_name, field_name)\n+                f\"MAKEDATE(YEAR({sql}), 1) + \"\n+                f\"INTERVAL QUARTER({sql}) QUARTER - INTERVAL 1 QUARTER\",\n+                (*params, *params),\n             )\n         elif lookup_type == \"week\":\n-            return \"DATE_SUB(%s, INTERVAL WEEKDAY(%s) DAY)\" % (field_name, field_name)\n+            return f\"DATE_SUB({sql}, INTERVAL WEEKDAY({sql}) DAY)\", (*params, *params)\n         else:\n-            return \"DATE(%s)\" % (field_name)\n+            return f\"DATE({sql})\", params\n \n     def _prepare_tzname_delta(self, tzname):\n         tzname, sign, offset = split_tzname_delta(tzname)\n         return f\"{sign}{offset}\" if offset else tzname\n \n-    def _convert_field_to_tz(self, field_name, tzname):\n+    def _convert_field_to_tz(self, sql, params, tzname):\n         if tzname and settings.USE_TZ and self.connection.timezone_name != tzname:\n-            field_name = \"CONVERT_TZ(%s, '%s', '%s')\" % (\n-                field_name,\n+            return f\"CONVERT_TZ({sql}, %s, %s)\", (\n+                *params,\n                 self.connection.timezone_name,\n                 self._prepare_tzname_delta(tzname),\n             )\n-        return field_name\n+        return sql, params\n \n-    def datetime_cast_date_sql(self, field_name, tzname):\n-        field_name = self._convert_field_to_tz(field_name, tzname)\n-        return \"DATE(%s)\" % field_name\n+    def datetime_cast_date_sql(self, sql, params, tzname):\n+        sql, params = self._convert_field_to_tz(sql, params, tzname)\n+        return f\"DATE({sql})\", params\n \n-    def datetime_cast_time_sql(self, field_name, tzname):\n-        field_name = self._convert_field_to_tz(field_name, tzname)\n-        return \"TIME(%s)\" % field_name\n+    def datetime_cast_time_sql(self, sql, params, tzname):\n+        sql, params = self._convert_field_to_tz(sql, params, tzname)\n+        return f\"TIME({sql})\", params\n \n-    def datetime_extract_sql(self, lookup_type, field_name, tzname):\n-        field_name = self._convert_field_to_tz(field_name, tzname)\n-        return self.date_extract_sql(lookup_type, field_name)\n+    def datetime_extract_sql(self, lookup_type, sql, params, tzname):\n+        sql, params = self._convert_field_to_tz(sql, params, tzname)\n+        return self.date_extract_sql(lookup_type, sql, params)\n \n-    def datetime_trunc_sql(self, lookup_type, field_name, tzname):\n-        field_name = self._convert_field_to_tz(field_name, tzname)\n+    def datetime_trunc_sql(self, lookup_type, sql, params, tzname):\n+        sql, params = self._convert_field_to_tz(sql, params, tzname)\n         fields = [\"year\", \"month\", \"day\", \"hour\", \"minute\", \"second\"]\n-        format = (\n-            \"%%Y-\",\n-            \"%%m\",\n-            \"-%%d\",\n-            \" %%H:\",\n-            \"%%i\",\n-            \":%%s\",\n-        )  # Use double percents to escape.\n+        format = (\"%Y-\", \"%m\", \"-%d\", \" %H:\", \"%i\", \":%s\")\n         format_def = (\"0000-\", \"01\", \"-01\", \" 00:\", \"00\", \":00\")\n         if lookup_type == \"quarter\":\n             return (\n-                \"CAST(DATE_FORMAT(MAKEDATE(YEAR({field_name}), 1) + \"\n-                \"INTERVAL QUARTER({field_name}) QUARTER - \"\n-                + \"INTERVAL 1 QUARTER, '%%Y-%%m-01 00:00:00') AS DATETIME)\"\n-            ).format(field_name=field_name)\n+                f\"CAST(DATE_FORMAT(MAKEDATE(YEAR({sql}), 1) + \"\n+                f\"INTERVAL QUARTER({sql}) QUARTER - \"\n+                f\"INTERVAL 1 QUARTER, %s) AS DATETIME)\"\n+            ), (*params, *params, \"%Y-%m-01 00:00:00\")\n         if lookup_type == \"week\":\n             return (\n-                \"CAST(DATE_FORMAT(DATE_SUB({field_name}, \"\n-                \"INTERVAL WEEKDAY({field_name}) DAY), \"\n-                \"'%%Y-%%m-%%d 00:00:00') AS DATETIME)\"\n-            ).format(field_name=field_name)\n+                f\"CAST(DATE_FORMAT(\"\n+                f\"DATE_SUB({sql}, INTERVAL WEEKDAY({sql}) DAY), %s) AS DATETIME)\"\n+            ), (*params, *params, \"%Y-%m-%d 00:00:00\")\n         try:\n             i = fields.index(lookup_type) + 1\n         except ValueError:\n-            sql = field_name\n+            pass\n         else:\n             format_str = \"\".join(format[:i] + format_def[i:])\n-            sql = \"CAST(DATE_FORMAT(%s, '%s') AS DATETIME)\" % (field_name, format_str)\n-        return sql\n+            return f\"CAST(DATE_FORMAT({sql}, %s) AS DATETIME)\", (*params, format_str)\n+        return sql, params\n \n-    def time_trunc_sql(self, lookup_type, field_name, tzname=None):\n-        field_name = self._convert_field_to_tz(field_name, tzname)\n+    def time_trunc_sql(self, lookup_type, sql, params, tzname=None):\n+        sql, params = self._convert_field_to_tz(sql, params, tzname)\n         fields = {\n-            \"hour\": \"%%H:00:00\",\n-            \"minute\": \"%%H:%%i:00\",\n-            \"second\": \"%%H:%%i:%%s\",\n-        }  # Use double percents to escape.\n+            \"hour\": \"%H:00:00\",\n+            \"minute\": \"%H:%i:00\",\n+            \"second\": \"%H:%i:%s\",\n+        }\n         if lookup_type in fields:\n             format_str = fields[lookup_type]\n-            return \"CAST(DATE_FORMAT(%s, '%s') AS TIME)\" % (field_name, format_str)\n+            return f\"CAST(DATE_FORMAT({sql}, %s) AS TIME)\", (*params, format_str)\n         else:\n-            return \"TIME(%s)\" % (field_name)\n+            return f\"TIME({sql})\", params\n \n     def fetch_returned_insert_rows(self, cursor):\n         \"\"\"\ndiff --git a/django/db/backends/oracle/operations.py b/django/db/backends/oracle/operations.py\nindex b044adadda..70548e358f 100644\n--- a/django/db/backends/oracle/operations.py\n+++ b/django/db/backends/oracle/operations.py\n@@ -77,34 +77,46 @@ END;\n             f\"ORDER BY {cache_key} OFFSET %%s ROWS FETCH FIRST 1 ROWS ONLY\"\n         )\n \n-    def date_extract_sql(self, lookup_type, field_name):\n+    # EXTRACT format cannot be passed in parameters.\n+    _extract_format_re = _lazy_re_compile(r\"[A-Z_]+\")\n+\n+    def date_extract_sql(self, lookup_type, sql, params):\n+        extract_sql = f\"TO_CHAR({sql}, %s)\"\n+        extract_param = None\n         if lookup_type == \"week_day\":\n             # TO_CHAR(field, 'D') returns an integer from 1-7, where 1=Sunday.\n-            return \"TO_CHAR(%s, 'D')\" % field_name\n+            extract_param = \"D\"\n         elif lookup_type == \"iso_week_day\":\n-            return \"TO_CHAR(%s - 1, 'D')\" % field_name\n+            extract_sql = f\"TO_CHAR({sql} - 1, %s)\"\n+            extract_param = \"D\"\n         elif lookup_type == \"week\":\n             # IW = ISO week number\n-            return \"TO_CHAR(%s, 'IW')\" % field_name\n+            extract_param = \"IW\"\n         elif lookup_type == \"quarter\":\n-            return \"TO_CHAR(%s, 'Q')\" % field_name\n+            extract_param = \"Q\"\n         elif lookup_type == \"iso_year\":\n-            return \"TO_CHAR(%s, 'IYYY')\" % field_name\n+            extract_param = \"IYYY\"\n         else:\n+            lookup_type = lookup_type.upper()\n+            if not self._extract_format_re.fullmatch(lookup_type):\n+                raise ValueError(f\"Invalid loookup type: {lookup_type!r}\")\n             # https://docs.oracle.com/en/database/oracle/oracle-database/21/sqlrf/EXTRACT-datetime.html\n-            return \"EXTRACT(%s FROM %s)\" % (lookup_type.upper(), field_name)\n+            return f\"EXTRACT({lookup_type} FROM {sql})\", params\n+        return extract_sql, (*params, extract_param)\n \n-    def date_trunc_sql(self, lookup_type, field_name, tzname=None):\n-        field_name = self._convert_field_to_tz(field_name, tzname)\n+    def date_trunc_sql(self, lookup_type, sql, params, tzname=None):\n+        sql, params = self._convert_field_to_tz(sql, params, tzname)\n         # https://docs.oracle.com/en/database/oracle/oracle-database/21/sqlrf/ROUND-and-TRUNC-Date-Functions.html\n+        trunc_param = None\n         if lookup_type in (\"year\", \"month\"):\n-            return \"TRUNC(%s, '%s')\" % (field_name, lookup_type.upper())\n+            trunc_param = lookup_type.upper()\n         elif lookup_type == \"quarter\":\n-            return \"TRUNC(%s, 'Q')\" % field_name\n+            trunc_param = \"Q\"\n         elif lookup_type == \"week\":\n-            return \"TRUNC(%s, 'IW')\" % field_name\n+            trunc_param = \"IW\"\n         else:\n-            return \"TRUNC(%s)\" % field_name\n+            return f\"TRUNC({sql})\", params\n+        return f\"TRUNC({sql}, %s)\", (*params, trunc_param)\n \n     # Oracle crashes with \"ORA-03113: end-of-file on communication channel\"\n     # if the time zone name is passed in parameter. Use interpolation instead.\n@@ -116,77 +128,80 @@ END;\n         tzname, sign, offset = split_tzname_delta(tzname)\n         return f\"{sign}{offset}\" if offset else tzname\n \n-    def _convert_field_to_tz(self, field_name, tzname):\n+    def _convert_field_to_tz(self, sql, params, tzname):\n         if not (settings.USE_TZ and tzname):\n-            return field_name\n+            return sql, params\n         if not self._tzname_re.match(tzname):\n             raise ValueError(\"Invalid time zone name: %s\" % tzname)\n         # Convert from connection timezone to the local time, returning\n         # TIMESTAMP WITH TIME ZONE and cast it back to TIMESTAMP to strip the\n         # TIME ZONE details.\n         if self.connection.timezone_name != tzname:\n-            return \"CAST((FROM_TZ(%s, '%s') AT TIME ZONE '%s') AS TIMESTAMP)\" % (\n-                field_name,\n-                self.connection.timezone_name,\n-                self._prepare_tzname_delta(tzname),\n+            from_timezone_name = self.connection.timezone_name\n+            to_timezone_name = self._prepare_tzname_delta(tzname)\n+            return (\n+                f\"CAST((FROM_TZ({sql}, '{from_timezone_name}') AT TIME ZONE \"\n+                f\"'{to_timezone_name}') AS TIMESTAMP)\",\n+                params,\n             )\n-        return field_name\n+        return sql, params\n \n-    def datetime_cast_date_sql(self, field_name, tzname):\n-        field_name = self._convert_field_to_tz(field_name, tzname)\n-        return \"TRUNC(%s)\" % field_name\n+    def datetime_cast_date_sql(self, sql, params, tzname):\n+        sql, params = self._convert_field_to_tz(sql, params, tzname)\n+        return f\"TRUNC({sql})\", params\n \n-    def datetime_cast_time_sql(self, field_name, tzname):\n+    def datetime_cast_time_sql(self, sql, params, tzname):\n         # Since `TimeField` values are stored as TIMESTAMP change to the\n         # default date and convert the field to the specified timezone.\n+        sql, params = self._convert_field_to_tz(sql, params, tzname)\n         convert_datetime_sql = (\n-            \"TO_TIMESTAMP(CONCAT('1900-01-01 ', TO_CHAR(%s, 'HH24:MI:SS.FF')), \"\n-            \"'YYYY-MM-DD HH24:MI:SS.FF')\"\n-        ) % self._convert_field_to_tz(field_name, tzname)\n-        return \"CASE WHEN %s IS NOT NULL THEN %s ELSE NULL END\" % (\n-            field_name,\n-            convert_datetime_sql,\n+            f\"TO_TIMESTAMP(CONCAT('1900-01-01 ', TO_CHAR({sql}, 'HH24:MI:SS.FF')), \"\n+            f\"'YYYY-MM-DD HH24:MI:SS.FF')\"\n+        )\n+        return (\n+            f\"CASE WHEN {sql} IS NOT NULL THEN {convert_datetime_sql} ELSE NULL END\",\n+            (*params, *params),\n         )\n \n-    def datetime_extract_sql(self, lookup_type, field_name, tzname):\n-        field_name = self._convert_field_to_tz(field_name, tzname)\n-        return self.date_extract_sql(lookup_type, field_name)\n+    def datetime_extract_sql(self, lookup_type, sql, params, tzname):\n+        sql, params = self._convert_field_to_tz(sql, params, tzname)\n+        return self.date_extract_sql(lookup_type, sql, params)\n \n-    def datetime_trunc_sql(self, lookup_type, field_name, tzname):\n-        field_name = self._convert_field_to_tz(field_name, tzname)\n+    def datetime_trunc_sql(self, lookup_type, sql, params, tzname):\n+        sql, params = self._convert_field_to_tz(sql, params, tzname)\n         # https://docs.oracle.com/en/database/oracle/oracle-database/21/sqlrf/ROUND-and-TRUNC-Date-Functions.html\n+        trunc_param = None\n         if lookup_type in (\"year\", \"month\"):\n-            sql = \"TRUNC(%s, '%s')\" % (field_name, lookup_type.upper())\n+            trunc_param = lookup_type.upper()\n         elif lookup_type == \"quarter\":\n-            sql = \"TRUNC(%s, 'Q')\" % field_name\n+            trunc_param = \"Q\"\n         elif lookup_type == \"week\":\n-            sql = \"TRUNC(%s, 'IW')\" % field_name\n-        elif lookup_type == \"day\":\n-            sql = \"TRUNC(%s)\" % field_name\n+            trunc_param = \"IW\"\n         elif lookup_type == \"hour\":\n-            sql = \"TRUNC(%s, 'HH24')\" % field_name\n+            trunc_param = \"HH24\"\n         elif lookup_type == \"minute\":\n-            sql = \"TRUNC(%s, 'MI')\" % field_name\n+            trunc_param = \"MI\"\n+        elif lookup_type == \"day\":\n+            return f\"TRUNC({sql})\", params\n         else:\n-            sql = (\n-                \"CAST(%s AS DATE)\" % field_name\n-            )  # Cast to DATE removes sub-second precision.\n-        return sql\n+            # Cast to DATE removes sub-second precision.\n+            return f\"CAST({sql} AS DATE)\", params\n+        return f\"TRUNC({sql}, %s)\", (*params, trunc_param)\n \n-    def time_trunc_sql(self, lookup_type, field_name, tzname=None):\n+    def time_trunc_sql(self, lookup_type, sql, params, tzname=None):\n         # The implementation is similar to `datetime_trunc_sql` as both\n         # `DateTimeField` and `TimeField` are stored as TIMESTAMP where\n         # the date part of the later is ignored.\n-        field_name = self._convert_field_to_tz(field_name, tzname)\n+        sql, params = self._convert_field_to_tz(sql, params, tzname)\n+        trunc_param = None\n         if lookup_type == \"hour\":\n-            sql = \"TRUNC(%s, 'HH24')\" % field_name\n+            trunc_param = \"HH24\"\n         elif lookup_type == \"minute\":\n-            sql = \"TRUNC(%s, 'MI')\" % field_name\n+            trunc_param = \"MI\"\n         elif lookup_type == \"second\":\n-            sql = (\n-                \"CAST(%s AS DATE)\" % field_name\n-            )  # Cast to DATE removes sub-second precision.\n-        return sql\n+            # Cast to DATE removes sub-second precision.\n+            return f\"CAST({sql} AS DATE)\", params\n+        return f\"TRUNC({sql}, %s)\", (*params, trunc_param)\n \n     def get_db_converters(self, expression):\n         converters = super().get_db_converters(expression)\ndiff --git a/django/db/backends/postgresql/operations.py b/django/db/backends/postgresql/operations.py\nindex ec162d53f4..e8eb06c9e2 100644\n--- a/django/db/backends/postgresql/operations.py\n+++ b/django/db/backends/postgresql/operations.py\n@@ -47,22 +47,24 @@ class DatabaseOperations(BaseDatabaseOperations):\n             )\n         return \"%s\"\n \n-    def date_extract_sql(self, lookup_type, field_name):\n+    def date_extract_sql(self, lookup_type, sql, params):\n         # https://www.postgresql.org/docs/current/functions-datetime.html#FUNCTIONS-DATETIME-EXTRACT\n+        extract_sql = f\"EXTRACT(%s FROM {sql})\"\n+        extract_param = lookup_type\n         if lookup_type == \"week_day\":\n             # For consistency across backends, we return Sunday=1, Saturday=7.\n-            return \"EXTRACT('dow' FROM %s) + 1\" % field_name\n+            extract_sql = f\"EXTRACT(%s FROM {sql}) + 1\"\n+            extract_param = \"dow\"\n         elif lookup_type == \"iso_week_day\":\n-            return \"EXTRACT('isodow' FROM %s)\" % field_name\n+            extract_param = \"isodow\"\n         elif lookup_type == \"iso_year\":\n-            return \"EXTRACT('isoyear' FROM %s)\" % field_name\n-        else:\n-            return \"EXTRACT('%s' FROM %s)\" % (lookup_type, field_name)\n+            extract_param = \"isoyear\"\n+        return extract_sql, (extract_param, *params)\n \n-    def date_trunc_sql(self, lookup_type, field_name, tzname=None):\n-        field_name = self._convert_field_to_tz(field_name, tzname)\n+    def date_trunc_sql(self, lookup_type, sql, params, tzname=None):\n+        sql, params = self._convert_sql_to_tz(sql, params, tzname)\n         # https://www.postgresql.org/docs/current/functions-datetime.html#FUNCTIONS-DATETIME-TRUNC\n-        return \"DATE_TRUNC('%s', %s)\" % (lookup_type, field_name)\n+        return f\"DATE_TRUNC(%s, {sql})\", (lookup_type, *params)\n \n     def _prepare_tzname_delta(self, tzname):\n         tzname, sign, offset = split_tzname_delta(tzname)\n@@ -71,43 +73,47 @@ class DatabaseOperations(BaseDatabaseOperations):\n             return f\"{tzname}{sign}{offset}\"\n         return tzname\n \n-    def _convert_field_to_tz(self, field_name, tzname):\n+    def _convert_sql_to_tz(self, sql, params, tzname):\n         if tzname and settings.USE_TZ:\n-            field_name = \"%s AT TIME ZONE '%s'\" % (\n-                field_name,\n-                self._prepare_tzname_delta(tzname),\n-            )\n-        return field_name\n+            tzname_param = self._prepare_tzname_delta(tzname)\n+            return f\"{sql} AT TIME ZONE %s\", (*params, tzname_param)\n+        return sql, params\n \n-    def datetime_cast_date_sql(self, field_name, tzname):\n-        field_name = self._convert_field_to_tz(field_name, tzname)\n-        return \"(%s)::date\" % field_name\n+    def datetime_cast_date_sql(self, sql, params, tzname):\n+        sql, params = self._convert_sql_to_tz(sql, params, tzname)\n+        return f\"({sql})::date\", params\n \n-    def datetime_cast_time_sql(self, field_name, tzname):\n-        field_name = self._convert_field_to_tz(field_name, tzname)\n-        return \"(%s)::time\" % field_name\n+    def datetime_cast_time_sql(self, sql, params, tzname):\n+        sql, params = self._convert_sql_to_tz(sql, params, tzname)\n+        return f\"({sql})::time\", params\n \n-    def datetime_extract_sql(self, lookup_type, field_name, tzname):\n-        field_name = self._convert_field_to_tz(field_name, tzname)\n+    def datetime_extract_sql(self, lookup_type, sql, params, tzname):\n+        sql, params = self._convert_sql_to_tz(sql, params, tzname)\n         if lookup_type == \"second\":\n             # Truncate fractional seconds.\n-            return f\"EXTRACT('second' FROM DATE_TRUNC('second', {field_name}))\"\n-        return self.date_extract_sql(lookup_type, field_name)\n+            return (\n+                f\"EXTRACT(%s FROM DATE_TRUNC(%s, {sql}))\",\n+                (\"second\", \"second\", *params),\n+            )\n+        return self.date_extract_sql(lookup_type, sql, params)\n \n-    def datetime_trunc_sql(self, lookup_type, field_name, tzname):\n-        field_name = self._convert_field_to_tz(field_name, tzname)\n+    def datetime_trunc_sql(self, lookup_type, sql, params, tzname):\n+        sql, params = self._convert_sql_to_tz(sql, params, tzname)\n         # https://www.postgresql.org/docs/current/functions-datetime.html#FUNCTIONS-DATETIME-TRUNC\n-        return \"DATE_TRUNC('%s', %s)\" % (lookup_type, field_name)\n+        return f\"DATE_TRUNC(%s, {sql})\", (lookup_type, *params)\n \n-    def time_extract_sql(self, lookup_type, field_name):\n+    def time_extract_sql(self, lookup_type, sql, params):\n         if lookup_type == \"second\":\n             # Truncate fractional seconds.\n-            return f\"EXTRACT('second' FROM DATE_TRUNC('second', {field_name}))\"\n-        return self.date_extract_sql(lookup_type, field_name)\n+            return (\n+                f\"EXTRACT(%s FROM DATE_TRUNC(%s, {sql}))\",\n+                (\"second\", \"second\", *params),\n+            )\n+        return self.date_extract_sql(lookup_type, sql, params)\n \n-    def time_trunc_sql(self, lookup_type, field_name, tzname=None):\n-        field_name = self._convert_field_to_tz(field_name, tzname)\n-        return \"DATE_TRUNC('%s', %s)::time\" % (lookup_type, field_name)\n+    def time_trunc_sql(self, lookup_type, sql, params, tzname=None):\n+        sql, params = self._convert_sql_to_tz(sql, params, tzname)\n+        return f\"DATE_TRUNC(%s, {sql})::time\", (lookup_type, *params)\n \n     def deferrable_sql(self):\n         return \" DEFERRABLE INITIALLY DEFERRED\"\ndiff --git a/django/db/backends/sqlite3/operations.py b/django/db/backends/sqlite3/operations.py\nindex 7c7cfce1ba..0d3a4060ac 100644\n--- a/django/db/backends/sqlite3/operations.py\n+++ b/django/db/backends/sqlite3/operations.py\n@@ -69,13 +69,13 @@ class DatabaseOperations(BaseDatabaseOperations):\n                 \"accepting multiple arguments.\"\n             )\n \n-    def date_extract_sql(self, lookup_type, field_name):\n+    def date_extract_sql(self, lookup_type, sql, params):\n         \"\"\"\n         Support EXTRACT with a user-defined function django_date_extract()\n         that's registered in connect(). Use single quotes because this is a\n         string and could otherwise cause a collision with a field name.\n         \"\"\"\n-        return \"django_date_extract('%s', %s)\" % (lookup_type.lower(), field_name)\n+        return f\"django_date_extract(%s, {sql})\", (lookup_type.lower(), *params)\n \n     def fetch_returned_insert_rows(self, cursor):\n         \"\"\"\n@@ -88,53 +88,53 @@ class DatabaseOperations(BaseDatabaseOperations):\n         \"\"\"Do nothing since formatting is handled in the custom function.\"\"\"\n         return sql\n \n-    def date_trunc_sql(self, lookup_type, field_name, tzname=None):\n-        return \"django_date_trunc('%s', %s, %s, %s)\" % (\n+    def date_trunc_sql(self, lookup_type, sql, params, tzname=None):\n+        return f\"django_date_trunc(%s, {sql}, %s, %s)\", (\n             lookup_type.lower(),\n-            field_name,\n+            *params,\n             *self._convert_tznames_to_sql(tzname),\n         )\n \n-    def time_trunc_sql(self, lookup_type, field_name, tzname=None):\n-        return \"django_time_trunc('%s', %s, %s, %s)\" % (\n+    def time_trunc_sql(self, lookup_type, sql, params, tzname=None):\n+        return f\"django_time_trunc(%s, {sql}, %s, %s)\", (\n             lookup_type.lower(),\n-            field_name,\n+            *params,\n             *self._convert_tznames_to_sql(tzname),\n         )\n \n     def _convert_tznames_to_sql(self, tzname):\n         if tzname and settings.USE_TZ:\n-            return \"'%s'\" % tzname, \"'%s'\" % self.connection.timezone_name\n-        return \"NULL\", \"NULL\"\n+            return tzname, self.connection.timezone_name\n+        return None, None\n \n-    def datetime_cast_date_sql(self, field_name, tzname):\n-        return \"django_datetime_cast_date(%s, %s, %s)\" % (\n-            field_name,\n+    def datetime_cast_date_sql(self, sql, params, tzname):\n+        return f\"django_datetime_cast_date({sql}, %s, %s)\", (\n+            *params,\n             *self._convert_tznames_to_sql(tzname),\n         )\n \n-    def datetime_cast_time_sql(self, field_name, tzname):\n-        return \"django_datetime_cast_time(%s, %s, %s)\" % (\n-            field_name,\n+    def datetime_cast_time_sql(self, sql, params, tzname):\n+        return f\"django_datetime_cast_time({sql}, %s, %s)\", (\n+            *params,\n             *self._convert_tznames_to_sql(tzname),\n         )\n \n-    def datetime_extract_sql(self, lookup_type, field_name, tzname):\n-        return \"django_datetime_extract('%s', %s, %s, %s)\" % (\n+    def datetime_extract_sql(self, lookup_type, sql, params, tzname):\n+        return f\"django_datetime_extract(%s, {sql}, %s, %s)\", (\n             lookup_type.lower(),\n-            field_name,\n+            *params,\n             *self._convert_tznames_to_sql(tzname),\n         )\n \n-    def datetime_trunc_sql(self, lookup_type, field_name, tzname):\n-        return \"django_datetime_trunc('%s', %s, %s, %s)\" % (\n+    def datetime_trunc_sql(self, lookup_type, sql, params, tzname):\n+        return f\"django_datetime_trunc(%s, {sql}, %s, %s)\", (\n             lookup_type.lower(),\n-            field_name,\n+            *params,\n             *self._convert_tznames_to_sql(tzname),\n         )\n \n-    def time_extract_sql(self, lookup_type, field_name):\n-        return \"django_time_extract('%s', %s)\" % (lookup_type.lower(), field_name)\n+    def time_extract_sql(self, lookup_type, sql, params):\n+        return f\"django_time_extract(%s, {sql})\", (lookup_type.lower(), *params)\n \n     def pk_default_value(self):\n         return \"NULL\"\ndiff --git a/django/db/models/functions/datetime.py b/django/db/models/functions/datetime.py\nindex 5f98e6bba1..f833c09973 100644\n--- a/django/db/models/functions/datetime.py\n+++ b/django/db/models/functions/datetime.py\n@@ -51,25 +51,31 @@ class Extract(TimezoneMixin, Transform):\n         super().__init__(expression, **extra)\n \n     def as_sql(self, compiler, connection):\n-        if not connection.ops.extract_trunc_lookup_pattern.fullmatch(self.lookup_name):\n-            raise ValueError(\"Invalid lookup_name: %s\" % self.lookup_name)\n         sql, params = compiler.compile(self.lhs)\n         lhs_output_field = self.lhs.output_field\n         if isinstance(lhs_output_field, DateTimeField):\n             tzname = self.get_tzname()\n-            sql = connection.ops.datetime_extract_sql(self.lookup_name, sql, tzname)\n+            sql, params = connection.ops.datetime_extract_sql(\n+                self.lookup_name, sql, tuple(params), tzname\n+            )\n         elif self.tzinfo is not None:\n             raise ValueError(\"tzinfo can only be used with DateTimeField.\")\n         elif isinstance(lhs_output_field, DateField):\n-            sql = connection.ops.date_extract_sql(self.lookup_name, sql)\n+            sql, params = connection.ops.date_extract_sql(\n+                self.lookup_name, sql, tuple(params)\n+            )\n         elif isinstance(lhs_output_field, TimeField):\n-            sql = connection.ops.time_extract_sql(self.lookup_name, sql)\n+            sql, params = connection.ops.time_extract_sql(\n+                self.lookup_name, sql, tuple(params)\n+            )\n         elif isinstance(lhs_output_field, DurationField):\n             if not connection.features.has_native_duration_field:\n                 raise ValueError(\n                     \"Extract requires native DurationField database support.\"\n                 )\n-            sql = connection.ops.time_extract_sql(self.lookup_name, sql)\n+            sql, params = connection.ops.time_extract_sql(\n+                self.lookup_name, sql, tuple(params)\n+            )\n         else:\n             # resolve_expression has already validated the output_field so this\n             # assert should never be hit.\n@@ -237,25 +243,29 @@ class TruncBase(TimezoneMixin, Transform):\n         super().__init__(expression, output_field=output_field, **extra)\n \n     def as_sql(self, compiler, connection):\n-        if not connection.ops.extract_trunc_lookup_pattern.fullmatch(self.kind):\n-            raise ValueError(\"Invalid kind: %s\" % self.kind)\n-        inner_sql, inner_params = compiler.compile(self.lhs)\n+        sql, params = compiler.compile(self.lhs)\n         tzname = None\n         if isinstance(self.lhs.output_field, DateTimeField):\n             tzname = self.get_tzname()\n         elif self.tzinfo is not None:\n             raise ValueError(\"tzinfo can only be used with DateTimeField.\")\n         if isinstance(self.output_field, DateTimeField):\n-            sql = connection.ops.datetime_trunc_sql(self.kind, inner_sql, tzname)\n+            sql, params = connection.ops.datetime_trunc_sql(\n+                self.kind, sql, tuple(params), tzname\n+            )\n         elif isinstance(self.output_field, DateField):\n-            sql = connection.ops.date_trunc_sql(self.kind, inner_sql, tzname)\n+            sql, params = connection.ops.date_trunc_sql(\n+                self.kind, sql, tuple(params), tzname\n+            )\n         elif isinstance(self.output_field, TimeField):\n-            sql = connection.ops.time_trunc_sql(self.kind, inner_sql, tzname)\n+            sql, params = connection.ops.time_trunc_sql(\n+                self.kind, sql, tuple(params), tzname\n+            )\n         else:\n             raise ValueError(\n                 \"Trunc only valid on DateField, TimeField, or DateTimeField.\"\n             )\n-        return sql, inner_params\n+        return sql, params\n \n     def resolve_expression(\n         self, query=None, allow_joins=True, reuse=None, summarize=False, for_save=False\n@@ -384,10 +394,9 @@ class TruncDate(TruncBase):\n \n     def as_sql(self, compiler, connection):\n         # Cast to date rather than truncate to date.\n-        lhs, lhs_params = compiler.compile(self.lhs)\n+        sql, params = compiler.compile(self.lhs)\n         tzname = self.get_tzname()\n-        sql = connection.ops.datetime_cast_date_sql(lhs, tzname)\n-        return sql, lhs_params\n+        return connection.ops.datetime_cast_date_sql(sql, tuple(params), tzname)\n \n \n class TruncTime(TruncBase):\n@@ -397,10 +406,9 @@ class TruncTime(TruncBase):\n \n     def as_sql(self, compiler, connection):\n         # Cast to time rather than truncate to time.\n-        lhs, lhs_params = compiler.compile(self.lhs)\n+        sql, params = compiler.compile(self.lhs)\n         tzname = self.get_tzname()\n-        sql = connection.ops.datetime_cast_time_sql(lhs, tzname)\n-        return sql, lhs_params\n+        return connection.ops.datetime_cast_time_sql(sql, tuple(params), tzname)\n \n \n class TruncHour(TruncBase):\ndiff --git a/docs/releases/4.1.txt b/docs/releases/4.1.txt\nindex ad6400c665..49bbf2dec2 100644\n--- a/docs/releases/4.1.txt\n+++ b/docs/releases/4.1.txt\n@@ -459,6 +459,20 @@ backends.\n   ``DatabaseOperations.insert_statement()`` method is replaced by\n   ``on_conflict`` that accepts ``django.db.models.constants.OnConflict``.\n \n+* Several date and time methods on ``DatabaseOperations`` now take ``sql`` and\n+  ``params`` arguments instead of ``field_name`` and return 2-tuple containing\n+  some SQL and the parameters to be interpolated into that SQL. The changed\n+  methods have these new signatures:\n+\n+  * ``DatabaseOperations.date_extract_sql(lookup_type, sql, params)``\n+  * ``DatabaseOperations.datetime_extract_sql(lookup_type, sql, params, tzname)``\n+  * ``DatabaseOperations.time_extract_sql(lookup_type, sql, params)``\n+  * ``DatabaseOperations.date_trunc_sql(lookup_type, sql, params, tzname=None)``\n+  * ``DatabaseOperations.datetime_trunc_sql(self, lookup_type, sql, params, tzname)``\n+  * ``DatabaseOperations.time_trunc_sql(lookup_type, sql, params, tzname=None)``\n+  * ``DatabaseOperations.datetime_cast_date_sql(sql, params, tzname)``\n+  * ``DatabaseOperations.datetime_cast_time_sql(sql, params, tzname)``\n+\n :mod:`django.contrib.gis`\n -------------------------\n \ndiff --git a/tests/backends/base/test_operations.py b/tests/backends/base/test_operations.py\nindex b19b7ee558..5260344da7 100644\n--- a/tests/backends/base/test_operations.py\n+++ b/tests/backends/base/test_operations.py\n@@ -115,49 +115,49 @@ class SimpleDatabaseOperationTests(SimpleTestCase):\n         with self.assertRaisesMessage(\n             NotImplementedError, self.may_require_msg % \"date_extract_sql\"\n         ):\n-            self.ops.date_extract_sql(None, None)\n+            self.ops.date_extract_sql(None, None, None)\n \n     def test_time_extract_sql(self):\n         with self.assertRaisesMessage(\n             NotImplementedError, self.may_require_msg % \"date_extract_sql\"\n         ):\n-            self.ops.time_extract_sql(None, None)\n+            self.ops.time_extract_sql(None, None, None)\n \n     def test_date_trunc_sql(self):\n         with self.assertRaisesMessage(\n             NotImplementedError, self.may_require_msg % \"date_trunc_sql\"\n         ):\n-            self.ops.date_trunc_sql(None, None)\n+            self.ops.date_trunc_sql(None, None, None)\n \n     def test_time_trunc_sql(self):\n         with self.assertRaisesMessage(\n             NotImplementedError, self.may_require_msg % \"time_trunc_sql\"\n         ):\n-            self.ops.time_trunc_sql(None, None)\n+            self.ops.time_trunc_sql(None, None, None)\n \n     def test_datetime_trunc_sql(self):\n         with self.assertRaisesMessage(\n             NotImplementedError, self.may_require_msg % \"datetime_trunc_sql\"\n         ):\n-            self.ops.datetime_trunc_sql(None, None, None)\n+            self.ops.datetime_trunc_sql(None, None, None, None)\n \n     def test_datetime_cast_date_sql(self):\n         with self.assertRaisesMessage(\n             NotImplementedError, self.may_require_msg % \"datetime_cast_date_sql\"\n         ):\n-            self.ops.datetime_cast_date_sql(None, None)\n+            self.ops.datetime_cast_date_sql(None, None, None)\n \n     def test_datetime_cast_time_sql(self):\n         with self.assertRaisesMessage(\n             NotImplementedError, self.may_require_msg % \"datetime_cast_time_sql\"\n         ):\n-            self.ops.datetime_cast_time_sql(None, None)\n+            self.ops.datetime_cast_time_sql(None, None, None)\n \n     def test_datetime_extract_sql(self):\n         with self.assertRaisesMessage(\n             NotImplementedError, self.may_require_msg % \"datetime_extract_sql\"\n         ):\n-            self.ops.datetime_extract_sql(None, None, None)\n+            self.ops.datetime_extract_sql(None, None, None, None)\n \n \n class DatabaseOperationTests(TestCase):\ndiff --git a/tests/custom_lookups/tests.py b/tests/custom_lookups/tests.py\nindex ece67a46a5..b730d7b5e1 100644\n--- a/tests/custom_lookups/tests.py\n+++ b/tests/custom_lookups/tests.py\n@@ -75,7 +75,7 @@ class YearTransform(models.Transform):\n \n     def as_sql(self, compiler, connection):\n         lhs_sql, params = compiler.compile(self.lhs)\n-        return connection.ops.date_extract_sql(\"year\", lhs_sql), params\n+        return connection.ops.date_extract_sql(\"year\", lhs_sql, params)\n \n     @property\n     def output_field(self):\ndiff --git a/tests/db_functions/datetime/test_extract_trunc.py b/tests/db_functions/datetime/test_extract_trunc.py\nindex bb70ed6094..00e3897e68 100644\n--- a/tests/db_functions/datetime/test_extract_trunc.py\n+++ b/tests/db_functions/datetime/test_extract_trunc.py\n@@ -13,6 +13,7 @@ except ImportError:\n     pytz = None\n \n from django.conf import settings\n+from django.db import DataError, OperationalError\n from django.db.models import (\n     DateField,\n     DateTimeField,\n@@ -244,8 +245,7 @@ class DateFunctionTests(TestCase):\n         self.create_model(start_datetime, end_datetime)\n         self.create_model(end_datetime, start_datetime)\n \n-        msg = \"Invalid lookup_name: \"\n-        with self.assertRaisesMessage(ValueError, msg):\n+        with self.assertRaises((DataError, OperationalError, ValueError)):\n             DTModel.objects.filter(\n                 start_datetime__year=Extract(\n                     \"start_datetime\", \"day' FROM start_datetime)) OR 1=1;--\"\n@@ -940,14 +940,18 @@ class DateFunctionTests(TestCase):\n             end_datetime = timezone.make_aware(end_datetime)\n         self.create_model(start_datetime, end_datetime)\n         self.create_model(end_datetime, start_datetime)\n-        msg = \"Invalid kind: \"\n-        with self.assertRaisesMessage(ValueError, msg):\n-            DTModel.objects.filter(\n+        # Database backends raise an exception or don't return any results.\n+        try:\n+            exists = DTModel.objects.filter(\n                 start_datetime__date=Trunc(\n                     \"start_datetime\",\n                     \"year', start_datetime)) OR 1=1;--\",\n                 )\n             ).exists()\n+        except (DataError, OperationalError):\n+            pass\n+        else:\n+            self.assertIs(exists, False)\n \n     def test_trunc_func(self):\n         start_datetime = datetime(999, 6, 15, 14, 30, 50, 321)\ndiff --git a/django/core/management/commands/inspectdb.py b/django/core/management/commands/inspectdb.py\nindex f33bcbdccf..d46180cd99 100644\n--- a/django/core/management/commands/inspectdb.py\n+++ b/django/core/management/commands/inspectdb.py\n@@ -127,12 +127,14 @@ class Command(BaseCommand):\n                     yield \"# The error was: %s\" % e\n                     continue\n \n+                model_name = table2model(table_name)\n                 yield \"\"\n                 yield \"\"\n-                yield \"class %s(models.Model):\" % table2model(table_name)\n-                known_models.append(table2model(table_name))\n+                yield \"class %s(models.Model):\" % model_name\n+                known_models.append(model_name)\n                 used_column_names = []  # Holds column names used in the table so far\n                 column_to_field_name = {}  # Maps column names to names of model fields\n+                used_relations = set()  # Holds foreign relations used in the table.\n                 for row in table_description:\n                     comment_notes = (\n                         []\n@@ -186,6 +188,12 @@ class Command(BaseCommand):\n                             field_type = \"%s(%s\" % (rel_type, rel_to)\n                         else:\n                             field_type = \"%s('%s'\" % (rel_type, rel_to)\n+                        if rel_to in used_relations:\n+                            extra_params[\"related_name\"] = \"%s_%s_set\" % (\n+                                model_name.lower(),\n+                                att_name,\n+                            )\n+                        used_relations.add(rel_to)\n                     else:\n                         # Calling `get_field_type` to get the field type string and any\n                         # additional parameters and notes.\nObtaining file:///testbed\n  Installing build dependencies: started\n  Installing build dependencies: finished with status 'done'\n  Checking if build backend supports build_editable: started\n  Checking if build backend supports build_editable: finished with status 'done'\n  Getting requirements to build editable: started\n  Getting requirements to build editable: finished with status 'done'\n  Preparing editable metadata (pyproject.toml): started\n  Preparing editable metadata (pyproject.toml): finished with status 'done'\nRequirement already satisfied: asgiref>=3.5.2 in /opt/miniconda3/envs/testbed/lib/python3.9/site-packages (from Django==4.2.dev20220706054007) (3.8.1)\nRequirement already satisfied: sqlparse>=0.2.2 in /opt/miniconda3/envs/testbed/lib/python3.9/site-packages (from Django==4.2.dev20220706054007) (0.5.1)\nRequirement already satisfied: typing-extensions>=4 in /opt/miniconda3/envs/testbed/lib/python3.9/site-packages (from asgiref>=3.5.2->Django==4.2.dev20220706054007) (4.12.2)\nBuilding wheels for collected packages: Django\n  Building editable for Django (pyproject.toml): started\n  Building editable for Django (pyproject.toml): finished with status 'done'\n  Created wheel for Django: filename=Django-4.2.dev20220706054007-0.editable-py3-none-any.whl size=27120 sha256=1c2c56fbb42c4d039bf901f02d8b4a504d1392c702c0fdb096c8b0a450996431\n  Stored in directory: /tmp/pip-ephem-wheel-cache-2hu9n1lp/wheels/7d/66/67/70d1ee2124ccf21d601c352e25cdca10f611f7c8b3f9ffb9e4\nSuccessfully built Django\nInstalling collected packages: Django\n  Attempting uninstall: Django\n    Found existing installation: Django 4.2.dev20220706054007\n    Uninstalling Django-4.2.dev20220706054007:\n      Successfully uninstalled Django-4.2.dev20220706054007\nSuccessfully installed Django-4.2.dev20220706054007\nTesting against Django installed in '/testbed/django'\nImporting application inspectdb\nFound 24 test(s).\nSkipping setup of unused database(s): other.\nOperations to perform:\n  Synchronize unmigrated apps: auth, contenttypes, inspectdb, messages, sessions, staticfiles\n  Apply all migrations: admin, sites\nSynchronizing apps without migrations:\n  Creating tables...\n    Creating table django_content_type\n    Creating table auth_permission\n    Creating table auth_group\n    Creating table auth_user\n    Creating table django_session\n    Creating table inspectdb_people\n    Creating table inspectdb_message\n    Creating table inspectdb_peopledata\n    Creating table inspectdb_peoplemoredata\n    Creating table inspectdb_foreignkeytofield\n    Creating table inspectdb_digitsincolumnname\n    Creating table inspectdb_special.table name\n    Creating table inspectdb_columntypes\n    Creating table inspectdb_jsonfieldcolumntype\n    Creating table inspectdb_charfielddbcollation\n    Creating table inspectdb_textfielddbcollation\n    Creating table inspectdb_uniquetogether\n    Creating table inspectdb_funcuniqueconstraint\n    Running deferred SQL...\nRunning migrations:\n  Applying admin.0001_initial... OK\n  Applying admin.0002_logentry_remove_auto_add... OK\n  Applying admin.0003_logentry_add_action_flag_choices... OK\n  Applying sites.0001_initial... OK\n  Applying sites.0002_alter_domain_unique... OK\nSystem check identified no issues (2 silenced).\n", {}]