[{"repo": "pytest-dev/pytest", "instance_id": "pytest-dev__pytest-11148", "base_commit": "2f7415cfbc4b6ca62f9013f1abd27136f46b9653", "patch": "diff --git a/src/_pytest/pathlib.py b/src/_pytest/pathlib.py\n--- a/src/_pytest/pathlib.py\n+++ b/src/_pytest/pathlib.py\n@@ -523,6 +523,8 @@ def import_path(\n \n     if mode is ImportMode.importlib:\n         module_name = module_name_from_path(path, root)\n+        with contextlib.suppress(KeyError):\n+            return sys.modules[module_name]\n \n         for meta_importer in sys.meta_path:\n             spec = meta_importer.find_spec(module_name, [str(path.parent)])\n", "test_patch": "diff --git a/testing/acceptance_test.py b/testing/acceptance_test.py\n--- a/testing/acceptance_test.py\n+++ b/testing/acceptance_test.py\n@@ -1315,3 +1315,38 @@ def test_stuff():\n     )\n     res = pytester.runpytest()\n     res.stdout.fnmatch_lines([\"*Did you mean to use `assert` instead of `return`?*\"])\n+\n+\n+def test_doctest_and_normal_imports_with_importlib(pytester: Pytester) -> None:\n+    \"\"\"\n+    Regression test for #10811: previously import_path with ImportMode.importlib would\n+    not return a module if already in sys.modules, resulting in modules being imported\n+    multiple times, which causes problems with modules that have import side effects.\n+    \"\"\"\n+    # Uses the exact reproducer form #10811, given it is very minimal\n+    # and illustrates the problem well.\n+    pytester.makepyfile(\n+        **{\n+            \"pmxbot/commands.py\": \"from . import logging\",\n+            \"pmxbot/logging.py\": \"\",\n+            \"tests/__init__.py\": \"\",\n+            \"tests/test_commands.py\": \"\"\"\n+                import importlib\n+                from pmxbot import logging\n+\n+                class TestCommands:\n+                    def test_boo(self):\n+                        assert importlib.import_module('pmxbot.logging') is logging\n+                \"\"\",\n+        }\n+    )\n+    pytester.makeini(\n+        \"\"\"\n+        [pytest]\n+        addopts=\n+            --doctest-modules\n+            --import-mode importlib\n+        \"\"\"\n+    )\n+    result = pytester.runpytest_subprocess()\n+    result.stdout.fnmatch_lines(\"*1 passed*\")\ndiff --git a/testing/test_pathlib.py b/testing/test_pathlib.py\n--- a/testing/test_pathlib.py\n+++ b/testing/test_pathlib.py\n@@ -7,6 +7,7 @@\n from types import ModuleType\n from typing import Any\n from typing import Generator\n+from typing import Iterator\n \n import pytest\n from _pytest.monkeypatch import MonkeyPatch\n@@ -282,29 +283,36 @@ def test_invalid_path(self, tmp_path: Path) -> None:\n             import_path(tmp_path / \"invalid.py\", root=tmp_path)\n \n     @pytest.fixture\n-    def simple_module(self, tmp_path: Path) -> Path:\n-        fn = tmp_path / \"_src/tests/mymod.py\"\n+    def simple_module(\n+        self, tmp_path: Path, request: pytest.FixtureRequest\n+    ) -> Iterator[Path]:\n+        name = f\"mymod_{request.node.name}\"\n+        fn = tmp_path / f\"_src/tests/{name}.py\"\n         fn.parent.mkdir(parents=True)\n         fn.write_text(\"def foo(x): return 40 + x\", encoding=\"utf-8\")\n-        return fn\n+        module_name = module_name_from_path(fn, root=tmp_path)\n+        yield fn\n+        sys.modules.pop(module_name, None)\n \n-    def test_importmode_importlib(self, simple_module: Path, tmp_path: Path) -> None:\n+    def test_importmode_importlib(\n+        self, simple_module: Path, tmp_path: Path, request: pytest.FixtureRequest\n+    ) -> None:\n         \"\"\"`importlib` mode does not change sys.path.\"\"\"\n         module = import_path(simple_module, mode=\"importlib\", root=tmp_path)\n         assert module.foo(2) == 42  # type: ignore[attr-defined]\n         assert str(simple_module.parent) not in sys.path\n         assert module.__name__ in sys.modules\n-        assert module.__name__ == \"_src.tests.mymod\"\n+        assert module.__name__ == f\"_src.tests.mymod_{request.node.name}\"\n         assert \"_src\" in sys.modules\n         assert \"_src.tests\" in sys.modules\n \n-    def test_importmode_twice_is_different_module(\n+    def test_remembers_previous_imports(\n         self, simple_module: Path, tmp_path: Path\n     ) -> None:\n-        \"\"\"`importlib` mode always returns a new module.\"\"\"\n+        \"\"\"`importlib` mode called remembers previous module (#10341, #10811).\"\"\"\n         module1 = import_path(simple_module, mode=\"importlib\", root=tmp_path)\n         module2 = import_path(simple_module, mode=\"importlib\", root=tmp_path)\n-        assert module1 is not module2\n+        assert module1 is module2\n \n     def test_no_meta_path_found(\n         self, simple_module: Path, monkeypatch: MonkeyPatch, tmp_path: Path\n@@ -317,6 +325,9 @@ def test_no_meta_path_found(\n         # mode='importlib' fails if no spec is found to load the module\n         import importlib.util\n \n+        # Force module to be re-imported.\n+        del sys.modules[module.__name__]\n+\n         monkeypatch.setattr(\n             importlib.util, \"spec_from_file_location\", lambda *args: None\n         )\n", "problem_statement": "Module imported twice under import-mode=importlib\nIn pmxbot/pmxbot@7f189ad, I'm attempting to switch pmxbot off of pkg_resources style namespace packaging to PEP 420 namespace packages. To do so, I've needed to switch to `importlib` for the `import-mode` and re-organize the tests to avoid import errors on the tests.\r\n\r\nYet even after working around these issues, the tests are failing when the effect of `core.initialize()` doesn't seem to have had any effect.\r\n\r\nInvestigating deeper, I see that initializer is executed and performs its actions (setting a class variable `pmxbot.logging.Logger.store`), but when that happens, there are two different versions of `pmxbot.logging` present, one in `sys.modules` and another found in `tests.unit.test_commands.logging`:\r\n\r\n```\r\n=========================================================================== test session starts ===========================================================================\r\nplatform darwin -- Python 3.11.1, pytest-7.2.0, pluggy-1.0.0\r\ncachedir: .tox/python/.pytest_cache\r\nrootdir: /Users/jaraco/code/pmxbot/pmxbot, configfile: pytest.ini\r\nplugins: black-0.3.12, mypy-0.10.3, jaraco.test-5.3.0, checkdocs-2.9.0, flake8-1.1.1, enabler-2.0.0, jaraco.mongodb-11.2.1, pmxbot-1122.14.3.dev13+g7f189ad\r\ncollected 421 items / 180 deselected / 241 selected                                                                                                                       \r\nrun-last-failure: rerun previous 240 failures (skipped 14 files)\r\n\r\ntests/unit/test_commands.py E\r\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> traceback >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>\r\n\r\ncls = <class 'tests.unit.test_commands.TestCommands'>\r\n\r\n    @classmethod\r\n    def setup_class(cls):\r\n        path = os.path.dirname(os.path.abspath(__file__))\r\n        configfile = os.path.join(path, 'testconf.yaml')\r\n        config = pmxbot.dictlib.ConfigDict.from_yaml(configfile)\r\n        cls.bot = core.initialize(config)\r\n>       logging.Logger.store.message(\"logged\", \"testrunner\", \"some text\")\r\nE       AttributeError: type object 'Logger' has no attribute 'store'\r\n\r\ntests/unit/test_commands.py:37: AttributeError\r\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> entering PDB >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>\r\n\r\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> PDB post_mortem (IO-capturing turned off) >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>\r\n> /Users/jaraco/code/pmxbot/pmxbot/tests/unit/test_commands.py(37)setup_class()\r\n-> logging.Logger.store.message(\"logged\", \"testrunner\", \"some text\")\r\n(Pdb) logging.Logger\r\n<class 'pmxbot.logging.Logger'>\r\n(Pdb) logging\r\n<module 'pmxbot.logging' from '/Users/jaraco/code/pmxbot/pmxbot/pmxbot/logging.py'>\r\n(Pdb) import sys\r\n(Pdb) sys.modules['pmxbot.logging']\r\n<module 'pmxbot.logging' from '/Users/jaraco/code/pmxbot/pmxbot/pmxbot/logging.py'>\r\n(Pdb) sys.modules['pmxbot.logging'] is logging\r\nFalse\r\n```\r\n\r\nI haven't yet made a minimal reproducer, but I wanted to first capture this condition.\r\n\n", "hints_text": "In pmxbot/pmxbot@3adc54c, I've managed to pare down the project to a bare minimum reproducer. The issue only happens when `import-mode=importlib` and `doctest-modules` and one of the modules imports another module.\r\n\r\nThis issue may be related to (or same as) #10341.\r\n\r\nI think you'll agree this is pretty basic behavior that should be supported.\r\n\r\nI'm not even aware of a good workaround.\nHey @jaraco, thanks for the reproducer! \r\n\r\nI found the problem, will open a PR shortly.", "created_at": "2023-06-29T00:04:33Z", "version": "8.0", "FAIL_TO_PASS": "[\"testing/test_pathlib.py::TestImportPath::test_remembers_previous_imports\", \"testing/acceptance_test.py::test_doctest_and_normal_imports_with_importlib\"]", "PASS_TO_PASS": "[\"testing/acceptance_test.py::TestGeneralUsage::test_docstring_on_hookspec\", \"testing/acceptance_test.py::TestInvocationVariants::test_invoke_with_invalid_type\", \"testing/acceptance_test.py::TestInvocationVariants::test_invoke_plugin_api\", \"testing/acceptance_test.py::TestInvocationVariants::test_core_backward_compatibility\", \"testing/acceptance_test.py::TestInvocationVariants::test_has_plugin\", \"testing/test_pathlib.py::TestFNMatcherPort::test_matching[*.py-foo.py]\", \"testing/test_pathlib.py::TestFNMatcherPort::test_matching[*.py-bar/foo.py]\", \"testing/test_pathlib.py::TestFNMatcherPort::test_matching[test_*.py-foo/test_foo.py]\", \"testing/test_pathlib.py::TestFNMatcherPort::test_matching[tests/*.py-tests/foo.py]\", \"testing/test_pathlib.py::TestFNMatcherPort::test_matching[/c/*.py-/c/foo.py]\", \"testing/test_pathlib.py::TestFNMatcherPort::test_matching[/c/foo/*.py-/c/foo/foo.py]\", \"testing/test_pathlib.py::TestFNMatcherPort::test_matching[tests/**/test*.py-tests/foo/test_foo.py]\", \"testing/test_pathlib.py::TestFNMatcherPort::test_matching[tests/**/doc/test*.py-tests/foo/bar/doc/test_foo.py]\", \"testing/test_pathlib.py::TestFNMatcherPort::test_matching[tests/**/doc/**/test*.py-tests/foo/doc/bar/test_foo.py]\", \"testing/test_pathlib.py::TestFNMatcherPort::test_matching_abspath\", \"testing/test_pathlib.py::TestFNMatcherPort::test_not_matching[*.py-foo.pyc]\", \"testing/test_pathlib.py::TestFNMatcherPort::test_not_matching[*.py-foo/foo.pyc]\", \"testing/test_pathlib.py::TestFNMatcherPort::test_not_matching[tests/*.py-foo/foo.py]\", \"testing/test_pathlib.py::TestFNMatcherPort::test_not_matching[/c/*.py-/d/foo.py]\", \"testing/test_pathlib.py::TestFNMatcherPort::test_not_matching[/c/foo/*.py-/d/foo/foo.py]\", \"testing/test_pathlib.py::TestFNMatcherPort::test_not_matching[tests/**/test*.py-tests/foo.py]\", \"testing/test_pathlib.py::TestFNMatcherPort::test_not_matching[tests/**/test*.py-foo/test_foo.py]\", \"testing/test_pathlib.py::TestFNMatcherPort::test_not_matching[tests/**/doc/test*.py-tests/foo/bar/doc/foo.py]\", \"testing/test_pathlib.py::TestFNMatcherPort::test_not_matching[tests/**/doc/test*.py-tests/foo/bar/test_foo.py]\", \"testing/test_pathlib.py::TestImportPath::test_smoke_test\", \"testing/test_pathlib.py::TestImportPath::test_import_path_missing_file\", \"testing/test_pathlib.py::TestImportPath::test_renamed_dir_creates_mismatch\", \"testing/test_pathlib.py::TestImportPath::test_messy_name\", \"testing/test_pathlib.py::TestImportPath::test_dir\", \"testing/test_pathlib.py::TestImportPath::test_a\", \"testing/test_pathlib.py::TestImportPath::test_b\", \"testing/test_pathlib.py::TestImportPath::test_c\", \"testing/test_pathlib.py::TestImportPath::test_d\", \"testing/test_pathlib.py::TestImportPath::test_import_after\", \"testing/test_pathlib.py::TestImportPath::test_check_filepath_consistency\", \"testing/test_pathlib.py::TestImportPath::test_issue131_on__init__\", \"testing/test_pathlib.py::TestImportPath::test_ensuresyspath_append\", \"testing/test_pathlib.py::TestImportPath::test_invalid_path\", \"testing/test_pathlib.py::TestImportPath::test_importmode_importlib\", \"testing/test_pathlib.py::TestImportPath::test_no_meta_path_found\", \"testing/test_pathlib.py::test_resolve_package_path\", \"testing/test_pathlib.py::test_package_unimportable\", \"testing/test_pathlib.py::test_access_denied_during_cleanup\", \"testing/test_pathlib.py::test_long_path_during_cleanup\", \"testing/test_pathlib.py::test_get_extended_length_path_str\", \"testing/test_pathlib.py::test_suppress_error_removing_lock\", \"testing/test_pathlib.py::test_bestrelpath\", \"testing/test_pathlib.py::test_commonpath\", \"testing/test_pathlib.py::test_visit_ignores_errors\", \"testing/test_pathlib.py::TestImportLibMode::test_importmode_importlib_with_dataclass\", \"testing/test_pathlib.py::TestImportLibMode::test_importmode_importlib_with_pickle\", \"testing/test_pathlib.py::TestImportLibMode::test_importmode_importlib_with_pickle_separate_modules\", \"testing/test_pathlib.py::TestImportLibMode::test_module_name_from_path\", \"testing/test_pathlib.py::TestImportLibMode::test_insert_missing_modules\", \"testing/test_pathlib.py::TestImportLibMode::test_parent_contains_child_module_attribute\", \"testing/acceptance_test.py::TestGeneralUsage::test_config_error\", \"testing/acceptance_test.py::TestGeneralUsage::test_root_conftest_syntax_error\", \"testing/acceptance_test.py::TestGeneralUsage::test_early_hook_error_issue38_1\", \"testing/acceptance_test.py::TestGeneralUsage::test_early_hook_configure_error_issue38\", \"testing/acceptance_test.py::TestGeneralUsage::test_file_not_found\", \"testing/acceptance_test.py::TestGeneralUsage::test_file_not_found_unconfigure_issue143\", \"testing/acceptance_test.py::TestGeneralUsage::test_config_preparse_plugin_option\", \"testing/acceptance_test.py::TestGeneralUsage::test_early_load_setuptools_name[True]\", \"testing/acceptance_test.py::TestGeneralUsage::test_early_load_setuptools_name[False]\", \"testing/acceptance_test.py::TestGeneralUsage::test_assertion_rewrite[prepend]\", \"testing/acceptance_test.py::TestGeneralUsage::test_assertion_rewrite[append]\", \"testing/acceptance_test.py::TestGeneralUsage::test_assertion_rewrite[importlib]\", \"testing/acceptance_test.py::TestGeneralUsage::test_nested_import_error\", \"testing/acceptance_test.py::TestGeneralUsage::test_not_collectable_arguments\", \"testing/acceptance_test.py::TestGeneralUsage::test_better_reporting_on_conftest_load_failure\", \"testing/acceptance_test.py::TestGeneralUsage::test_early_skip\", \"testing/acceptance_test.py::TestGeneralUsage::test_issue88_initial_file_multinodes\", \"testing/acceptance_test.py::TestGeneralUsage::test_issue93_initialnode_importing_capturing\", \"testing/acceptance_test.py::TestGeneralUsage::test_conftest_printing_shows_if_error\", \"testing/acceptance_test.py::TestGeneralUsage::test_issue109_sibling_conftests_not_loaded\", \"testing/acceptance_test.py::TestGeneralUsage::test_directory_skipped\", \"testing/acceptance_test.py::TestGeneralUsage::test_multiple_items_per_collector_byid\", \"testing/acceptance_test.py::TestGeneralUsage::test_skip_on_generated_funcarg_id\", \"testing/acceptance_test.py::TestGeneralUsage::test_direct_addressing_selects\", \"testing/acceptance_test.py::TestGeneralUsage::test_direct_addressing_notfound\", \"testing/acceptance_test.py::TestGeneralUsage::test_initialization_error_issue49\", \"testing/acceptance_test.py::TestGeneralUsage::test_issue134_report_error_when_collecting_member[test_fun.py::test_a]\", \"testing/acceptance_test.py::TestGeneralUsage::test_report_all_failed_collections_initargs\", \"testing/acceptance_test.py::TestGeneralUsage::test_namespace_import_doesnt_confuse_import_hook\", \"testing/acceptance_test.py::TestGeneralUsage::test_unknown_option\", \"testing/acceptance_test.py::TestGeneralUsage::test_getsourcelines_error_issue553\", \"testing/acceptance_test.py::TestGeneralUsage::test_plugins_given_as_strings\", \"testing/acceptance_test.py::TestGeneralUsage::test_parametrized_with_bytes_regex\", \"testing/acceptance_test.py::TestGeneralUsage::test_parametrized_with_null_bytes\", \"testing/acceptance_test.py::TestInvocationVariants::test_earlyinit\", \"testing/acceptance_test.py::TestInvocationVariants::test_pydoc\", \"testing/acceptance_test.py::TestInvocationVariants::test_import_star_pytest\", \"testing/acceptance_test.py::TestInvocationVariants::test_double_pytestcmdline\", \"testing/acceptance_test.py::TestInvocationVariants::test_python_minus_m_invocation_ok\", \"testing/acceptance_test.py::TestInvocationVariants::test_python_minus_m_invocation_fail\", \"testing/acceptance_test.py::TestInvocationVariants::test_python_pytest_package\", \"testing/acceptance_test.py::TestInvocationVariants::test_invoke_with_path\", \"testing/acceptance_test.py::TestInvocationVariants::test_pyargs_importerror\", \"testing/acceptance_test.py::TestInvocationVariants::test_pyargs_only_imported_once\", \"testing/acceptance_test.py::TestInvocationVariants::test_pyargs_filename_looks_like_module\", \"testing/acceptance_test.py::TestInvocationVariants::test_cmdline_python_package\", \"testing/acceptance_test.py::TestInvocationVariants::test_cmdline_python_namespace_package\", \"testing/acceptance_test.py::TestInvocationVariants::test_invoke_test_and_doctestmodules\", \"testing/acceptance_test.py::TestInvocationVariants::test_cmdline_python_package_symlink\", \"testing/acceptance_test.py::TestInvocationVariants::test_cmdline_python_package_not_exists\", \"testing/acceptance_test.py::TestInvocationVariants::test_doctest_id\", \"testing/acceptance_test.py::TestDurations::test_calls\", \"testing/acceptance_test.py::TestDurations::test_calls_show_2\", \"testing/acceptance_test.py::TestDurations::test_calls_showall\", \"testing/acceptance_test.py::TestDurations::test_calls_showall_verbose\", \"testing/acceptance_test.py::TestDurations::test_with_deselected\", \"testing/acceptance_test.py::TestDurations::test_with_failing_collection\", \"testing/acceptance_test.py::TestDurations::test_with_not\", \"testing/acceptance_test.py::TestDurationsWithFixture::test_setup_function\", \"testing/acceptance_test.py::test_zipimport_hook\", \"testing/acceptance_test.py::test_import_plugin_unicode_name\", \"testing/acceptance_test.py::test_pytest_plugins_as_module\", \"testing/acceptance_test.py::test_deferred_hook_checking\", \"testing/acceptance_test.py::test_fixture_order_respects_scope\", \"testing/acceptance_test.py::test_fixture_mock_integration\", \"testing/acceptance_test.py::test_usage_error_code\", \"testing/acceptance_test.py::test_warn_on_async_function\", \"testing/acceptance_test.py::test_warn_on_async_gen_function\", \"testing/acceptance_test.py::test_no_brokenpipeerror_message\", \"testing/acceptance_test.py::test_function_return_non_none_warning\", \"testing/acceptance_test.py::test_fixture_values_leak\", \"testing/acceptance_test.py::test_frame_leak_on_failing_test\", \"testing/acceptance_test.py::test_pdb_can_be_rewritten\", \"testing/acceptance_test.py::test_tee_stdio_captures_and_live_prints\"]", "environment_setup_commit": "10056865d2a4784934ce043908a0e78d0578f677"}, "On branch main\nChanges not staged for commit:\n  (use \"git add <file>...\" to update what will be committed)\n  (use \"git restore <file>...\" to discard changes in working directory)\n\tmodified:   src/_pytest/pathlib.py\n\nno changes added to commit (use \"git add\" and/or \"git commit -a\")\ncommit 2f7415cfbc4b6ca62f9013f1abd27136f46b9653\nAuthor: akhilramkee <31619526+akhilramkee@users.noreply.github.com>\nDate:   Sat Jul 1 20:42:41 2023 +0530\n\n    Add child modules as attributes of parent modules. (#10338)\n    \n    Failing to add child modules as attributes of parent module will prevent them from being accessible through parent module.\n    \n    Fix #10337\n\ndiff --git a/changelog/10337.bugfix.rst b/changelog/10337.bugfix.rst\nnew file mode 100644\nindex 000000000..c5eeff19d\n--- /dev/null\n+++ b/changelog/10337.bugfix.rst\n@@ -0,0 +1,2 @@\n+Fixed but that fake intermediate modules generated by ``--import-mode=importlib`` would not include the\n+child modules as attributes of the parent modules.\ndiff --git a/src/_pytest/pathlib.py b/src/_pytest/pathlib.py\nindex 70383e4b5..e43310ef0 100644\n--- a/src/_pytest/pathlib.py\n+++ b/src/_pytest/pathlib.py\n@@ -633,6 +633,9 @@ def insert_missing_modules(modules: Dict[str, ModuleType], module_name: str) ->\n     otherwise \"src.tests.test_foo\" is not importable by ``__import__``.\n     \"\"\"\n     module_parts = module_name.split(\".\")\n+    child_module: Union[ModuleType, None] = None\n+    module: Union[ModuleType, None] = None\n+    child_name: str = \"\"\n     while module_name:\n         if module_name not in modules:\n             try:\n@@ -642,13 +645,22 @@ def insert_missing_modules(modules: Dict[str, ModuleType], module_name: str) ->\n                 # ourselves to fall back to creating a dummy module.\n                 if not sys.meta_path:\n                     raise ModuleNotFoundError\n-                importlib.import_module(module_name)\n+                module = importlib.import_module(module_name)\n             except ModuleNotFoundError:\n                 module = ModuleType(\n                     module_name,\n                     doc=\"Empty module created by pytest's importmode=importlib.\",\n                 )\n+        else:\n+            module = modules[module_name]\n+        if child_module:\n+            # Add child attribute to the parent that can reference the child\n+            # modules.\n+            if not hasattr(module, child_name):\n+                setattr(module, child_name, child_module)\n                 modules[module_name] = module\n+        # Keep track of the child module while moving up the tree.\n+        child_module, child_name = module, module_name.rpartition(\".\")[-1]\n         module_parts.pop(-1)\n         module_name = \".\".join(module_parts)\n \ndiff --git a/testing/test_pathlib.py b/testing/test_pathlib.py\nindex 56c54e484..c15a81ea1 100644\n--- a/testing/test_pathlib.py\n+++ b/testing/test_pathlib.py\n@@ -592,3 +592,15 @@ class TestImportLibMode:\n         modules = {}\n         insert_missing_modules(modules, \"\")\n         assert modules == {}\n+\n+    def test_parent_contains_child_module_attribute(\n+        self, monkeypatch: MonkeyPatch, tmp_path: Path\n+    ):\n+        monkeypatch.chdir(tmp_path)\n+        # Use 'xxx' and 'xxy' as parent names as they are unlikely to exist and\n+        # don't end up being imported.\n+        modules = {\"xxx.tests.foo\": ModuleType(\"xxx.tests.foo\")}\n+        insert_missing_modules(modules, \"xxx.tests.foo\")\n+        assert sorted(modules) == [\"xxx\", \"xxx.tests\", \"xxx.tests.foo\"]\n+        assert modules[\"xxx\"].tests is modules[\"xxx.tests\"]\n+        assert modules[\"xxx.tests\"].foo is modules[\"xxx.tests.foo\"]\ndiff --git a/src/_pytest/pathlib.py b/src/_pytest/pathlib.py\nindex e43310ef0..14fb2e3ae 100644\n--- a/src/_pytest/pathlib.py\n+++ b/src/_pytest/pathlib.py\n@@ -523,6 +523,8 @@ def import_path(\n \n     if mode is ImportMode.importlib:\n         module_name = module_name_from_path(path, root)\n+        with contextlib.suppress(KeyError):\n+            return sys.modules[module_name]\n \n         for meta_importer in sys.meta_path:\n             spec = meta_importer.find_spec(module_name, [str(path.parent)])\nObtaining file:///testbed\n  Installing build dependencies: started\n  Installing build dependencies: finished with status 'done'\n  Checking if build backend supports build_editable: started\n  Checking if build backend supports build_editable: finished with status 'done'\n  Getting requirements to build editable: started\n  Getting requirements to build editable: finished with status 'done'\n  Preparing editable metadata (pyproject.toml): started\n  Preparing editable metadata (pyproject.toml): finished with status 'done'\nRequirement already satisfied: iniconfig in /opt/miniconda3/envs/testbed/lib/python3.9/site-packages (from pytest==8.0.0.dev46+g2f7415cfb.d20220101) (2.0.0)\nRequirement already satisfied: packaging in /opt/miniconda3/envs/testbed/lib/python3.9/site-packages (from pytest==8.0.0.dev46+g2f7415cfb.d20220101) (23.1)\nRequirement already satisfied: pluggy<2.0,>=0.12 in /opt/miniconda3/envs/testbed/lib/python3.9/site-packages (from pytest==8.0.0.dev46+g2f7415cfb.d20220101) (1.3.0)\nRequirement already satisfied: exceptiongroup>=1.0.0rc8 in /opt/miniconda3/envs/testbed/lib/python3.9/site-packages (from pytest==8.0.0.dev46+g2f7415cfb.d20220101) (1.1.3)\nRequirement already satisfied: tomli>=1.0.0 in /opt/miniconda3/envs/testbed/lib/python3.9/site-packages (from pytest==8.0.0.dev46+g2f7415cfb.d20220101) (2.0.1)\nBuilding wheels for collected packages: pytest\n  Building editable for pytest (pyproject.toml): started\n  Building editable for pytest (pyproject.toml): finished with status 'done'\n  Created wheel for pytest: filename=pytest-8.0.0.dev46+g2f7415cfb.d20220101-0.editable-py3-none-any.whl size=5347 sha256=853ea6975b42c4da469fba73d941a44040f72e08217ff214db458234339a0c2b\n  Stored in directory: /tmp/pip-ephem-wheel-cache-sff_2uyf/wheels/7d/66/67/70d1ee2124ccf21d601c352e25cdca10f611f7c8b3f9ffb9e4\nSuccessfully built pytest\nInstalling collected packages: pytest\n  Attempting uninstall: pytest\n    Found existing installation: pytest 8.0.0.dev46+g2f7415cfb\n    Uninstalling pytest-8.0.0.dev46+g2f7415cfb:\n      Successfully uninstalled pytest-8.0.0.dev46+g2f7415cfb\nSuccessfully installed pytest-8.0.0.dev46+g2f7415cfb.d20220101\n============================= test session starts ==============================\nplatform linux -- Python 3.9.20, pytest-8.0.0.dev46+g2f7415cfb.d20220101, pluggy-1.3.0\nrootdir: /testbed\nconfigfile: pyproject.toml\ncollected 133 items\n\ntesting/acceptance_test.py .....                                         [  3%]\ntesting/test_pathlib.py .............................................s.. [ 39%]\n....                                                                     [ 42%]\ntesting/acceptance_test.py ............................................. [ 76%]\n.....x.........................                                          [100%]\n\n==================================== PASSES ====================================\n______________________ TestGeneralUsage.test_config_error ______________________\n----------------------------- Captured stdout call -----------------------------\npytest_unconfigure_called\n----------------------------- Captured stderr call -----------------------------\nERROR: hello\n\n_______________ TestGeneralUsage.test_root_conftest_syntax_error _______________\n----------------------------- Captured stderr call -----------------------------\nImportError while loading conftest '/tmp/pytest-of-root/pytest-0/test_root_conftest_syntax_error0/conftest.py'.\nconftest.py:1: in <module>\n    raise SyntaxError\nE   SyntaxError: <no detail available>\n_______________ TestGeneralUsage.test_early_hook_error_issue38_1 _______________\n----------------------------- Captured stdout call -----------------------------\nINTERNALERROR> Traceback (most recent call last):\nINTERNALERROR>   File \"/testbed/src/_pytest/main.py\", line 268, in wrap_session\nINTERNALERROR>     config.hook.pytest_sessionstart(session=session)\nINTERNALERROR>   File \"/opt/miniconda3/envs/testbed/lib/python3.9/site-packages/pluggy/_hooks.py\", line 493, in __call__\nINTERNALERROR>     return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)\nINTERNALERROR>   File \"/opt/miniconda3/envs/testbed/lib/python3.9/site-packages/pluggy/_manager.py\", line 115, in _hookexec\nINTERNALERROR>     return self._inner_hookexec(hook_name, methods, kwargs, firstresult)\nINTERNALERROR>   File \"/opt/miniconda3/envs/testbed/lib/python3.9/site-packages/pluggy/_manager.py\", line 457, in traced_hookexec\nINTERNALERROR>     return outcome.get_result()\nINTERNALERROR>   File \"/opt/miniconda3/envs/testbed/lib/python3.9/site-packages/pluggy/_result.py\", line 114, in get_result\nINTERNALERROR>     raise exc.with_traceback(exc.__traceback__)\nINTERNALERROR>   File \"/opt/miniconda3/envs/testbed/lib/python3.9/site-packages/pluggy/_result.py\", line 76, in from_call\nINTERNALERROR>     result = func()\nINTERNALERROR>   File \"/opt/miniconda3/envs/testbed/lib/python3.9/site-packages/pluggy/_manager.py\", line 454, in <lambda>\nINTERNALERROR>     lambda: oldcall(hook_name, hook_impls, caller_kwargs, firstresult)\nINTERNALERROR>   File \"/opt/miniconda3/envs/testbed/lib/python3.9/site-packages/pluggy/_callers.py\", line 152, in _multicall\nINTERNALERROR>     return outcome.get_result()\nINTERNALERROR>   File \"/opt/miniconda3/envs/testbed/lib/python3.9/site-packages/pluggy/_result.py\", line 114, in get_result\nINTERNALERROR>     raise exc.with_traceback(exc.__traceback__)\nINTERNALERROR>   File \"/opt/miniconda3/envs/testbed/lib/python3.9/site-packages/pluggy/_callers.py\", line 77, in _multicall\nINTERNALERROR>     res = hook_impl.function(*args)\nINTERNALERROR>   File \"/tmp/pytest-of-root/pytest-0/test_early_hook_error_issue38_10/conftest.py\", line 2, in pytest_sessionstart\nINTERNALERROR>     0 / 0\nINTERNALERROR> ZeroDivisionError: division by zero\nINTERNALERROR> config = <_pytest.config.Config object at 0x7f5130d3d700>\nINTERNALERROR> doit = <function _main at 0x7f51316e81f0>\nINTERNALERROR> \nINTERNALERROR>     def wrap_session(\nINTERNALERROR>         config: Config, doit: Callable[[Config, \"Session\"], Optional[Union[int, ExitCode]]]\nINTERNALERROR>     ) -> Union[int, ExitCode]:\nINTERNALERROR>         \"\"\"Skeleton command line program.\"\"\"\nINTERNALERROR>         session = Session.from_config(config)\nINTERNALERROR>         session.exitstatus = ExitCode.OK\nINTERNALERROR>         initstate = 0\nINTERNALERROR>         try:\nINTERNALERROR>             try:\nINTERNALERROR>                 config._do_configure()\nINTERNALERROR>                 initstate = 1\nINTERNALERROR> >               config.hook.pytest_sessionstart(session=session)\nINTERNALERROR> \nINTERNALERROR> /testbed/src/_pytest/main.py:268: \nINTERNALERROR> _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \nINTERNALERROR> \nINTERNALERROR> self = <HookCaller 'pytest_sessionstart'>\nINTERNALERROR> kwargs = {'session': <Session test_early_hook_error_issue38_10 exitstatus=<ExitCode.INTERNAL_ERROR: 3> testsfailed=0 testscollected=0>}\nINTERNALERROR> firstresult = False\nINTERNALERROR> \nINTERNALERROR>     def __call__(self, **kwargs: object) -> Any:\nINTERNALERROR>         \"\"\"Call the hook.\nINTERNALERROR>     \nINTERNALERROR>         Only accepts keyword arguments, which should match the hook\nINTERNALERROR>         specification.\nINTERNALERROR>     \nINTERNALERROR>         Returns the result(s) of calling all registered plugins, see\nINTERNALERROR>         :ref:`calling`.\nINTERNALERROR>         \"\"\"\nINTERNALERROR>         assert (\nINTERNALERROR>             not self.is_historic()\nINTERNALERROR>         ), \"Cannot directly call a historic hook - use call_historic instead.\"\nINTERNALERROR>         self._verify_all_args_are_provided(kwargs)\nINTERNALERROR>         firstresult = self.spec.opts.get(\"firstresult\", False) if self.spec else False\nINTERNALERROR> >       return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)\nINTERNALERROR> \nINTERNALERROR> /opt/miniconda3/envs/testbed/lib/python3.9/site-packages/pluggy/_hooks.py:493: \nINTERNALERROR> _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \nINTERNALERROR> \nINTERNALERROR> self = <_pytest.config.PytestPluginManager object at 0x7f5130d3d910>\nINTERNALERROR> hook_name = 'pytest_sessionstart'\nINTERNALERROR> methods = [<HookImpl plugin_name='terminalreporter', plugin=<_pytest.terminal.TerminalReporter object at 0x7f5130d287f0>>, <Hook...nftest.py'>>, <HookImpl plugin_name='logging-plugin', plugin=<_pytest.logging.LoggingPlugin object at 0x7f5130d28310>>]\nINTERNALERROR> kwargs = {'session': <Session test_early_hook_error_issue38_10 exitstatus=<ExitCode.INTERNAL_ERROR: 3> testsfailed=0 testscollected=0>}\nINTERNALERROR> firstresult = False\nINTERNALERROR> \nINTERNALERROR>     def _hookexec(\nINTERNALERROR>         self,\nINTERNALERROR>         hook_name: str,\nINTERNALERROR>         methods: Sequence[HookImpl],\nINTERNALERROR>         kwargs: Mapping[str, object],\nINTERNALERROR>         firstresult: bool,\nINTERNALERROR>     ) -> object | list[object]:\nINTERNALERROR>         # called from all hookcaller instances.\nINTERNALERROR>         # enable_tracing will set its own wrapping function at self._inner_hookexec\nINTERNALERROR> >       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)\nINTERNALERROR> \nINTERNALERROR> /opt/miniconda3/envs/testbed/lib/python3.9/site-packages/pluggy/_manager.py:115: \nINTERNALERROR> _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \nINTERNALERROR> \nINTERNALERROR> hook_name = 'pytest_sessionstart'\nINTERNALERROR> hook_impls = [<HookImpl plugin_name='terminalreporter', plugin=<_pytest.terminal.TerminalReporter object at 0x7f5130d287f0>>, <Hook...nftest.py'>>, <HookImpl plugin_name='logging-plugin', plugin=<_pytest.logging.LoggingPlugin object at 0x7f5130d28310>>]\nINTERNALERROR> caller_kwargs = {'session': <Session test_early_hook_error_issue38_10 exitstatus=<ExitCode.INTERNAL_ERROR: 3> testsfailed=0 testscollected=0>}\nINTERNALERROR> firstresult = False\nINTERNALERROR> \nINTERNALERROR>     def traced_hookexec(\nINTERNALERROR>         hook_name: str,\nINTERNALERROR>         hook_impls: Sequence[HookImpl],\nINTERNALERROR>         caller_kwargs: Mapping[str, object],\nINTERNALERROR>         firstresult: bool,\nINTERNALERROR>     ) -> object | list[object]:\nINTERNALERROR>         before(hook_name, hook_impls, caller_kwargs)\nINTERNALERROR>         outcome = Result.from_call(\nINTERNALERROR>             lambda: oldcall(hook_name, hook_impls, caller_kwargs, firstresult)\nINTERNALERROR>         )\nINTERNALERROR>         after(outcome, hook_name, hook_impls, caller_kwargs)\nINTERNALERROR> >       return outcome.get_result()\nINTERNALERROR> \nINTERNALERROR> /opt/miniconda3/envs/testbed/lib/python3.9/site-packages/pluggy/_manager.py:457: \nINTERNALERROR> _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \nINTERNALERROR> \nINTERNALERROR> >       lambda: oldcall(hook_name, hook_impls, caller_kwargs, firstresult)\nINTERNALERROR>     )\nINTERNALERROR> \nINTERNALERROR> /opt/miniconda3/envs/testbed/lib/python3.9/site-packages/pluggy/_manager.py:454: \nINTERNALERROR> _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \nINTERNALERROR> \nINTERNALERROR>     def pytest_sessionstart():\nINTERNALERROR> >       0 / 0\nINTERNALERROR> E       ZeroDivisionError: division by zero\nINTERNALERROR> \nINTERNALERROR> conftest.py:2: ZeroDivisionError\n___________ TestGeneralUsage.test_early_hook_configure_error_issue38 ___________\n----------------------------- Captured stderr call -----------------------------\nINTERNALERROR> Traceback (most recent call last):\nINTERNALERROR>   File \"/testbed/src/_pytest/main.py\", line 266, in wrap_session\nINTERNALERROR>     config._do_configure()\nINTERNALERROR>   File \"/testbed/src/_pytest/config/__init__.py\", line 1055, in _do_configure\nINTERNALERROR>     self.hook.pytest_configure.call_historic(kwargs=dict(config=self))\nINTERNALERROR>   File \"/opt/miniconda3/envs/testbed/lib/python3.9/site-packages/pluggy/_hooks.py\", line 514, in call_historic\nINTERNALERROR>     res = self._hookexec(self.name, self._hookimpls, kwargs, False)\nINTERNALERROR>   File \"/opt/miniconda3/envs/testbed/lib/python3.9/site-packages/pluggy/_manager.py\", line 115, in _hookexec\nINTERNALERROR>     return self._inner_hookexec(hook_name, methods, kwargs, firstresult)\nINTERNALERROR>   File \"/opt/miniconda3/envs/testbed/lib/python3.9/site-packages/pluggy/_callers.py\", line 113, in _multicall\nINTERNALERROR>     raise exception.with_traceback(exception.__traceback__)\nINTERNALERROR>   File \"/opt/miniconda3/envs/testbed/lib/python3.9/site-packages/pluggy/_callers.py\", line 77, in _multicall\nINTERNALERROR>     res = hook_impl.function(*args)\nINTERNALERROR>   File \"/tmp/pytest-of-root/pytest-0/test_early_hook_configure_error_issue380/conftest.py\", line 2, in pytest_configure\nINTERNALERROR>     0 / 0\nINTERNALERROR> ZeroDivisionError: division by zero\n_____________________ TestGeneralUsage.test_file_not_found _____________________\n----------------------------- Captured stdout call -----------------------------\n============================= test session starts ==============================\nplatform linux -- Python 3.9.20, pytest-8.0.0.dev46+g2f7415cfb.d20220101, pluggy-1.3.0\nrootdir: /tmp/pytest-of-root/pytest-0/test_file_not_found0\ncollected 0 items\n\n============================ no tests ran in 0.00s =============================\n----------------------------- Captured stderr call -----------------------------\nERROR: file or directory not found: asd\n\n__________ TestGeneralUsage.test_file_not_found_unconfigure_issue143 ___________\n----------------------------- Captured stdout call -----------------------------\n---configure\n============================= test session starts ==============================\nplatform linux -- Python 3.9.20, pytest-8.0.0.dev46+g2f7415cfb.d20220101, pluggy-1.3.0\nrootdir: /tmp/pytest-of-root/pytest-0/test_file_not_found_unconfigure_issue1430\ncollected 0 items\n\n============================ no tests ran in 0.00s =============================\n---unconfigure\n----------------------------- Captured stderr call -----------------------------\nERROR: file or directory not found: asd\n\n_____________ TestGeneralUsage.test_config_preparse_plugin_option ______________\n----------------------------- Captured stdout call -----------------------------\n============================= test session starts ==============================\nplatform linux -- Python 3.9.20, pytest-8.0.0.dev46+g2f7415cfb.d20220101, pluggy-1.3.0\nrootdir: /tmp/pytest-of-root/pytest-0/test_config_preparse_plugin_option0\ncollected 1 item\n\ntest_one.py .                                                            [100%]\n\n============================== 1 passed in 0.01s ===============================\n____________ TestGeneralUsage.test_early_load_setuptools_name[True] ____________\n----------------------------- Captured stdout call -----------------------------\n============================= test session starts ==============================\nplatform linux -- Python 3.9.20, pytest-8.0.0.dev46+g2f7415cfb.d20220101, pluggy-1.3.0\nINTERNALERROR> Traceback (most recent call last):\nINTERNALERROR>   File \"/testbed/src/_pytest/main.py\", line 268, in wrap_session\nINTERNALERROR>     config.hook.pytest_sessionstart(session=session)\nINTERNALERROR>   File \"/opt/miniconda3/envs/testbed/lib/python3.9/site-packages/pluggy/_hooks.py\", line 493, in __call__\nINTERNALERROR>     return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)\nINTERNALERROR>   File \"/opt/miniconda3/envs/testbed/lib/python3.9/site-packages/pluggy/_manager.py\", line 115, in _hookexec\nINTERNALERROR>     return self._inner_hookexec(hook_name, methods, kwargs, firstresult)\nINTERNALERROR>   File \"/opt/miniconda3/envs/testbed/lib/python3.9/site-packages/pluggy/_manager.py\", line 457, in traced_hookexec\nINTERNALERROR>     return outcome.get_result()\nINTERNALERROR>   File \"/opt/miniconda3/envs/testbed/lib/python3.9/site-packages/pluggy/_result.py\", line 114, in get_result\nINTERNALERROR>     raise exc.with_traceback(exc.__traceback__)\nINTERNALERROR>   File \"/opt/miniconda3/envs/testbed/lib/python3.9/site-packages/pluggy/_result.py\", line 76, in from_call\nINTERNALERROR>     result = func()\nINTERNALERROR>   File \"/opt/miniconda3/envs/testbed/lib/python3.9/site-packages/pluggy/_manager.py\", line 454, in <lambda>\nINTERNALERROR>     lambda: oldcall(hook_name, hook_impls, caller_kwargs, firstresult)\nINTERNALERROR>   File \"/opt/miniconda3/envs/testbed/lib/python3.9/site-packages/pluggy/_callers.py\", line 152, in _multicall\nINTERNALERROR>     return outcome.get_result()\nINTERNALERROR>   File \"/opt/miniconda3/envs/testbed/lib/python3.9/site-packages/pluggy/_result.py\", line 114, in get_result\nINTERNALERROR>     raise exc.with_traceback(exc.__traceback__)\nINTERNALERROR>   File \"/opt/miniconda3/envs/testbed/lib/python3.9/site-packages/pluggy/_callers.py\", line 77, in _multicall\nINTERNALERROR>     res = hook_impl.function(*args)\nINTERNALERROR>   File \"/testbed/src/_pytest/terminal.py\", line 771, in pytest_sessionstart\nINTERNALERROR>     lines = self.config.hook.pytest_report_header(\nINTERNALERROR>   File \"/testbed/src/_pytest/config/compat.py\", line 66, in fixed_hook\nINTERNALERROR>     return hook(**kw)\nINTERNALERROR>   File \"/opt/miniconda3/envs/testbed/lib/python3.9/site-packages/pluggy/_hooks.py\", line 493, in __call__\nINTERNALERROR>     return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)\nINTERNALERROR>   File \"/opt/miniconda3/envs/testbed/lib/python3.9/site-packages/pluggy/_manager.py\", line 115, in _hookexec\nINTERNALERROR>     return self._inner_hookexec(hook_name, methods, kwargs, firstresult)\nINTERNALERROR>   File \"/opt/miniconda3/envs/testbed/lib/python3.9/site-packages/pluggy/_manager.py\", line 457, in traced_hookexec\nINTERNALERROR>     return outcome.get_result()\nINTERNALERROR>   File \"/opt/miniconda3/envs/testbed/lib/python3.9/site-packages/pluggy/_result.py\", line 114, in get_result\nINTERNALERROR>     raise exc.with_traceback(exc.__traceback__)\nINTERNALERROR>   File \"/opt/miniconda3/envs/testbed/lib/python3.9/site-packages/pluggy/_result.py\", line 76, in from_call\nINTERNALERROR>     result = func()\nINTERNALERROR>   File \"/opt/miniconda3/envs/testbed/lib/python3.9/site-packages/pluggy/_manager.py\", line 454, in <lambda>\nINTERNALERROR>     lambda: oldcall(hook_name, hook_impls, caller_kwargs, firstresult)\nINTERNALERROR>   File \"/opt/miniconda3/envs/testbed/lib/python3.9/site-packages/pluggy/_callers.py\", line 113, in _multicall\nINTERNALERROR>     raise exception.with_traceback(exception.__traceback__)\nINTERNALERROR>   File \"/opt/miniconda3/envs/testbed/lib/python3.9/site-packages/pluggy/_callers.py\", line 77, in _multicall\nINTERNALERROR>     res = hook_impl.function(*args)\nINTERNALERROR>   File \"/testbed/src/_pytest/terminal.py\", line 798, in pytest_report_header\nINTERNALERROR>     result.append(\"plugins: %s\" % \", \".join(_plugin_nameversions(plugininfo)))\nINTERNALERROR>   File \"/testbed/src/_pytest/terminal.py\", line 1444, in _plugin_nameversions\nINTERNALERROR>     name = \"{dist.project_name}-{dist.version}\".format(dist=dist)\nINTERNALERROR>   File \"/opt/miniconda3/envs/testbed/lib/python3.9/site-packages/pluggy/_manager.py\", line 65, in project_name\nINTERNALERROR>     name: str = self.metadata[\"name\"]\nINTERNALERROR> TypeError: 'NoneType' object is not subscriptable\n___________ TestGeneralUsage.test_early_load_setuptools_name[False] ____________\n----------------------------- Captured stdout call -----------------------------\n============================= test session starts ==============================\nplatform linux -- Python 3.9.20, pytest-8.0.0.dev46+g2f7415cfb.d20220101, pluggy-1.3.0\nINTERNALERROR> Traceback (most recent call last):\nINTERNALERROR>   File \"/testbed/src/_pytest/main.py\", line 268, in wrap_session\nINTERNALERROR>     config.hook.pytest_sessionstart(session=session)\nINTERNALERROR>   File \"/opt/miniconda3/envs/testbed/lib/python3.9/site-packages/pluggy/_hooks.py\", line 493, in __call__\nINTERNALERROR>     return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)\nINTERNALERROR>   File \"/opt/miniconda3/envs/testbed/lib/python3.9/site-packages/pluggy/_manager.py\", line 115, in _hookexec\nINTERNALERROR>     return self._inner_hookexec(hook_name, methods, kwargs, firstresult)\nINTERNALERROR>   File \"/opt/miniconda3/envs/testbed/lib/python3.9/site-packages/pluggy/_manager.py\", line 457, in traced_hookexec\nINTERNALERROR>     return outcome.get_result()\nINTERNALERROR>   File \"/opt/miniconda3/envs/testbed/lib/python3.9/site-packages/pluggy/_result.py\", line 114, in get_result\nINTERNALERROR>     raise exc.with_traceback(exc.__traceback__)\nINTERNALERROR>   File \"/opt/miniconda3/envs/testbed/lib/python3.9/site-packages/pluggy/_result.py\", line 76, in from_call\nINTERNALERROR>     result = func()\nINTERNALERROR>   File \"/opt/miniconda3/envs/testbed/lib/python3.9/site-packages/pluggy/_manager.py\", line 454, in <lambda>\nINTERNALERROR>     lambda: oldcall(hook_name, hook_impls, caller_kwargs, firstresult)\nINTERNALERROR>   File \"/opt/miniconda3/envs/testbed/lib/python3.9/site-packages/pluggy/_callers.py\", line 152, in _multicall\nINTERNALERROR>     return outcome.get_result()\nINTERNALERROR>   File \"/opt/miniconda3/envs/testbed/lib/python3.9/site-packages/pluggy/_result.py\", line 114, in get_result\nINTERNALERROR>     raise exc.with_traceback(exc.__traceback__)\nINTERNALERROR>   File \"/opt/miniconda3/envs/testbed/lib/python3.9/site-packages/pluggy/_callers.py\", line 77, in _multicall\nINTERNALERROR>     res = hook_impl.function(*args)\nINTERNALERROR>   File \"/testbed/src/_pytest/terminal.py\", line 771, in pytest_sessionstart\nINTERNALERROR>     lines = self.config.hook.pytest_report_header(\nINTERNALERROR>   File \"/testbed/src/_pytest/config/compat.py\", line 66, in fixed_hook\nINTERNALERROR>     return hook(**kw)\nINTERNALERROR>   File \"/opt/miniconda3/envs/testbed/lib/python3.9/site-packages/pluggy/_hooks.py\", line 493, in __call__\nINTERNALERROR>     return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)\nINTERNALERROR>   File \"/opt/miniconda3/envs/testbed/lib/python3.9/site-packages/pluggy/_manager.py\", line 115, in _hookexec\nINTERNALERROR>     return self._inner_hookexec(hook_name, methods, kwargs, firstresult)\nINTERNALERROR>   File \"/opt/miniconda3/envs/testbed/lib/python3.9/site-packages/pluggy/_manager.py\", line 457, in traced_hookexec\nINTERNALERROR>     return outcome.get_result()\nINTERNALERROR>   File \"/opt/miniconda3/envs/testbed/lib/python3.9/site-packages/pluggy/_result.py\", line 114, in get_result\nINTERNALERROR>     raise exc.with_traceback(exc.__traceback__)\nINTERNALERROR>   File \"/opt/miniconda3/envs/testbed/lib/python3.9/site-packages/pluggy/_result.py\", line 76, in from_call\nINTERNALERROR>     result = func()\nINTERNALERROR>   File \"/opt/miniconda3/envs/testbed/lib/python3.9/site-packages/pluggy/_manager.py\", line 454, in <lambda>\nINTERNALERROR>     lambda: oldcall(hook_name, hook_impls, caller_kwargs, firstresult)\nINTERNALERROR>   File \"/opt/miniconda3/envs/testbed/lib/python3.9/site-packages/pluggy/_callers.py\", line 113, in _multicall\nINTERNALERROR>     raise exception.with_traceback(exception.__traceback__)\nINTERNALERROR>   File \"/opt/miniconda3/envs/testbed/lib/python3.9/site-packages/pluggy/_callers.py\", line 77, in _multicall\nINTERNALERROR>     res = hook_impl.function(*args)\nINTERNALERROR>   File \"/testbed/src/_pytest/terminal.py\", line 798, in pytest_report_header\nINTERNALERROR>     result.append(\"plugins: %s\" % \", \".join(_plugin_nameversions(plugininfo)))\nINTERNALERROR>   File \"/testbed/src/_pytest/terminal.py\", line 1444, in _plugin_nameversions\nINTERNALERROR>     name = \"{dist.project_name}-{dist.version}\".format(dist=dist)\nINTERNALERROR>   File \"/opt/miniconda3/envs/testbed/lib/python3.9/site-packages/pluggy/_manager.py\", line 65, in project_name\nINTERNALERROR>     name: str = self.metadata[\"name\"]\nINTERNALERROR> TypeError: 'NoneType' object is not subscriptable\n_______________ TestGeneralUsage.test_assertion_rewrite[prepend] _______________\n----------------------------- Captured stdout call -----------------------------\n============================= test session starts ==============================\nplatform linux -- Python 3.9.20, pytest-8.0.0.dev46+g2f7415cfb.d20220101, pluggy-1.3.0\nrootdir: /tmp/pytest-of-root/pytest-0/test_assertion_rewrite0\ncollected 1 item\n\ntest_assertion_rewrite.py F                                              [100%]\n\n=================================== FAILURES ===================================\n__________________________________ test_this ___________________________________\n\n    def test_this():\n        x = 0\n>       assert x\nE       assert 0\n\ntest_assertion_rewrite.py:3: AssertionError\n=========================== short test summary info ============================\nFAILED test_assertion_rewrite.py::test_this - assert 0\n============================== 1 failed in 0.01s ===============================\n_______________ TestGeneralUsage.test_assertion_rewrite[append] ________________\n----------------------------- Captured stdout call -----------------------------\n============================= test session starts ==============================\nplatform linux -- Python 3.9.20, pytest-8.0.0.dev46+g2f7415cfb.d20220101, pluggy-1.3.0\nrootdir: /tmp/pytest-of-root/pytest-0/test_assertion_rewrite1\ncollected 1 item\n\ntest_assertion_rewrite.py F                                              [100%]\n\n=================================== FAILURES ===================================\n__________________________________ test_this ___________________________________\n\n    def test_this():\n        x = 0\n>       assert x\nE       assert 0\n\ntest_assertion_rewrite.py:3: AssertionError\n=========================== short test summary info ============================\nFAILED test_assertion_rewrite.py::test_this - assert 0\n============================== 1 failed in 0.01s ===============================\n______________ TestGeneralUsage.test_assertion_rewrite[importlib] ______________\n----------------------------- Captured stdout call -----------------------------\n============================= test session starts ==============================\nplatform linux -- Python 3.9.20, pytest-8.0.0.dev46+g2f7415cfb.d20220101, pluggy-1.3.0\nrootdir: /tmp/pytest-of-root/pytest-0/test_assertion_rewrite2\ncollected 1 item\n\ntest_assertion_rewrite.py F                                              [100%]\n\n=================================== FAILURES ===================================\n__________________________________ test_this ___________________________________\n\n    def test_this():\n        x = 0\n>       assert x\nE       assert 0\n\ntest_assertion_rewrite.py:3: AssertionError\n=========================== short test summary info ============================\nFAILED test_assertion_rewrite.py::test_this - assert 0\n============================== 1 failed in 0.01s ===============================\n__________________ TestGeneralUsage.test_nested_import_error ___________________\n----------------------------- Captured stdout call -----------------------------\n============================= test session starts ==============================\nplatform linux -- Python 3.9.20, pytest-8.0.0.dev46+g2f7415cfb.d20220101, pluggy-1.3.0\nrootdir: /tmp/pytest-of-root/pytest-0/test_nested_import_error0\ncollected 0 items / 1 error\n\n==================================== ERRORS ====================================\n_________________ ERROR collecting test_nested_import_error.py _________________\nImportError while importing test module '/tmp/pytest-of-root/pytest-0/test_nested_import_error0/test_nested_import_error.py'.\nHint: make sure your test modules/packages have valid Python names.\nTraceback:\n/opt/miniconda3/envs/testbed/lib/python3.9/importlib/__init__.py:127: in import_module\n    return _bootstrap._gcd_import(name[level:], package, level)\ntest_nested_import_error.py:1: in <module>\n    import import_fails\nimport_fails.py:1: in <module>\n    import does_not_work\nE   ModuleNotFoundError: No module named 'does_not_work'\n=========================== short test summary info ============================\nERROR test_nested_import_error.py\n!!!!!!!!!!!!!!!!!!!! Interrupted: 1 error during collection !!!!!!!!!!!!!!!!!!!!\n=============================== 1 error in 0.04s ===============================\n_______________ TestGeneralUsage.test_not_collectable_arguments ________________\n----------------------------- Captured stdout call -----------------------------\n============================= test session starts ==============================\nplatform linux -- Python 3.9.20, pytest-8.0.0.dev46+g2f7415cfb.d20220101, pluggy-1.3.0\nrootdir: /tmp/pytest-of-root/pytest-0/test_not_collectable_arguments0\ncollected 0 items\n\n============================ no tests ran in 0.00s =============================\n----------------------------- Captured stderr call -----------------------------\nERROR: found no collectors for /tmp/pytest-of-root/pytest-0/test_not_collectable_arguments0/test_not_collectable_arguments.pyc\n\n_______ TestGeneralUsage.test_better_reporting_on_conftest_load_failure ________\n----------------------------- Captured stdout call -----------------------------\nusage: pytest [options] [file_or_dir] [file_or_dir] [...]\n\npositional arguments:\n  file_or_dir\n\ngeneral:\n  -k EXPRESSION         Only run tests which match the given substring\n                        expression. An expression is a Python evaluatable\n                        expression where all names are substring-matched against\n                        test names and their parent classes. Example: -k\n                        'test_method or test_other' matches all test functions\n                        and classes whose name contains 'test_method' or\n                        'test_other', while -k 'not test_method' matches those\n                        that don't contain 'test_method' in their names. -k 'not\n                        test_method and not test_other' will eliminate the\n                        matches. Additionally keywords are matched to classes\n                        and functions containing extra names in their\n                        'extra_keyword_matches' set, as well as functions which\n                        have names assigned directly to them. The matching is\n                        case-insensitive.\n  -m MARKEXPR           Only run tests matching given mark expression. For\n                        example: -m 'mark1 and not mark2'.\n  --markers             show markers (builtin, plugin and per-project ones).\n  -x, --exitfirst       Exit instantly on first error or failed test\n  --fixtures, --funcargs\n                        Show available fixtures, sorted by plugin appearance\n                        (fixtures with leading '_' are only shown with '-v')\n  --fixtures-per-test   Show fixtures per test\n  --pdb                 Start the interactive Python debugger on errors or\n                        KeyboardInterrupt\n  --pdbcls=modulename:classname\n                        Specify a custom interactive Python debugger for use\n                        with --pdb.For example:\n                        --pdbcls=IPython.terminal.debugger:TerminalPdb\n  --trace               Immediately break when running each test\n  --capture=method      Per-test capturing method: one of fd|sys|no|tee-sys\n  -s                    Shortcut for --capture=no\n  --runxfail            Report the results of xfail tests as if they were not\n                        marked\n  --lf, --last-failed   Rerun only the tests that failed at the last run (or all\n                        if none failed)\n  --ff, --failed-first  Run all tests, but run the last failures first. This may\n                        re-order tests and thus lead to repeated fixture\n                        setup/teardown.\n  --nf, --new-first     Run tests from new files first, then the rest of the\n                        tests sorted by file mtime\n  --cache-show=[CACHESHOW]\n                        Show cache contents, don't perform collection or tests.\n                        Optional argument: glob (default: '*').\n  --cache-clear         Remove all cache contents at start of test run\n  --lfnf={all,none}, --last-failed-no-failures={all,none}\n                        Which tests to run with no previously (known) failures\n  --sw, --stepwise      Exit on test failure and continue from last failing test\n                        next time\n  --sw-skip, --stepwise-skip\n                        Ignore the first failing test but stop on the next\n                        failing test. Implicitly enables --stepwise.\n\nReporting:\n  --durations=N         Show N slowest setup/test durations (N=0 for all)\n  --durations-min=N     Minimal duration in seconds for inclusion in slowest\n                        list. Default: 0.005.\n  -v, --verbose         Increase verbosity\n  --no-header           Disable header\n  --no-summary          Disable summary\n  -q, --quiet           Decrease verbosity\n  --verbosity=VERBOSE   Set verbosity. Default: 0.\n  -r chars              Show extra test summary info as specified by chars:\n                        (f)ailed, (E)rror, (s)kipped, (x)failed, (X)passed,\n                        (p)assed, (P)assed with output, (a)ll except passed\n                        (p/P), or (A)ll. (w)arnings are enabled by default (see\n                        --disable-warnings), 'N' can be used to reset the list.\n                        (default: 'fE').\n  --disable-warnings, --disable-pytest-warnings\n                        Disable warnings summary\n  -l, --showlocals      Show locals in tracebacks (disabled by default)\n  --no-showlocals       Hide locals in tracebacks (negate --showlocals passed\n                        through addopts)\n  --tb=style            Traceback print mode (auto/long/short/line/native/no)\n  --show-capture={no,stdout,stderr,log,all}\n                        Controls how captured stdout/stderr/log is shown on\n                        failed tests. Default: all.\n  --full-trace          Don't cut any tracebacks (default is to cut)\n  --color=color         Color terminal output (yes/no/auto)\n  --code-highlight={yes,no}\n                        Whether code should be highlighted (only if --color is\n                        also enabled). Default: yes.\n  --pastebin=mode       Send failed|all info to bpaste.net pastebin service\n  --junit-xml=path      Create junit-xml style report file at given path\n  --junit-prefix=str    Prepend prefix to classnames in junit-xml output\n\npytest-warnings:\n  -W PYTHONWARNINGS, --pythonwarnings=PYTHONWARNINGS\n                        Set which warnings to report, see -W option of Python\n                        itself\n  --maxfail=num         Exit after first num failures or errors\n  --strict-config       Any warnings encountered while parsing the `pytest`\n                        section of the configuration file raise errors\n  --strict-markers      Markers not registered in the `markers` section of the\n                        configuration file raise errors\n  --strict              (Deprecated) alias to --strict-markers\n  -c FILE, --config-file=FILE\n                        Load configuration from `FILE` instead of trying to\n                        locate one of the implicit configuration files.\n  --continue-on-collection-errors\n                        Force test execution even if collection errors occur\n  --rootdir=ROOTDIR     Define root directory for tests. Can be relative path:\n                        'root_dir', './root_dir', 'root_dir/another_dir/';\n                        absolute path: '/home/user/root_dir'; path with\n                        variables: '$HOME/root_dir'.\n\ncollection:\n  --collect-only, --co  Only collect tests, don't execute them\n  --pyargs              Try to interpret all arguments as Python packages\n  --ignore=path         Ignore path during collection (multi-allowed)\n  --ignore-glob=path    Ignore path pattern during collection (multi-allowed)\n  --deselect=nodeid_prefix\n                        Deselect item (via node id prefix) during collection\n                        (multi-allowed)\n  --confcutdir=dir      Only load conftest.py's relative to specified dir\n  --noconftest          Don't load any conftest.py files\n  --keep-duplicates     Keep duplicate tests\n  --collect-in-virtualenv\n                        Don't ignore tests in a local virtualenv directory\n  --import-mode={prepend,append,importlib}\n                        Prepend/append to sys.path when importing test modules\n                        and conftest files. Default: prepend.\n  --doctest-modules     Run doctests in all .py modules\n  --doctest-report={none,cdiff,ndiff,udiff,only_first_failure}\n                        Choose another output format for diffs on doctest\n                        failure\n  --doctest-glob=pat    Doctests file matching pattern, default: test*.txt\n  --doctest-ignore-import-errors\n                        Ignore doctest ImportErrors\n  --doctest-continue-on-failure\n                        For a given doctest, continue to run after the first\n                        failure\n\ntest session debugging and configuration:\n  --basetemp=dir        Base temporary directory for this test run. (Warning:\n                        this directory is removed if it exists.)\n  -V, --version         Display pytest version and information about plugins.\n                        When given twice, also display information about\n                        plugins.\n  -h, --help            Show help message and configuration info\n  -p name               Early-load given plugin module name or entry point\n                        (multi-allowed). To avoid loading of plugins, use the\n                        `no:` prefix, e.g. `no:doctest`.\n  --trace-config        Trace considerations of conftest.py files\n  --debug=[DEBUG_FILE_NAME]\n                        Store internal tracing debug information in this log\n                        file. This file is opened with 'w' and truncated as a\n                        result, care advised. Default: pytestdebug.log.\n  -o OVERRIDE_INI, --override-ini=OVERRIDE_INI\n                        Override ini option with \"option=value\" style, e.g. `-o\n                        xfail_strict=True -o cache_dir=cache`.\n  --assert=MODE         Control assertion debugging tools.\n                        'plain' performs no assertion debugging.\n                        'rewrite' (the default) rewrites assert statements in\n                        test modules on import to provide assert expression\n                        information.\n  --setup-only          Only setup fixtures, do not execute tests\n  --setup-show          Show setup of fixtures while executing tests\n  --setup-plan          Show what fixtures and tests would be executed but don't\n                        execute anything\n\nlogging:\n  --log-level=LEVEL     Level of messages to catch/display. Not set by default,\n                        so it depends on the root/parent log handler's effective\n                        level, where it is \"WARNING\" by default.\n  --log-format=LOG_FORMAT\n                        Log format used by the logging module\n  --log-date-format=LOG_DATE_FORMAT\n                        Log date format used by the logging module\n  --log-cli-level=LOG_CLI_LEVEL\n                        CLI logging level\n  --log-cli-format=LOG_CLI_FORMAT\n                        Log format used by the logging module\n  --log-cli-date-format=LOG_CLI_DATE_FORMAT\n                        Log date format used by the logging module\n  --log-file=LOG_FILE   Path to a file when logging will be written to\n  --log-file-level=LOG_FILE_LEVEL\n                        Log file logging level\n  --log-file-format=LOG_FILE_FORMAT\n                        Log format used by the logging module\n  --log-file-date-format=LOG_FILE_DATE_FORMAT\n                        Log date format used by the logging module\n  --log-auto-indent=LOG_AUTO_INDENT\n                        Auto-indent multiline messages passed to the logging\n                        module. Accepts true|on, false|off or an integer.\n  --log-disable=LOGGER_DISABLE\n                        Disable a logger by name. Can be passed multiple times.\n\n[pytest] ini-options in the first pytest.ini|tox.ini|setup.cfg|pyproject.toml file found:\n\n  markers (linelist):   Markers for test functions\n  empty_parameter_set_mark (string):\n                        Default marker for empty parametersets\n  norecursedirs (args): Directory patterns to avoid for recursion\n  testpaths (args):     Directories to search for tests when no files or\n                        directories are given on the command line\n  filterwarnings (linelist):\n                        Each line specifies a pattern for\n                        warnings.filterwarnings. Processed after\n                        -W/--pythonwarnings.\n  usefixtures (args):   List of default fixtures to be used with this project\n  python_files (args):  Glob-style file patterns for Python test module\n                        discovery\n  python_classes (args):\n                        Prefixes or glob names for Python test class discovery\n  python_functions (args):\n                        Prefixes or glob names for Python test function and\n                        method discovery\n  disable_test_id_escaping_and_forfeit_all_rights_to_community_support (bool):\n                        Disable string escape non-ASCII characters, might cause\n                        unwanted side effects(use at your own risk)\n  console_output_style (string):\n                        Console output: \"classic\", or with additional progress\n                        information (\"progress\" (percentage) | \"count\" |\n                        \"progress-even-when-capture-no\" (forces progress even\n                        when capture=no)\n  xfail_strict (bool):  Default for the strict parameter of xfail markers when\n                        not given explicitly (default: False)\n  tmp_path_retention_count (string):\n                        How many sessions should we keep the `tmp_path`\n                        directories, according to `tmp_path_retention_policy`.\n  tmp_path_retention_policy (string):\n                        Controls which directories created by the `tmp_path`\n                        fixture are kept around, based on test outcome.\n                        (all/failed/none)\n  enable_assertion_pass_hook (bool):\n                        Enables the pytest_assertion_pass hook. Make sure to\n                        delete any previously generated pyc cache files.\n  junit_suite_name (string):\n                        Test suite name for JUnit report\n  junit_logging (string):\n                        Write captured log messages to JUnit report: one of\n                        no|log|system-out|system-err|out-err|all\n  junit_log_passing_tests (bool):\n                        Capture log information for passing tests to JUnit\n                        report:\n  junit_duration_report (string):\n                        Duration time to report: one of total|call\n  junit_family (string):\n                        Emit XML for schema: one of legacy|xunit1|xunit2\n  doctest_optionflags (args):\n                        Option flags for doctests\n  doctest_encoding (string):\n                        Encoding used for doctest files\n  cache_dir (string):   Cache directory path\n  log_level (string):   Default value for --log-level\n  log_format (string):  Default value for --log-format\n  log_date_format (string):\n                        Default value for --log-date-format\n  log_cli (bool):       Enable log display during test run (also known as \"live\n                        logging\")\n  log_cli_level (string):\n                        Default value for --log-cli-level\n  log_cli_format (string):\n                        Default value for --log-cli-format\n  log_cli_date_format (string):\n                        Default value for --log-cli-date-format\n  log_file (string):    Default value for --log-file\n  log_file_level (string):\n                        Default value for --log-file-level\n  log_file_format (string):\n                        Default value for --log-file-format\n  log_file_date_format (string):\n                        Default value for --log-file-date-format\n  log_auto_indent (string):\n                        Default value for --log-auto-indent\n  pythonpath (paths):   Add paths to sys.path\n  faulthandler_timeout (string):\n                        Dump the traceback of all threads if a test takes more\n                        than TIMEOUT seconds to finish\n  addopts (args):       Extra command line options\n  minversion (string):  Minimally required pytest version\n  required_plugins (args):\n                        Plugins that must be present for pytest to run\n\nEnvironment variables:\n  PYTEST_ADDOPTS           Extra command line options\n  PYTEST_PLUGINS           Comma-separated plugins to load during startup\n  PYTEST_DISABLE_PLUGIN_AUTOLOAD Set to disable plugin auto-loading\n  PYTEST_DEBUG             Set to enable debug tracing of pytest's internals\n\n\nto see available markers type: pytest --markers\nto see available fixtures type: pytest --fixtures\n(shown according to specified file_or_dir or current dir if not specified; fixtures with leading '_' are only shown with the '-v' option\nwarning : /testbed/src/_pytest/config/__init__.py:1335: PytestConfigWarning: could not load initial conftests: /tmp/pytest-of-root/pytest-0/test_better_reporting_on_conftest_load_failure0/conftest.py\n  self.issue_config_time_warning(\n\n----------------------------- Captured stderr call -----------------------------\nImportError while loading conftest '/tmp/pytest-of-root/pytest-0/test_better_reporting_on_conftest_load_failure0/conftest.py'.\nconftest.py:3: in <module>\n    foo()\nconftest.py:2: in foo\n    import qwerty\nE   ModuleNotFoundError: No module named 'qwerty'\n_______________________ TestGeneralUsage.test_early_skip _______________________\n----------------------------- Captured stdout call -----------------------------\n============================= test session starts ==============================\nplatform linux -- Python 3.9.20, pytest-8.0.0.dev46+g2f7415cfb.d20220101, pluggy-1.3.0\nrootdir: /tmp/pytest-of-root/pytest-0/test_early_skip0\ncollected 0 items / 1 skipped\n\n============================== 1 skipped in 0.00s ==============================\n____________ TestGeneralUsage.test_issue88_initial_file_multinodes _____________\n----------------------------- Captured stdout call -----------------------------\n============================= test session starts ==============================\nplatform linux -- Python 3.9.20, pytest-8.0.0.dev46+g2f7415cfb.d20220101, pluggy-1.3.0\nrootdir: /tmp/pytest-of-root/pytest-0/test_issue88_initial_file_multinodes0\ncollected 2 items\n\n<MyFile test_issue88_initial_file_multinodes.py>\n  <MyItem hello>\n<Module test_issue88_initial_file_multinodes.py>\n  <Function test_hello>\n\n========================== 2 tests collected in 0.00s ==========================\n________ TestGeneralUsage.test_issue93_initialnode_importing_capturing _________\n----------------------------- Captured stdout call -----------------------------\nshould not be seen\n============================= test session starts ==============================\nplatform linux -- Python 3.9.20, pytest-8.0.0.dev46+g2f7415cfb.d20220101, pluggy-1.3.0\nrootdir: /tmp/pytest-of-root/pytest-0/test_issue93_initialnode_importing_capturing0\ncollected 0 items\n\n============================ no tests ran in 0.00s =============================\n----------------------------- Captured stderr call -----------------------------\nstder42\n____________ TestGeneralUsage.test_conftest_printing_shows_if_error ____________\n----------------------------- Captured stdout call -----------------------------\nshould be seen\n----------------------------- Captured stderr call -----------------------------\nImportError while loading conftest '/tmp/pytest-of-root/pytest-0/test_conftest_printing_shows_if_error0/conftest.py'.\nconftest.py:2: in <module>\n    assert 0\nE   assert 0\n_________ TestGeneralUsage.test_issue109_sibling_conftests_not_loaded __________\n----------------------------- Captured stdout call -----------------------------\n============================= test session starts ==============================\nplatform linux -- Python 3.9.20, pytest-8.0.0.dev46+g2f7415cfb.d20220101, pluggy-1.3.0\nrootdir: /tmp/pytest-of-root/pytest-0/test_issue109_sibling_conftests_not_loaded0\ncollected 0 items\n\n============================ no tests ran in 0.00s =============================\n============================= test session starts ==============================\nplatform linux -- Python 3.9.20, pytest-8.0.0.dev46+g2f7415cfb.d20220101, pluggy-1.3.0\nrootdir: /tmp/pytest-of-root/pytest-0/test_issue109_sibling_conftests_not_loaded0\ncollected 0 items\n\n============================ no tests ran in 0.00s =============================\n----------------------------- Captured stderr call -----------------------------\nImportError while loading conftest '/tmp/pytest-of-root/pytest-0/test_issue109_sibling_conftests_not_loaded0/sub1/conftest.py'.\nsub1/conftest.py:1: in <module>\n    assert 0\nE   assert 0\n___________________ TestGeneralUsage.test_directory_skipped ____________________\n----------------------------- Captured stdout call -----------------------------\n============================= test session starts ==============================\nplatform linux -- Python 3.9.20, pytest-8.0.0.dev46+g2f7415cfb.d20220101, pluggy-1.3.0\nrootdir: /tmp/pytest-of-root/pytest-0/test_directory_skipped0\ncollected 0 items / 1 skipped\n\n============================== 1 skipped in 0.00s ==============================\n___________ TestGeneralUsage.test_multiple_items_per_collector_byid ____________\n----------------------------- Captured stdout call -----------------------------\n============================= test session starts ==============================\nplatform linux -- Python 3.9.20, pytest-8.0.0.dev46+g2f7415cfb.d20220101, pluggy-1.3.0\nrootdir: /tmp/pytest-of-root/pytest-0/test_multiple_items_per_collector_byid0\ncollected 1 item\n\nconftest.py .                                                            [100%]\n\n============================== 1 passed in 0.00s ===============================\n______________ TestGeneralUsage.test_skip_on_generated_funcarg_id ______________\n----------------------------- Captured stdout call -----------------------------\n============================= test session starts ==============================\nplatform linux -- Python 3.9.20, pytest-8.0.0.dev46+g2f7415cfb.d20220101, pluggy-1.3.0\nrootdir: /tmp/pytest-of-root/pytest-0/test_skip_on_generated_funcarg_id0\ncollected 1 item\n\ntest_skip_on_generated_funcarg_id.py s                                   [100%]\n\n============================== 1 skipped in 0.00s ==============================\n_______________ TestGeneralUsage.test_direct_addressing_selects ________________\n----------------------------- Captured stdout call -----------------------------\n============================= test session starts ==============================\nplatform linux -- Python 3.9.20, pytest-8.0.0.dev46+g2f7415cfb.d20220101, pluggy-1.3.0\nrootdir: /tmp/pytest-of-root/pytest-0/test_direct_addressing_selects0\ncollected 1 item\n\ntest_direct_addressing_selects.py .                                      [100%]\n\n============================== 1 passed in 0.00s ===============================\n_______________ TestGeneralUsage.test_direct_addressing_notfound _______________\n----------------------------- Captured stdout call -----------------------------\n============================= test session starts ==============================\nplatform linux -- Python 3.9.20, pytest-8.0.0.dev46+g2f7415cfb.d20220101, pluggy-1.3.0\nrootdir: /tmp/pytest-of-root/pytest-0/test_direct_addressing_notfound0\ncollected 0 items\n\n============================ no tests ran in 0.00s =============================\n----------------------------- Captured stderr call -----------------------------\nERROR: not found: /tmp/pytest-of-root/pytest-0/test_direct_addressing_notfound0/test_direct_addressing_notfound.py::test_notfound\n(no name '/tmp/pytest-of-root/pytest-0/test_direct_addressing_notfound0/test_direct_addressing_notfound.py::test_notfound' in any of [<Module test_direct_addressing_notfound.py>])\n\n______________ TestGeneralUsage.test_initialization_error_issue49 ______________\n----------------------------- Captured stderr call -----------------------------\nINTERNALERROR> Traceback (most recent call last):\nINTERNALERROR>   File \"/testbed/src/_pytest/main.py\", line 266, in wrap_session\nINTERNALERROR>     config._do_configure()\nINTERNALERROR>   File \"/testbed/src/_pytest/config/__init__.py\", line 1055, in _do_configure\nINTERNALERROR>     self.hook.pytest_configure.call_historic(kwargs=dict(config=self))\nINTERNALERROR>   File \"/opt/miniconda3/envs/testbed/lib/python3.9/site-packages/pluggy/_hooks.py\", line 514, in call_historic\nINTERNALERROR>     res = self._hookexec(self.name, self._hookimpls, kwargs, False)\nINTERNALERROR>   File \"/opt/miniconda3/envs/testbed/lib/python3.9/site-packages/pluggy/_manager.py\", line 115, in _hookexec\nINTERNALERROR>     return self._inner_hookexec(hook_name, methods, kwargs, firstresult)\nINTERNALERROR>   File \"/opt/miniconda3/envs/testbed/lib/python3.9/site-packages/pluggy/_callers.py\", line 113, in _multicall\nINTERNALERROR>     raise exception.with_traceback(exception.__traceback__)\nINTERNALERROR>   File \"/opt/miniconda3/envs/testbed/lib/python3.9/site-packages/pluggy/_callers.py\", line 77, in _multicall\nINTERNALERROR>     res = hook_impl.function(*args)\nINTERNALERROR>   File \"/tmp/pytest-of-root/pytest-0/test_initialization_error_issue490/conftest.py\", line 2, in pytest_configure\nINTERNALERROR>     x\nINTERNALERROR> NameError: name 'x' is not defined\n_ TestGeneralUsage.test_issue134_report_error_when_collecting_member[test_fun.py::test_a] _\n----------------------------- Captured stdout call -----------------------------\n============================= test session starts ==============================\nplatform linux -- Python 3.9.20, pytest-8.0.0.dev46+g2f7415cfb.d20220101, pluggy-1.3.0\nrootdir: /tmp/pytest-of-root/pytest-0/test_issue134_report_error_when_collecting_member0\ncollected 0 items / 1 error\n\n==================================== ERRORS ====================================\n_________________________ ERROR collecting test_fun.py _________________________\n/testbed/src/_pytest/python.py:617: in _importtestmodule\n    mod = import_path(self.path, mode=importmode, root=self.config.rootpath)\n/testbed/src/_pytest/pathlib.py:567: in import_path\n    importlib.import_module(module_name)\n/opt/miniconda3/envs/testbed/lib/python3.9/importlib/__init__.py:127: in import_module\n    return _bootstrap._gcd_import(name[level:], package, level)\n<frozen importlib._bootstrap>:1030: in _gcd_import\n    ???\n<frozen importlib._bootstrap>:1007: in _find_and_load\n    ???\n<frozen importlib._bootstrap>:986: in _find_and_load_unlocked\n    ???\n<frozen importlib._bootstrap>:680: in _load_unlocked\n    ???\n/testbed/src/_pytest/assertion/rewrite.py:158: in exec_module\n    source_stat, co = _rewrite_test(fn, self.config)\n/testbed/src/_pytest/assertion/rewrite.py:340: in _rewrite_test\n    tree = ast.parse(source, filename=strfn)\n/opt/miniconda3/envs/testbed/lib/python3.9/ast.py:50: in parse\n    return compile(source, filename, mode, flags,\nE     File \"/tmp/pytest-of-root/pytest-0/test_issue134_report_error_when_collecting_member0/test_fun.py\", line 3\nE       def\nE          ^\nE   SyntaxError: invalid syntax\n=========================== short test summary info ============================\nERROR test_fun.py\n=============================== 1 error in 0.09s ===============================\n----------------------------- Captured stderr call -----------------------------\nERROR: not found: /tmp/pytest-of-root/pytest-0/test_issue134_report_error_when_collecting_member0/test_fun.py::test_a\n(no name '/tmp/pytest-of-root/pytest-0/test_issue134_report_error_when_collecting_member0/test_fun.py::test_a' in any of [<Module test_fun.py>])\n\n_________ TestGeneralUsage.test_report_all_failed_collections_initargs _________\n----------------------------- Captured stdout call -----------------------------\n============================= test session starts ==============================\nplatform linux -- Python 3.9.20, pytest-8.0.0.dev46+g2f7415cfb.d20220101, pluggy-1.3.0\nrootdir: /tmp/pytest-of-root/pytest-0/test_report_all_failed_collections_initargs0\ncollected 0 items / 2 errors\npytest_sessionfinish_called\n\n==================================== ERRORS ====================================\n__________________________ ERROR collecting test_a.py __________________________\n/testbed/src/_pytest/python.py:617: in _importtestmodule\n    mod = import_path(self.path, mode=importmode, root=self.config.rootpath)\n/testbed/src/_pytest/pathlib.py:567: in import_path\n    importlib.import_module(module_name)\n/opt/miniconda3/envs/testbed/lib/python3.9/importlib/__init__.py:127: in import_module\n    return _bootstrap._gcd_import(name[level:], package, level)\n<frozen importlib._bootstrap>:1030: in _gcd_import\n    ???\n<frozen importlib._bootstrap>:1007: in _find_and_load\n    ???\n<frozen importlib._bootstrap>:986: in _find_and_load_unlocked\n    ???\n<frozen importlib._bootstrap>:680: in _load_unlocked\n    ???\n/testbed/src/_pytest/assertion/rewrite.py:158: in exec_module\n    source_stat, co = _rewrite_test(fn, self.config)\n/testbed/src/_pytest/assertion/rewrite.py:340: in _rewrite_test\n    tree = ast.parse(source, filename=strfn)\n/opt/miniconda3/envs/testbed/lib/python3.9/ast.py:50: in parse\n    return compile(source, filename, mode, flags,\nE     File \"/tmp/pytest-of-root/pytest-0/test_report_all_failed_collections_initargs0/test_a.py\", line 1\nE       def\nE          ^\nE   SyntaxError: invalid syntax\n__________________________ ERROR collecting test_b.py __________________________\n/testbed/src/_pytest/python.py:617: in _importtestmodule\n    mod = import_path(self.path, mode=importmode, root=self.config.rootpath)\n/testbed/src/_pytest/pathlib.py:567: in import_path\n    importlib.import_module(module_name)\n/opt/miniconda3/envs/testbed/lib/python3.9/importlib/__init__.py:127: in import_module\n    return _bootstrap._gcd_import(name[level:], package, level)\n<frozen importlib._bootstrap>:1030: in _gcd_import\n    ???\n<frozen importlib._bootstrap>:1007: in _find_and_load\n    ???\n<frozen importlib._bootstrap>:986: in _find_and_load_unlocked\n    ???\n<frozen importlib._bootstrap>:680: in _load_unlocked\n    ???\n/testbed/src/_pytest/assertion/rewrite.py:158: in exec_module\n    source_stat, co = _rewrite_test(fn, self.config)\n/testbed/src/_pytest/assertion/rewrite.py:340: in _rewrite_test\n    tree = ast.parse(source, filename=strfn)\n/opt/miniconda3/envs/testbed/lib/python3.9/ast.py:50: in parse\n    return compile(source, filename, mode, flags,\nE     File \"/tmp/pytest-of-root/pytest-0/test_report_all_failed_collections_initargs0/test_b.py\", line 1\nE       def\nE          ^\nE   SyntaxError: invalid syntax\n=========================== short test summary info ============================\nERROR test_a.py\nERROR test_b.py\n============================== 2 errors in 0.15s ===============================\n----------------------------- Captured stderr call -----------------------------\nERROR: not found: /tmp/pytest-of-root/pytest-0/test_report_all_failed_collections_initargs0/test_a.py::a\n(no name '/tmp/pytest-of-root/pytest-0/test_report_all_failed_collections_initargs0/test_a.py::a' in any of [<Module test_a.py>])\n\nERROR: not found: /tmp/pytest-of-root/pytest-0/test_report_all_failed_collections_initargs0/test_b.py::b\n(no name '/tmp/pytest-of-root/pytest-0/test_report_all_failed_collections_initargs0/test_b.py::b' in any of [<Module test_b.py>])\n\n______ TestGeneralUsage.test_namespace_import_doesnt_confuse_import_hook _______\n----------------------------- Captured stdout call -----------------------------\n============================= test session starts ==============================\nplatform linux -- Python 3.9.20, pytest-8.0.0.dev46+g2f7415cfb.d20220101, pluggy-1.3.0\nrootdir: /tmp/pytest-of-root/pytest-0/test_namespace_import_doesnt_confuse_import_hook0\ncollected 1 item\n\ntest_namespace_import_doesnt_confuse_import_hook.py .                    [100%]\n\n============================== 1 passed in 0.00s ===============================\n_____________________ TestGeneralUsage.test_unknown_option _____________________\n----------------------------- Captured stderr call -----------------------------\nERROR: usage: pytest [options] [file_or_dir] [file_or_dir] [...]\npytest: error: unrecognized arguments: --qwlkej\n  inifile: None\n  rootdir: /tmp/pytest-of-root/pytest-0/test_unknown_option0\n\n_____________ TestGeneralUsage.test_getsourcelines_error_issue553 ______________\n----------------------------- Captured stdout call -----------------------------\n============================= test session starts ==============================\nplatform linux -- Python 3.9.20, pytest-8.0.0.dev46+g2f7415cfb.d20220101, pluggy-1.3.0\nrootdir: /tmp/pytest-of-root/pytest-0/test_getsourcelines_error_issue5530\ncollected 1 item\n\ntest_getsourcelines_error_issue553.py E                                  [100%]\n\n==================================== ERRORS ====================================\n__________________________ ERROR at setup of test_foo __________________________\nfile /tmp/pytest-of-root/pytest-0/test_getsourcelines_error_issue5530/test_getsourcelines_error_issue553.py, line 7: source code not available\nE       fixture 'invalid_fixture' not found\n>       available fixtures: cache, capfd, capfdbinary, caplog, capsys, capsysbinary, doctest_namespace, monkeypatch, pytestconfig, record_property, record_testsuite_property, record_xml_attribute, recwarn, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory\n>       use 'pytest --fixtures [testpath]' for help on them.\n\n/tmp/pytest-of-root/pytest-0/test_getsourcelines_error_issue5530/test_getsourcelines_error_issue553.py:7\n=========================== short test summary info ============================\nERROR test_getsourcelines_error_issue553.py::test_foo\n=============================== 1 error in 0.00s ===============================\n________________ TestGeneralUsage.test_plugins_given_as_strings ________________\n----------------------------- Captured stdout call -----------------------------\n============================= test session starts ==============================\nplatform linux -- Python 3.9.20, pytest-8.0.0.dev46+g2f7415cfb.d20220101, pluggy-1.3.0\nrootdir: /tmp/pytest-of-root/pytest-0/test_plugins_given_as_strings0\ncollected 1 item\n\ntest_test_plugins_given_as_strings.py .                                  [100%]\n\n============================== 1 passed in 0.00s ===============================\n_____________ TestGeneralUsage.test_parametrized_with_bytes_regex ______________\n----------------------------- Captured stdout call -----------------------------\n============================= test session starts ==============================\nplatform linux -- Python 3.9.20, pytest-8.0.0.dev46+g2f7415cfb.d20220101, pluggy-1.3.0\nrootdir: /tmp/pytest-of-root/pytest-0/test_parametrized_with_bytes_regex0\ncollected 1 item\n\ntest_parametrized_with_bytes_regex.py .                                  [100%]\n\n============================== 1 passed in 0.00s ===============================\n______________ TestGeneralUsage.test_parametrized_with_null_bytes ______________\n----------------------------- Captured stdout call -----------------------------\n============================= test session starts ==============================\nplatform linux -- Python 3.9.20, pytest-8.0.0.dev46+g2f7415cfb.d20220101, pluggy-1.3.0\nrootdir: /tmp/pytest-of-root/pytest-0/test_parametrized_with_null_bytes0\ncollected 3 items\n\ntest_parametrized_with_null_bytes.py ...                                 [100%]\n\n============================== 3 passed in 0.01s ===============================\n____________________ TestInvocationVariants.test_earlyinit _____________________\n----------------------------- Captured stdout call -----------------------------\nrunning: /opt/miniconda3/envs/testbed/bin/python /tmp/pytest-of-root/pytest-0/test_earlyinit0/test_earlyinit.py\n     in: /tmp/pytest-of-root/pytest-0/test_earlyinit0\n______________________ TestInvocationVariants.test_pydoc _______________________\n----------------------------- Captured stdout call -----------------------------\nrunning: /opt/miniconda3/envs/testbed/bin/python -c import pytest;help(pytest)\n     in: /tmp/pytest-of-root/pytest-0/test_pydoc0\nHelp on package pytest:\n\nNAME\n    pytest - pytest: unit and functional testing with Python.\n\nPACKAGE CONTENTS\n    __main__\n\nCLASSES\n    _pytest.nodes.FSCollector(_pytest.nodes.Collector)\n        _pytest.main.Session\n        _pytest.nodes.File\n            _pytest.python.Module(_pytest.nodes.File, _pytest.python.PyCollector)\n                _pytest.python.Package\n    _pytest.nodes.Node(builtins.object)\n        _pytest.nodes.Collector\n        _pytest.nodes.Item\n            _pytest.doctest.DoctestItem\n            _pytest.python.Function(_pytest.python.PyobjMixin, _pytest.nodes.Item)\n    _pytest.python.PyCollector(_pytest.python.PyobjMixin, _pytest.nodes.Collector)\n        _pytest.python.Class\n    _pytest.python.PyobjMixin(_pytest.nodes.Node)\n        _pytest.python.Function(_pytest.python.PyobjMixin, _pytest.nodes.Item)\n    _pytest.reports.BaseReport(builtins.object)\n        _pytest.reports.CollectReport\n        _pytest.reports.TestReport\n    builtins.Exception(builtins.BaseException)\n        _pytest.config.exceptions.UsageError\n    builtins.LookupError(builtins.Exception)\n        _pytest.fixtures.FixtureLookupError\n    builtins.UserWarning(builtins.Warning)\n        PytestWarning\n            PytestAssertRewriteWarning\n            PytestCacheWarning\n            PytestCollectionWarning\n            PytestConfigWarning\n            PytestDeprecationWarning(PytestWarning, builtins.DeprecationWarning)\n                PytestRemovedIn8Warning\n                    PytestReturnNotNoneWarning\n                        PytestUnhandledCoroutineWarning\n                PytestRemovedIn9Warning\n            PytestExperimentalApiWarning(PytestWarning, builtins.FutureWarning)\n            PytestUnhandledThreadExceptionWarning\n            PytestUnknownMarkWarning\n            PytestUnraisableExceptionWarning\n    builtins.object\n        _pytest.cacheprovider.Cache\n        _pytest.config.Config\n        _pytest.config.cmdline\n        _pytest.config.argparsing.OptionGroup\n        _pytest.config.argparsing.Parser\n        _pytest.fixtures.FixtureRequest\n        _pytest.legacypath.TempdirFactory\n        _pytest.legacypath.Testdir\n        _pytest.logging.LogCaptureFixture\n        _pytest.mark.structures.Mark\n        _pytest.mark.structures.MarkDecorator\n        _pytest.mark.structures.MarkGenerator\n        _pytest.monkeypatch.MonkeyPatch\n        _pytest.pytester.HookRecorder\n        _pytest.pytester.LineMatcher\n        _pytest.pytester.Pytester\n        _pytest.pytester.RecordedHookCall\n        _pytest.pytester.RunResult\n        _pytest.python.Metafunc\n        _pytest.stash.Stash\n        _pytest.tmpdir.TempPathFactory\n    builtins.tuple(builtins.object)\n        _pytest.terminal.TestShortLogReport\n    enum.IntEnum(builtins.int, enum.Enum)\n        _pytest.config.ExitCode\n    pluggy._manager.PluginManager(builtins.object)\n        _pytest.config.PytestPluginManager\n    typing.Generic(builtins.object)\n        _pytest._code.code.ExceptionInfo\n        _pytest.capture.CaptureFixture\n        _pytest.runner.CallInfo\n        _pytest.stash.StashKey\n    warnings.catch_warnings(builtins.object)\n        _pytest.recwarn.WarningsRecorder\n    \n    class Cache(builtins.object)\n     |  Cache(cachedir: pathlib.Path, config: _pytest.config.Config, *, _ispytest: bool = False) -> None\n     |  \n     |  Instance of the `cache` fixture.\n     |  \n     |  Methods defined here:\n     |  \n     |  __eq__(self, other)\n     |  \n     |  __init__(self, cachedir: pathlib.Path, config: _pytest.config.Config, *, _ispytest: bool = False) -> None\n     |      Initialize self.  See help(type(self)) for accurate signature.\n     |  \n     |  __repr__(self)\n     |  \n     |  get(self, key: str, default)\n     |      Return the cached value for the given key.\n     |      \n     |      If no value was yet cached or the value cannot be read, the specified\n     |      default is returned.\n     |      \n     |      :param key:\n     |          Must be a ``/`` separated value. Usually the first\n     |          name is the name of your plugin or your application.\n     |      :param default:\n     |          The value to return in case of a cache-miss or invalid cache value.\n     |  \n     |  mkdir(self, name: str) -> pathlib.Path\n     |      Return a directory path object with the given name.\n     |      \n     |      If the directory does not yet exist, it will be created. You can use\n     |      it to manage files to e.g. store/retrieve database dumps across test\n     |      sessions.\n     |      \n     |      .. versionadded:: 7.0\n     |      \n     |      :param name:\n     |          Must be a string not containing a ``/`` separator.\n     |          Make sure the name contains your plugin or application\n     |          identifiers to prevent clashes with other cache users.\n     |  \n     |  set(self, key: str, value: object) -> None\n     |      Save value for the given key.\n     |      \n     |      :param key:\n     |          Must be a ``/`` separated value. Usually the first\n     |          name is the name of your plugin or your application.\n     |      :param value:\n     |          Must be of any combination of basic python types,\n     |          including nested types like lists of dictionaries.\n     |  \n     |  warn(self, fmt: str, *, _ispytest: bool = False, **args: object) -> None\n     |      Issue a cache warning.\n     |      \n     |      :meta private:\n     |  \n     |  ----------------------------------------------------------------------\n     |  Class methods defined here:\n     |  \n     |  clear_cache(cachedir: pathlib.Path, _ispytest: bool = False) -> None from builtins.type\n     |      Clear the sub-directories used to hold cached directories and values.\n     |      \n     |      :meta private:\n     |  \n     |  for_config(config: _pytest.config.Config, *, _ispytest: bool = False) -> 'Cache' from builtins.type\n     |      Create the Cache instance for a Config.\n     |      \n     |      :meta private:\n     |  \n     |  ----------------------------------------------------------------------\n     |  Static methods defined here:\n     |  \n     |  cache_dir_from_config(config: _pytest.config.Config, *, _ispytest: bool = False) -> pathlib.Path\n     |      Get the path to the cache directory for a Config.\n     |      \n     |      :meta private:\n     |  \n     |  ----------------------------------------------------------------------\n     |  Data descriptors defined here:\n     |  \n     |  __dict__\n     |      dictionary for instance variables (if defined)\n     |  \n     |  __weakref__\n     |      list of weak references to the object (if defined)\n     |  \n     |  ----------------------------------------------------------------------\n     |  Data and other attributes defined here:\n     |  \n     |  __annotations__ = {'_cachedir': <class 'pathlib.Path'>, '_config': <cl...\n     |  \n     |  __dataclass_fields__ = {'_cachedir': Field(name='_cachedir',type=<clas...\n     |  \n     |  __dataclass_params__ = _DataclassParams(init=True,repr=True,eq=True,or...\n     |  \n     |  __hash__ = None\n    \n    class CallInfo(typing.Generic)\n     |  CallInfo(result: Optional[+TResult], excinfo: Optional[_pytest._code.code.ExceptionInfo[BaseException]], start: float, stop: float, duration: float, when: \"Literal['collect', 'setup', 'call', 'teardown']\", *, _ispytest: bool = False) -> None\n     |  \n     |  Result/Exception info of a function invocation.\n     |  \n     |  Method resolution order:\n     |      CallInfo\n     |      typing.Generic\n     |      builtins.object\n     |  \n     |  Methods defined here:\n     |  \n     |  __eq__(self, other)\n     |  \n     |  __init__(self, result: Optional[+TResult], excinfo: Optional[_pytest._code.code.ExceptionInfo[BaseException]], start: float, stop: float, duration: float, when: \"Literal['collect', 'setup', 'call', 'teardown']\", *, _ispytest: bool = False) -> None\n     |      Initialize self.  See help(type(self)) for accurate signature.\n     |  \n     |  __repr__(self) -> str\n     |      Return repr(self).\n     |  \n     |  ----------------------------------------------------------------------\n     |  Class methods defined here:\n     |  \n     |  from_call(func: 'Callable[[], TResult]', when: \"Literal['collect', 'setup', 'call', 'teardown']\", reraise: Union[Type[BaseException], Tuple[Type[BaseException], ...], NoneType] = None) -> 'CallInfo[TResult]' from builtins.type\n     |      Call func, wrapping the result in a CallInfo.\n     |      \n     |      :param func:\n     |          The function to call. Called without arguments.\n     |      :param when:\n     |          The phase in which the function is called.\n     |      :param reraise:\n     |          Exception or exceptions that shall propagate if raised by the\n     |          function, instead of being wrapped in the CallInfo.\n     |  \n     |  ----------------------------------------------------------------------\n     |  Readonly properties defined here:\n     |  \n     |  result\n     |      The return value of the call, if it didn't raise.\n     |      \n     |      Can only be accessed if excinfo is None.\n     |  \n     |  ----------------------------------------------------------------------\n     |  Data descriptors defined here:\n     |  \n     |  __dict__\n     |      dictionary for instance variables (if defined)\n     |  \n     |  __weakref__\n     |      list of weak references to the object (if defined)\n     |  \n     |  ----------------------------------------------------------------------\n     |  Data and other attributes defined here:\n     |  \n     |  __annotations__ = {'_result': typing.Optional[+TResult], 'duration': <...\n     |  \n     |  __dataclass_fields__ = {'_result': Field(name='_result',type=typing.Op...\n     |  \n     |  __dataclass_params__ = _DataclassParams(init=True,repr=True,eq=True,or...\n     |  \n     |  __hash__ = None\n     |  \n     |  __orig_bases__ = (typing.Generic[+TResult],)\n     |  \n     |  __parameters__ = (+TResult,)\n     |  \n     |  ----------------------------------------------------------------------\n     |  Class methods inherited from typing.Generic:\n     |  \n     |  __class_getitem__(params) from builtins.type\n     |  \n     |  __init_subclass__(*args, **kwargs) from builtins.type\n     |      This method is called when a class is subclassed.\n     |      \n     |      The default implementation does nothing. It may be\n     |      overridden to extend subclasses.\n    \n    class CaptureFixture(typing.Generic)\n     |  CaptureFixture(captureclass: Type[_pytest.capture.CaptureBase[~AnyStr]], request: _pytest.fixtures.SubRequest, *, _ispytest: bool = False) -> None\n     |  \n     |  Object returned by the :fixture:`capsys`, :fixture:`capsysbinary`,\n     |  :fixture:`capfd` and :fixture:`capfdbinary` fixtures.\n     |  \n     |  Method resolution order:\n     |      CaptureFixture\n     |      typing.Generic\n     |      builtins.object\n     |  \n     |  Methods defined here:\n     |  \n     |  __init__(self, captureclass: Type[_pytest.capture.CaptureBase[~AnyStr]], request: _pytest.fixtures.SubRequest, *, _ispytest: bool = False) -> None\n     |      Initialize self.  See help(type(self)) for accurate signature.\n     |  \n     |  close(self) -> None\n     |  \n     |  disabled(self) -> Generator[NoneType, NoneType, NoneType]\n     |      Temporarily disable capturing while inside the ``with`` block.\n     |  \n     |  readouterr(self) -> _pytest.capture.CaptureResult[~AnyStr]\n     |      Read and return the captured output so far, resetting the internal\n     |      buffer.\n     |      \n     |      :returns:\n     |          The captured content as a namedtuple with ``out`` and ``err``\n     |          string attributes.\n     |  \n     |  ----------------------------------------------------------------------\n     |  Data descriptors defined here:\n     |  \n     |  __dict__\n     |      dictionary for instance variables (if defined)\n     |  \n     |  __weakref__\n     |      list of weak references to the object (if defined)\n     |  \n     |  ----------------------------------------------------------------------\n     |  Data and other attributes defined here:\n     |  \n     |  __orig_bases__ = (typing.Generic[~AnyStr],)\n     |  \n     |  __parameters__ = (~AnyStr,)\n     |  \n     |  ----------------------------------------------------------------------\n     |  Class methods inherited from typing.Generic:\n     |  \n     |  __class_getitem__(params) from builtins.type\n     |  \n     |  __init_subclass__(*args, **kwargs) from builtins.type\n     |      This method is called when a class is subclassed.\n     |      \n     |      The default implementation does nothing. It may be\n     |      overridden to extend subclasses.\n    \n    class Class(PyCollector)\n     |  Class(*k, **kw)\n     |  \n     |  Collector for test methods.\n     |  \n     |  Method resolution order:\n     |      Class\n     |      PyCollector\n     |      PyobjMixin\n     |      _pytest.nodes.Collector\n     |      _pytest.nodes.Node\n     |      builtins.object\n     |  \n     |  Methods defined here:\n     |  \n     |  collect(self) -> Iterable[Union[_pytest.nodes.Item, _pytest.nodes.Collector]]\n     |      Return a list of children (items and collectors) for this\n     |      collection node.\n     |  \n     |  newinstance(self)\n     |  \n     |  ----------------------------------------------------------------------\n     |  Class methods defined here:\n     |  \n     |  from_parent(parent, *, name, obj=None, **kw) from _pytest.nodes.NodeMeta\n     |      The public constructor.\n     |  \n     |  ----------------------------------------------------------------------\n     |  Methods inherited from PyCollector:\n     |  \n     |  classnamefilter(self, name: str) -> bool\n     |  \n     |  funcnamefilter(self, name: str) -> bool\n     |  \n     |  isnosetest(self, obj: object) -> bool\n     |      Look for the __test__ attribute, which is applied by the\n     |      @nose.tools.istest decorator.\n     |  \n     |  istestclass(self, obj: object, name: str) -> bool\n     |  \n     |  istestfunction(self, obj: object, name: str) -> bool\n     |  \n     |  ----------------------------------------------------------------------\n     |  Methods inherited from PyobjMixin:\n     |  \n     |  getmodpath(self, stopatmodule: bool = True, includemodule: bool = False) -> str\n     |      Return Python path relative to the containing module.\n     |  \n     |  reportinfo(self) -> Tuple[Union[ForwardRef('os.PathLike[str]'), str], Optional[int], str]\n     |  \n     |  ----------------------------------------------------------------------\n     |  Readonly properties inherited from PyobjMixin:\n     |  \n     |  cls\n     |      Python class object this node was collected from (can be None).\n     |  \n     |  instance\n     |      Python instance object the function is bound to.\n     |      \n     |      Returns None if not a test method, e.g. for a standalone test function,\n     |      a staticmethod, a class or a module.\n     |  \n     |  module\n     |      Python module object this node was collected from (can be None).\n     |  \n     |  ----------------------------------------------------------------------\n     |  Data descriptors inherited from PyobjMixin:\n     |  \n     |  __weakref__\n     |      list of weak references to the object (if defined)\n     |  \n     |  obj\n     |      Underlying Python object.\n     |  \n     |  ----------------------------------------------------------------------\n     |  Methods inherited from _pytest.nodes.Collector:\n     |  \n     |  repr_failure(self, excinfo: _pytest._code.code.ExceptionInfo[BaseException]) -> Union[str, _pytest._code.code.TerminalRepr]\n     |      Return a representation of a collection failure.\n     |      \n     |      :param excinfo: Exception information for the failure.\n     |  \n     |  ----------------------------------------------------------------------\n     |  Data and other attributes inherited from _pytest.nodes.Collector:\n     |  \n     |  CollectError = <class '_pytest.nodes.Collector.CollectError'>\n     |      An error during collection, contains a custom message.\n     |  \n     |  \n     |  ----------------------------------------------------------------------\n     |  Methods inherited from _pytest.nodes.Node:\n     |  \n     |  __hash__(self) -> int\n     |      Return hash(self).\n     |  \n     |  __init__(self, name: str, parent: 'Optional[Node]' = None, config: Optional[_pytest.config.Config] = None, session: 'Optional[Session]' = None, fspath: Optional[_pytest._py.path.LocalPath] = None, path: Optional[pathlib.Path] = None, nodeid: Optional[str] = None) -> None\n     |      Initialize self.  See help(type(self)) for accurate signature.\n     |  \n     |  __repr__(self) -> str\n     |      Return repr(self).\n     |  \n     |  add_marker(self, marker: Union[str, _pytest.mark.structures.MarkDecorator], append: bool = True) -> None\n     |      Dynamically add a marker object to the node.\n     |      \n     |      :param marker:\n     |          The marker.\n     |      :param append:\n     |          Whether to append the marker, or prepend it.\n     |  \n     |  addfinalizer(self, fin: Callable[[], object]) -> None\n     |      Register a function to be called without arguments when this node is\n     |      finalized.\n     |      \n     |      This method can only be called when this node is active\n     |      in a setup chain, for example during self.setup().\n     |  \n     |  get_closest_marker(self, name: str, default: Optional[_pytest.mark.structures.Mark] = None) -> Optional[_pytest.mark.structures.Mark]\n     |      Return the first marker matching the name, from closest (for\n     |      example function) to farther level (for example module level).\n     |      \n     |      :param default: Fallback return value if no marker was found.\n     |      :param name: Name to filter by.\n     |  \n     |  getparent(self, cls: Type[~_NodeType]) -> Optional[~_NodeType]\n     |      Get the next parent node (including self) which is an instance of\n     |      the given class.\n     |      \n     |      :param cls: The node class to search for.\n     |      :returns: The node, if found.\n     |  \n     |  iter_markers(self, name: Optional[str] = None) -> Iterator[_pytest.mark.structures.Mark]\n     |      Iterate over all markers of the node.\n     |      \n     |      :param name: If given, filter the results by the name attribute.\n     |      :returns: An iterator of the markers of the node.\n     |  \n     |  iter_markers_with_node(self, name: Optional[str] = None) -> Iterator[Tuple[ForwardRef('Node'), _pytest.mark.structures.Mark]]\n     |      Iterate over all markers of the node.\n     |      \n     |      :param name: If given, filter the results by the name attribute.\n     |      :returns: An iterator of (node, mark) tuples.\n     |  \n     |  listchain(self) -> List[ForwardRef('Node')]\n     |      Return list of all parent collectors up to self, starting from\n     |      the root of collection tree.\n     |      \n     |      :returns: The nodes.\n     |  \n     |  listextrakeywords(self) -> Set[str]\n     |      Return a set of all extra keywords in self and any parents.\n     |  \n     |  listnames(self) -> List[str]\n     |  \n     |  setup(self) -> None\n     |  \n     |  teardown(self) -> None\n     |  \n     |  warn(self, warning: Warning) -> None\n     |      Issue a warning for this Node.\n     |      \n     |      Warnings will be displayed after the test session, unless explicitly suppressed.\n     |      \n     |      :param Warning warning:\n     |          The warning instance to issue.\n     |      \n     |      :raises ValueError: If ``warning`` instance is not a subclass of Warning.\n     |      \n     |      Example usage:\n     |      \n     |      .. code-block:: python\n     |      \n     |          node.warn(PytestWarning(\"some message\"))\n     |          node.warn(UserWarning(\"some message\"))\n     |      \n     |      .. versionchanged:: 6.2\n     |          Any subclass of :class:`Warning` is now accepted, rather than only\n     |          :class:`PytestWarning <pytest.PytestWarning>` subclasses.\n     |  \n     |  ----------------------------------------------------------------------\n     |  Readonly properties inherited from _pytest.nodes.Node:\n     |  \n     |  ihook\n     |      fspath-sensitive hook proxy used to call pytest hooks.\n     |  \n     |  nodeid\n     |      A ::-separated string denoting its collection tree address.\n     |  \n     |  ----------------------------------------------------------------------\n     |  Data descriptors inherited from _pytest.nodes.Node:\n     |  \n     |  __dict__\n     |      dictionary for instance variables (if defined)\n     |  \n     |  config\n     |  \n     |  name\n     |  \n     |  parent\n     |  \n     |  path\n     |  \n     |  session\n     |  \n     |  ----------------------------------------------------------------------\n     |  Data and other attributes inherited from _pytest.nodes.Node:\n     |  \n     |  __annotations__ = {'fspath': <class '_pytest._py.path.LocalPath'>}\n    \n    class CollectReport(BaseReport)\n     |  CollectReport(nodeid: str, outcome: \"Literal['passed', 'failed', 'skipped']\", longrepr: Union[NoneType, _pytest._code.code.ExceptionInfo[BaseException], Tuple[str, int, str], str, _pytest._code.code.TerminalRepr], result: Optional[List[Union[_pytest.nodes.Item, _pytest.nodes.Collector]]], sections: Iterable[Tuple[str, str]] = (), **extra) -> None\n     |  \n     |  Collection report object.\n     |  \n     |  Reports can contain arbitrary extra attributes.\n     |  \n     |  Method resolution order:\n     |      CollectReport\n     |      BaseReport\n     |      builtins.object\n     |  \n     |  Methods defined here:\n     |  \n     |  __init__(self, nodeid: str, outcome: \"Literal['passed', 'failed', 'skipped']\", longrepr: Union[NoneType, _pytest._code.code.ExceptionInfo[BaseException], Tuple[str, int, str], str, _pytest._code.code.TerminalRepr], result: Optional[List[Union[_pytest.nodes.Item, _pytest.nodes.Collector]]], sections: Iterable[Tuple[str, str]] = (), **extra) -> None\n     |      Initialize self.  See help(type(self)) for accurate signature.\n     |  \n     |  __repr__(self) -> str\n     |      Return repr(self).\n     |  \n     |  ----------------------------------------------------------------------\n     |  Readonly properties defined here:\n     |  \n     |  location\n     |  \n     |  ----------------------------------------------------------------------\n     |  Data and other attributes defined here:\n     |  \n     |  when = 'collect'\n     |  \n     |  ----------------------------------------------------------------------\n     |  Methods inherited from BaseReport:\n     |  \n     |  get_sections(self, prefix: str) -> Iterator[Tuple[str, str]]\n     |  \n     |  toterminal(self, out: _pytest._io.terminalwriter.TerminalWriter) -> None\n     |  \n     |  ----------------------------------------------------------------------\n     |  Readonly properties inherited from BaseReport:\n     |  \n     |  caplog\n     |      Return captured log lines, if log capturing is enabled.\n     |      \n     |      .. versionadded:: 3.5\n     |  \n     |  capstderr\n     |      Return captured text from stderr, if capturing is enabled.\n     |      \n     |      .. versionadded:: 3.0\n     |  \n     |  capstdout\n     |      Return captured text from stdout, if capturing is enabled.\n     |      \n     |      .. versionadded:: 3.0\n     |  \n     |  count_towards_summary\n     |      **Experimental** Whether this report should be counted towards the\n     |      totals shown at the end of the test session: \"1 passed, 1 failure, etc\".\n     |      \n     |      .. note::\n     |      \n     |          This function is considered **experimental**, so beware that it is subject to changes\n     |          even in patch releases.\n     |  \n     |  failed\n     |      Whether the outcome is failed.\n     |  \n     |  fspath\n     |      The path portion of the reported node, as a string.\n     |  \n     |  head_line\n     |      **Experimental** The head line shown with longrepr output for this\n     |      report, more commonly during traceback representation during\n     |      failures::\n     |      \n     |          ________ Test.foo ________\n     |      \n     |      \n     |      In the example above, the head_line is \"Test.foo\".\n     |      \n     |      .. note::\n     |      \n     |          This function is considered **experimental**, so beware that it is subject to changes\n     |          even in patch releases.\n     |  \n     |  longreprtext\n     |      Read-only property that returns the full string representation of\n     |      ``longrepr``.\n     |      \n     |      .. versionadded:: 3.0\n     |  \n     |  passed\n     |      Whether the outcome is passed.\n     |  \n     |  skipped\n     |      Whether the outcome is skipped.\n     |  \n     |  ----------------------------------------------------------------------\n     |  Data descriptors inherited from BaseReport:\n     |  \n     |  __dict__\n     |      dictionary for instance variables (if defined)\n     |  \n     |  __weakref__\n     |      list of weak references to the object (if defined)\n     |  \n     |  ----------------------------------------------------------------------\n     |  Data and other attributes inherited from BaseReport:\n     |  \n     |  __annotations__ = {'location': typing.Optional[typing.Tuple[str, typin...\n    \n    class Collector(Node)\n     |  Collector(*k, **kw)\n     |  \n     |  Collector instances create children through collect() and thus\n     |  iteratively build a tree.\n     |  \n     |  Method resolution order:\n     |      Collector\n     |      Node\n     |      builtins.object\n     |  \n     |  Methods defined here:\n     |  \n     |  collect(self) -> Iterable[Union[ForwardRef('Item'), ForwardRef('Collector')]]\n     |      Return a list of children (items and collectors) for this\n     |      collection node.\n     |  \n     |  repr_failure(self, excinfo: _pytest._code.code.ExceptionInfo[BaseException]) -> Union[str, _pytest._code.code.TerminalRepr]\n     |      Return a representation of a collection failure.\n     |      \n     |      :param excinfo: Exception information for the failure.\n     |  \n     |  ----------------------------------------------------------------------\n     |  Data descriptors defined here:\n     |  \n     |  __weakref__\n     |      list of weak references to the object (if defined)\n     |  \n     |  ----------------------------------------------------------------------\n     |  Data and other attributes defined here:\n     |  \n     |  CollectError = <class '_pytest.nodes.Collector.CollectError'>\n     |      An error during collection, contains a custom message.\n     |  \n     |  \n     |  ----------------------------------------------------------------------\n     |  Methods inherited from Node:\n     |  \n     |  __hash__(self) -> int\n     |      Return hash(self).\n     |  \n     |  __init__(self, name: str, parent: 'Optional[Node]' = None, config: Optional[_pytest.config.Config] = None, session: 'Optional[Session]' = None, fspath: Optional[_pytest._py.path.LocalPath] = None, path: Optional[pathlib.Path] = None, nodeid: Optional[str] = None) -> None\n     |      Initialize self.  See help(type(self)) for accurate signature.\n     |  \n     |  __repr__(self) -> str\n     |      Return repr(self).\n     |  \n     |  add_marker(self, marker: Union[str, _pytest.mark.structures.MarkDecorator], append: bool = True) -> None\n     |      Dynamically add a marker object to the node.\n     |      \n     |      :param marker:\n     |          The marker.\n     |      :param append:\n     |          Whether to append the marker, or prepend it.\n     |  \n     |  addfinalizer(self, fin: Callable[[], object]) -> None\n     |      Register a function to be called without arguments when this node is\n     |      finalized.\n     |      \n     |      This method can only be called when this node is active\n     |      in a setup chain, for example during self.setup().\n     |  \n     |  get_closest_marker(self, name: str, default: Optional[_pytest.mark.structures.Mark] = None) -> Optional[_pytest.mark.structures.Mark]\n     |      Return the first marker matching the name, from closest (for\n     |      example function) to farther level (for example module level).\n     |      \n     |      :param default: Fallback return value if no marker was found.\n     |      :param name: Name to filter by.\n     |  \n     |  getparent(self, cls: Type[~_NodeType]) -> Optional[~_NodeType]\n     |      Get the next parent node (including self) which is an instance of\n     |      the given class.\n     |      \n     |      :param cls: The node class to search for.\n     |      :returns: The node, if found.\n     |  \n     |  iter_markers(self, name: Optional[str] = None) -> Iterator[_pytest.mark.structures.Mark]\n     |      Iterate over all markers of the node.\n     |      \n     |      :param name: If given, filter the results by the name attribute.\n     |      :returns: An iterator of the markers of the node.\n     |  \n     |  iter_markers_with_node(self, name: Optional[str] = None) -> Iterator[Tuple[ForwardRef('Node'), _pytest.mark.structures.Mark]]\n     |      Iterate over all markers of the node.\n     |      \n     |      :param name: If given, filter the results by the name attribute.\n     |      :returns: An iterator of (node, mark) tuples.\n     |  \n     |  listchain(self) -> List[ForwardRef('Node')]\n     |      Return list of all parent collectors up to self, starting from\n     |      the root of collection tree.\n     |      \n     |      :returns: The nodes.\n     |  \n     |  listextrakeywords(self) -> Set[str]\n     |      Return a set of all extra keywords in self and any parents.\n     |  \n     |  listnames(self) -> List[str]\n     |  \n     |  setup(self) -> None\n     |  \n     |  teardown(self) -> None\n     |  \n     |  warn(self, warning: Warning) -> None\n     |      Issue a warning for this Node.\n     |      \n     |      Warnings will be displayed after the test session, unless explicitly suppressed.\n     |      \n     |      :param Warning warning:\n     |          The warning instance to issue.\n     |      \n     |      :raises ValueError: If ``warning`` instance is not a subclass of Warning.\n     |      \n     |      Example usage:\n     |      \n     |      .. code-block:: python\n     |      \n     |          node.warn(PytestWarning(\"some message\"))\n     |          node.warn(UserWarning(\"some message\"))\n     |      \n     |      .. versionchanged:: 6.2\n     |          Any subclass of :class:`Warning` is now accepted, rather than only\n     |          :class:`PytestWarning <pytest.PytestWarning>` subclasses.\n     |  \n     |  ----------------------------------------------------------------------\n     |  Class methods inherited from Node:\n     |  \n     |  from_parent(parent: 'Node', **kw) from _pytest.nodes.NodeMeta\n     |      Public constructor for Nodes.\n     |      \n     |      This indirection got introduced in order to enable removing\n     |      the fragile logic from the node constructors.\n     |      \n     |      Subclasses can use ``super().from_parent(...)`` when overriding the\n     |      construction.\n     |      \n     |      :param parent: The parent node of this Node.\n     |  \n     |  ----------------------------------------------------------------------\n     |  Readonly properties inherited from Node:\n     |  \n     |  ihook\n     |      fspath-sensitive hook proxy used to call pytest hooks.\n     |  \n     |  nodeid\n     |      A ::-separated string denoting its collection tree address.\n     |  \n     |  ----------------------------------------------------------------------\n     |  Data descriptors inherited from Node:\n     |  \n     |  __dict__\n     |      dictionary for instance variables (if defined)\n     |  \n     |  config\n     |  \n     |  name\n     |  \n     |  parent\n     |  \n     |  path\n     |  \n     |  session\n     |  \n     |  ----------------------------------------------------------------------\n     |  Data and other attributes inherited from Node:\n     |  \n     |  __annotations__ = {'fspath': <class '_pytest._py.path.LocalPath'>}\n    \n    class Config(builtins.object)\n     |  Config(pluginmanager: _pytest.config.PytestPluginManager, *, invocation_params: Optional[_pytest.config.Config.InvocationParams] = None) -> None\n     |  \n     |  Access to configuration values, pluginmanager and plugin hooks.\n     |  \n     |  :param PytestPluginManager pluginmanager:\n     |      A pytest PluginManager.\n     |  \n     |  :param InvocationParams invocation_params:\n     |      Object containing parameters regarding the :func:`pytest.main`\n     |      invocation.\n     |  \n     |  Methods defined here:\n     |  \n     |  __init__(self, pluginmanager: _pytest.config.PytestPluginManager, *, invocation_params: Optional[_pytest.config.Config.InvocationParams] = None) -> None\n     |      Initialize self.  See help(type(self)) for accurate signature.\n     |  \n     |  add_cleanup(self, func: Callable[[], NoneType]) -> None\n     |      Add a function to be called when the config object gets out of\n     |      use (usually coinciding with pytest_unconfigure).\n     |  \n     |  addinivalue_line(self, name: str, line: str) -> None\n     |      Add a line to an ini-file option. The option must have been\n     |      declared but might not yet be set in which case the line becomes\n     |      the first line in its value.\n     |  \n     |  cwd_relative_nodeid(self, nodeid: str) -> str\n     |  \n     |  get_terminal_writer(self) -> _pytest._io.terminalwriter.TerminalWriter\n     |  \n     |  getini(self, name: str)\n     |      Return configuration value from an :ref:`ini file <configfiles>`.\n     |      \n     |      If the specified name hasn't been registered through a prior\n     |      :func:`parser.addini <pytest.Parser.addini>` call (usually from a\n     |      plugin), a ValueError is raised.\n     |  \n     |  getoption(self, name: str, default=<NOTSET>, skip: bool = False)\n     |      Return command line option value.\n     |      \n     |      :param name: Name of the option.  You may also specify\n     |          the literal ``--OPT`` option instead of the \"dest\" option name.\n     |      :param default: Default value if no option of that name exists.\n     |      :param skip: If True, raise pytest.skip if option does not exists\n     |          or has a None value.\n     |  \n     |  getvalue(self, name: str, path=None)\n     |      Deprecated, use getoption() instead.\n     |  \n     |  getvalueorskip(self, name: str, path=None)\n     |      Deprecated, use getoption(skip=True) instead.\n     |  \n     |  issue_config_time_warning(self, warning: Warning, stacklevel: int) -> None\n     |      Issue and handle a warning during the \"configure\" stage.\n     |      \n     |      During ``pytest_configure`` we can't capture warnings using the ``catch_warnings_for_item``\n     |      function because it is not possible to have hookwrappers around ``pytest_configure``.\n     |      \n     |      This function is mainly intended for plugins that need to issue warnings during\n     |      ``pytest_configure`` (or similar stages).\n     |      \n     |      :param warning: The warning instance.\n     |      :param stacklevel: stacklevel forwarded to warnings.warn.\n     |  \n     |  notify_exception(self, excinfo: _pytest._code.code.ExceptionInfo[BaseException], option: Optional[argparse.Namespace] = None) -> None\n     |  \n     |  parse(self, args: List[str], addopts: bool = True) -> None\n     |  \n     |  pytest_cmdline_parse(self, pluginmanager: _pytest.config.PytestPluginManager, args: List[str]) -> 'Config'\n     |  \n     |  pytest_collection(self) -> Generator[NoneType, NoneType, NoneType]\n     |  \n     |  pytest_load_initial_conftests(self, early_config: 'Config') -> None\n     |  \n     |  ----------------------------------------------------------------------\n     |  Class methods defined here:\n     |  \n     |  fromdictargs(option_dict, args) -> 'Config' from builtins.type\n     |      Constructor usable for subprocesses.\n     |  \n     |  ----------------------------------------------------------------------\n     |  Readonly properties defined here:\n     |  \n     |  inipath\n     |      The path to the :ref:`configfile <configfiles>`.\n     |      \n     |      :type: Optional[pathlib.Path]\n     |      \n     |      .. versionadded:: 6.1\n     |  \n     |  rootpath\n     |      The path to the :ref:`rootdir <rootdir>`.\n     |      \n     |      :type: pathlib.Path\n     |      \n     |      .. versionadded:: 6.1\n     |  \n     |  ----------------------------------------------------------------------\n     |  Data descriptors defined here:\n     |  \n     |  __dict__\n     |      dictionary for instance variables (if defined)\n     |  \n     |  __weakref__\n     |      list of weak references to the object (if defined)\n     |  \n     |  ----------------------------------------------------------------------\n     |  Data and other attributes defined here:\n     |  \n     |  ArgsSource = <enum 'ArgsSource'>\n     |      Indicates the source of the test arguments.\n     |      \n     |      .. versionadded:: 7.2\n     |  \n     |  \n     |  InvocationParams = <class '_pytest.config.Config.InvocationParams'>\n     |      Holds parameters passed during :func:`pytest.main`.\n     |      \n     |      The object attributes are read-only.\n     |      \n     |      .. versionadded:: 5.1\n     |      \n     |      .. note::\n     |      \n     |          Note that the environment variable ``PYTEST_ADDOPTS`` and the ``addopts``\n     |          ini option are handled by pytest, not being included in the ``args`` attribute.\n     |      \n     |          Plugins accessing ``InvocationParams`` must be aware of that.\n    \n    class DoctestItem(_pytest.nodes.Item)\n     |  DoctestItem(*k, **kw)\n     |  \n     |  Method resolution order:\n     |      DoctestItem\n     |      _pytest.nodes.Item\n     |      _pytest.nodes.Node\n     |      builtins.object\n     |  \n     |  Methods defined here:\n     |  \n     |  __init__(self, name: str, parent: 'Union[DoctestTextfile, DoctestModule]', runner: Optional[ForwardRef('doctest.DocTestRunner')] = None, dtest: Optional[ForwardRef('doctest.DocTest')] = None) -> None\n     |      Initialize self.  See help(type(self)) for accurate signature.\n     |  \n     |  reportinfo(self) -> Tuple[Union[ForwardRef('os.PathLike[str]'), str], Optional[int], str]\n     |      Get location information for this item for test reports.\n     |      \n     |      Returns a tuple with three elements:\n     |      \n     |      - The path of the test (default ``self.path``)\n     |      - The 0-based line number of the test (default ``None``)\n     |      - A name of the test to be shown (default ``\"\"``)\n     |      \n     |      .. seealso:: :ref:`non-python tests`\n     |  \n     |  repr_failure(self, excinfo: _pytest._code.code.ExceptionInfo[BaseException]) -> Union[str, _pytest._code.code.TerminalRepr]\n     |      Return a representation of a collection or test failure.\n     |      \n     |      .. seealso:: :ref:`non-python tests`\n     |      \n     |      :param excinfo: Exception information for the failure.\n     |  \n     |  runtest(self) -> None\n     |      Run the test case for this item.\n     |      \n     |      Must be implemented by subclasses.\n     |      \n     |      .. seealso:: :ref:`non-python tests`\n     |  \n     |  setup(self) -> None\n     |  \n     |  ----------------------------------------------------------------------\n     |  Class methods defined here:\n     |  \n     |  from_parent(parent: 'Union[DoctestTextfile, DoctestModule]', *, name: str, runner: 'doctest.DocTestRunner', dtest: 'doctest.DocTest') from _pytest.nodes.NodeMeta\n     |      The public named constructor.\n     |  \n     |  ----------------------------------------------------------------------\n     |  Methods inherited from _pytest.nodes.Item:\n     |  \n     |  add_report_section(self, when: str, key: str, content: str) -> None\n     |      Add a new report section, similar to what's done internally to add\n     |      stdout and stderr captured output::\n     |      \n     |          item.add_report_section(\"call\", \"stdout\", \"report section contents\")\n     |      \n     |      :param str when:\n     |          One of the possible capture states, ``\"setup\"``, ``\"call\"``, ``\"teardown\"``.\n     |      :param str key:\n     |          Name of the section, can be customized at will. Pytest uses ``\"stdout\"`` and\n     |          ``\"stderr\"`` internally.\n     |      :param str content:\n     |          The full contents as a string.\n     |  \n     |  location = <functools.cached_property object>\n     |      Returns a tuple of ``(relfspath, lineno, testname)`` for this item\n     |      where ``relfspath`` is file path relative to ``config.rootpath``\n     |      and lineno is a 0-based line number.\n     |  \n     |  ----------------------------------------------------------------------\n     |  Data descriptors inherited from _pytest.nodes.Item:\n     |  \n     |  __weakref__\n     |      list of weak references to the object (if defined)\n     |  \n     |  ----------------------------------------------------------------------\n     |  Data and other attributes inherited from _pytest.nodes.Item:\n     |  \n     |  nextitem = None\n     |  \n     |  ----------------------------------------------------------------------\n     |  Methods inherited from _pytest.nodes.Node:\n     |  \n     |  __hash__(self) -> int\n     |      Return hash(self).\n     |  \n     |  __repr__(self) -> str\n     |      Return repr(self).\n     |  \n     |  add_marker(self, marker: Union[str, _pytest.mark.structures.MarkDecorator], append: bool = True) -> None\n     |      Dynamically add a marker object to the node.\n     |      \n     |      :param marker:\n     |          The marker.\n     |      :param append:\n     |          Whether to append the marker, or prepend it.\n     |  \n     |  addfinalizer(self, fin: Callable[[], object]) -> None\n     |      Register a function to be called without arguments when this node is\n     |      finalized.\n     |      \n     |      This method can only be called when this node is active\n     |      in a setup chain, for example during self.setup().\n     |  \n     |  get_closest_marker(self, name: str, default: Optional[_pytest.mark.structures.Mark] = None) -> Optional[_pytest.mark.structures.Mark]\n     |      Return the first marker matching the name, from closest (for\n     |      example function) to farther level (for example module level).\n     |      \n     |      :param default: Fallback return value if no marker was found.\n     |      :param name: Name to filter by.\n     |  \n     |  getparent(self, cls: Type[~_NodeType]) -> Optional[~_NodeType]\n     |      Get the next parent node (including self) which is an instance of\n     |      the given class.\n     |      \n     |      :param cls: The node class to search for.\n     |      :returns: The node, if found.\n     |  \n     |  iter_markers(self, name: Optional[str] = None) -> Iterator[_pytest.mark.structures.Mark]\n     |      Iterate over all markers of the node.\n     |      \n     |      :param name: If given, filter the results by the name attribute.\n     |      :returns: An iterator of the markers of the node.\n     |  \n     |  iter_markers_with_node(self, name: Optional[str] = None) -> Iterator[Tuple[ForwardRef('Node'), _pytest.mark.structures.Mark]]\n     |      Iterate over all markers of the node.\n     |      \n     |      :param name: If given, filter the results by the name attribute.\n     |      :returns: An iterator of (node, mark) tuples.\n     |  \n     |  listchain(self) -> List[ForwardRef('Node')]\n     |      Return list of all parent collectors up to self, starting from\n     |      the root of collection tree.\n     |      \n     |      :returns: The nodes.\n     |  \n     |  listextrakeywords(self) -> Set[str]\n     |      Return a set of all extra keywords in self and any parents.\n     |  \n     |  listnames(self) -> List[str]\n     |  \n     |  teardown(self) -> None\n     |  \n     |  warn(self, warning: Warning) -> None\n     |      Issue a warning for this Node.\n     |      \n     |      Warnings will be displayed after the test session, unless explicitly suppressed.\n     |      \n     |      :param Warning warning:\n     |          The warning instance to issue.\n     |      \n     |      :raises ValueError: If ``warning`` instance is not a subclass of Warning.\n     |      \n     |      Example usage:\n     |      \n     |      .. code-block:: python\n     |      \n     |          node.warn(PytestWarning(\"some message\"))\n     |          node.warn(UserWarning(\"some message\"))\n     |      \n     |      .. versionchanged:: 6.2\n     |          Any subclass of :class:`Warning` is now accepted, rather than only\n     |          :class:`PytestWarning <pytest.PytestWarning>` subclasses.\n     |  \n     |  ----------------------------------------------------------------------\n     |  Readonly properties inherited from _pytest.nodes.Node:\n     |  \n     |  ihook\n     |      fspath-sensitive hook proxy used to call pytest hooks.\n     |  \n     |  nodeid\n     |      A ::-separated string denoting its collection tree address.\n     |  \n     |  ----------------------------------------------------------------------\n     |  Data descriptors inherited from _pytest.nodes.Node:\n     |  \n     |  __dict__\n     |      dictionary for instance variables (if defined)\n     |  \n     |  config\n     |  \n     |  name\n     |  \n     |  parent\n     |  \n     |  path\n     |  \n     |  session\n     |  \n     |  ----------------------------------------------------------------------\n     |  Data and other attributes inherited from _pytest.nodes.Node:\n     |  \n     |  __annotations__ = {'fspath': <class '_pytest._py.path.LocalPath'>}\n    \n    class ExceptionInfo(typing.Generic)\n     |  ExceptionInfo(excinfo: Optional[Tuple[Type[ForwardRef('E')], ForwardRef('E'), traceback]], striptext: str = '', traceback: Optional[_pytest._code.code.Traceback] = None, *, _ispytest: bool = False) -> None\n     |  \n     |  Wraps sys.exc_info() objects and offers help for navigating the traceback.\n     |  \n     |  Method resolution order:\n     |      ExceptionInfo\n     |      typing.Generic\n     |      builtins.object\n     |  \n     |  Methods defined here:\n     |  \n     |  __eq__(self, other)\n     |  \n     |  __init__(self, excinfo: Optional[Tuple[Type[ForwardRef('E')], ForwardRef('E'), traceback]], striptext: str = '', traceback: Optional[_pytest._code.code.Traceback] = None, *, _ispytest: bool = False) -> None\n     |      Initialize self.  See help(type(self)) for accurate signature.\n     |  \n     |  __repr__(self) -> str\n     |      Return repr(self).\n     |  \n     |  errisinstance(self, exc: Union[Type[BaseException], Tuple[Type[BaseException], ...]]) -> bool\n     |      Return True if the exception is an instance of exc.\n     |      \n     |      Consider using ``isinstance(excinfo.value, exc)`` instead.\n     |  \n     |  exconly(self, tryshort: bool = False) -> str\n     |      Return the exception as a string.\n     |      \n     |      When 'tryshort' resolves to True, and the exception is an\n     |      AssertionError, only the actual exception part of the exception\n     |      representation is returned (so 'AssertionError: ' is removed from\n     |      the beginning).\n     |  \n     |  fill_unfilled(self, exc_info: Tuple[Type[+E], +E, traceback]) -> None\n     |      Fill an unfilled ExceptionInfo created with ``for_later()``.\n     |  \n     |  getrepr(self, showlocals: bool = False, style: Literal['long', 'short', 'line', 'no', 'native', 'value', 'auto'] = 'long', abspath: bool = False, tbfilter: Union[bool, Callable[[ForwardRef('ExceptionInfo[BaseException]')], _pytest._code.code.Traceback]] = True, funcargs: bool = False, truncate_locals: bool = True, chain: bool = True) -> Union[ForwardRef('ReprExceptionInfo'), ForwardRef('ExceptionChainRepr')]\n     |      Return str()able representation of this exception info.\n     |      \n     |      :param bool showlocals:\n     |          Show locals per traceback entry.\n     |          Ignored if ``style==\"native\"``.\n     |      \n     |      :param str style:\n     |          long|short|line|no|native|value traceback style.\n     |      \n     |      :param bool abspath:\n     |          If paths should be changed to absolute or left unchanged.\n     |      \n     |      :param tbfilter:\n     |          A filter for traceback entries.\n     |      \n     |          * If false, don't hide any entries.\n     |          * If true, hide internal entries and entries that contain a local\n     |            variable ``__tracebackhide__ = True``.\n     |          * If a callable, delegates the filtering to the callable.\n     |      \n     |          Ignored if ``style`` is ``\"native\"``.\n     |      \n     |      :param bool funcargs:\n     |          Show fixtures (\"funcargs\" for legacy purposes) per traceback entry.\n     |      \n     |      :param bool truncate_locals:\n     |          With ``showlocals==True``, make sure locals can be safely represented as strings.\n     |      \n     |      :param bool chain:\n     |          If chained exceptions in Python 3 should be shown.\n     |      \n     |      .. versionchanged:: 3.9\n     |      \n     |          Added the ``chain`` parameter.\n     |  \n     |  match(self, regexp: Union[str, Pattern[str]]) -> 'Literal[True]'\n     |      Check whether the regular expression `regexp` matches the string\n     |      representation of the exception using :func:`python:re.search`.\n     |      \n     |      If it matches `True` is returned, otherwise an `AssertionError` is raised.\n     |  \n     |  ----------------------------------------------------------------------\n     |  Class methods defined here:\n     |  \n     |  for_later() -> 'ExceptionInfo[E]' from builtins.type\n     |      Return an unfilled ExceptionInfo.\n     |  \n     |  from_current(exprinfo: Optional[str] = None) -> 'ExceptionInfo[BaseException]' from builtins.type\n     |      Return an ExceptionInfo matching the current traceback.\n     |      \n     |      .. warning::\n     |      \n     |          Experimental API\n     |      \n     |      :param exprinfo:\n     |          A text string helping to determine if we should strip\n     |          ``AssertionError`` from the output. Defaults to the exception\n     |          message/``__str__()``.\n     |  \n     |  from_exc_info(exc_info: Tuple[Type[+E], +E, traceback], exprinfo: Optional[str] = None) -> 'ExceptionInfo[E]' from builtins.type\n     |      Like :func:`from_exception`, but using old-style exc_info tuple.\n     |  \n     |  from_exception(exception: +E, exprinfo: Optional[str] = None) -> 'ExceptionInfo[E]' from builtins.type\n     |      Return an ExceptionInfo for an existing exception.\n     |      \n     |      The exception must have a non-``None`` ``__traceback__`` attribute,\n     |      otherwise this function fails with an assertion error. This means that\n     |      the exception must have been raised, or added a traceback with the\n     |      :py:meth:`~BaseException.with_traceback()` method.\n     |      \n     |      :param exprinfo:\n     |          A text string helping to determine if we should strip\n     |          ``AssertionError`` from the output. Defaults to the exception\n     |          message/``__str__()``.\n     |      \n     |      .. versionadded:: 7.4\n     |  \n     |  ----------------------------------------------------------------------\n     |  Readonly properties defined here:\n     |  \n     |  tb\n     |      The exception raw traceback.\n     |  \n     |  type\n     |      The exception class.\n     |  \n     |  typename\n     |      The type name of the exception.\n     |  \n     |  value\n     |      The exception value.\n     |  \n     |  ----------------------------------------------------------------------\n     |  Data descriptors defined here:\n     |  \n     |  __dict__\n     |      dictionary for instance variables (if defined)\n     |  \n     |  __weakref__\n     |      list of weak references to the object (if defined)\n     |  \n     |  traceback\n     |      The traceback.\n     |  \n     |  ----------------------------------------------------------------------\n     |  Data and other attributes defined here:\n     |  \n     |  __annotations__ = {'_assert_start_repr': typing.ClassVar, '_excinfo': ...\n     |  \n     |  __dataclass_fields__ = {'_assert_start_repr': Field(name='_assert_star...\n     |  \n     |  __dataclass_params__ = _DataclassParams(init=True,repr=True,eq=True,or...\n     |  \n     |  __hash__ = None\n     |  \n     |  __orig_bases__ = (typing.Generic[+E],)\n     |  \n     |  __parameters__ = (+E,)\n     |  \n     |  ----------------------------------------------------------------------\n     |  Class methods inherited from typing.Generic:\n     |  \n     |  __class_getitem__(params) from builtins.type\n     |  \n     |  __init_subclass__(*args, **kwargs) from builtins.type\n     |      This method is called when a class is subclassed.\n     |      \n     |      The default implementation does nothing. It may be\n     |      overridden to extend subclasses.\n    \n    class ExitCode(enum.IntEnum)\n     |  ExitCode(value, names=None, *, module=None, qualname=None, type=None, start=1)\n     |  \n     |  Encodes the valid exit codes by pytest.\n     |  \n     |  Currently users and plugins may supply other exit codes as well.\n     |  \n     |  .. versionadded:: 5.0\n     |  \n     |  Method resolution order:\n     |      ExitCode\n     |      enum.IntEnum\n     |      builtins.int\n     |      enum.Enum\n     |      builtins.object\n     |  \n     |  Data and other attributes defined here:\n     |  \n     |  INTERNAL_ERROR = <ExitCode.INTERNAL_ERROR: 3>\n     |  \n     |  INTERRUPTED = <ExitCode.INTERRUPTED: 2>\n     |  \n     |  NO_TESTS_COLLECTED = <ExitCode.NO_TESTS_COLLECTED: 5>\n     |  \n     |  OK = <ExitCode.OK: 0>\n     |  \n     |  TESTS_FAILED = <ExitCode.TESTS_FAILED: 1>\n     |  \n     |  USAGE_ERROR = <ExitCode.USAGE_ERROR: 4>\n     |  \n     |  ----------------------------------------------------------------------\n     |  Data descriptors inherited from enum.Enum:\n     |  \n     |  name\n     |      The name of the Enum member.\n     |  \n     |  value\n     |      The value of the Enum member.\n     |  \n     |  ----------------------------------------------------------------------\n     |  Readonly properties inherited from enum.EnumMeta:\n     |  \n     |  __members__\n     |      Returns a mapping of member name->value.\n     |      \n     |      This mapping lists all enum members, including aliases. Note that this\n     |      is a read-only view of the internal mapping.\n    \n    class File(FSCollector)\n     |  File(*k, **kw)\n     |  \n     |  Base class for collecting tests from a file.\n     |  \n     |  :ref:`non-python tests`.\n     |  \n     |  Method resolution order:\n     |      File\n     |      FSCollector\n     |      Collector\n     |      Node\n     |      builtins.object\n     |  \n     |  Methods inherited from FSCollector:\n     |  \n     |  __init__(self, fspath: Optional[_pytest._py.path.LocalPath] = None, path_or_parent: Union[pathlib.Path, _pytest.nodes.Node, NoneType] = None, path: Optional[pathlib.Path] = None, name: Optional[str] = None, parent: Optional[_pytest.nodes.Node] = None, config: Optional[_pytest.config.Config] = None, session: Optional[ForwardRef('Session')] = None, nodeid: Optional[str] = None) -> None\n     |      Initialize self.  See help(type(self)) for accurate signature.\n     |  \n     |  gethookproxy(self, fspath: 'os.PathLike[str]')\n     |  \n     |  isinitpath(self, path: Union[str, ForwardRef('os.PathLike[str]')]) -> bool\n     |  \n     |  ----------------------------------------------------------------------\n     |  Class methods inherited from FSCollector:\n     |  \n     |  from_parent(parent, *, fspath: Optional[_pytest._py.path.LocalPath] = None, path: Optional[pathlib.Path] = None, **kw) from _pytest.nodes.NodeMeta\n     |      The public constructor.\n     |  \n     |  ----------------------------------------------------------------------\n     |  Methods inherited from Collector:\n     |  \n     |  collect(self) -> Iterable[Union[ForwardRef('Item'), ForwardRef('Collector')]]\n     |      Return a list of children (items and collectors) for this\n     |      collection node.\n     |  \n     |  repr_failure(self, excinfo: _pytest._code.code.ExceptionInfo[BaseException]) -> Union[str, _pytest._code.code.TerminalRepr]\n     |      Return a representation of a collection failure.\n     |      \n     |      :param excinfo: Exception information for the failure.\n     |  \n     |  ----------------------------------------------------------------------\n     |  Data descriptors inherited from Collector:\n     |  \n     |  __weakref__\n     |      list of weak references to the object (if defined)\n     |  \n     |  ----------------------------------------------------------------------\n     |  Data and other attributes inherited from Collector:\n     |  \n     |  CollectError = <class '_pytest.nodes.Collector.CollectError'>\n     |      An error during collection, contains a custom message.\n     |  \n     |  \n     |  ----------------------------------------------------------------------\n     |  Methods inherited from Node:\n     |  \n     |  __hash__(self) -> int\n     |      Return hash(self).\n     |  \n     |  __repr__(self) -> str\n     |      Return repr(self).\n     |  \n     |  add_marker(self, marker: Union[str, _pytest.mark.structures.MarkDecorator], append: bool = True) -> None\n     |      Dynamically add a marker object to the node.\n     |      \n     |      :param marker:\n     |          The marker.\n     |      :param append:\n     |          Whether to append the marker, or prepend it.\n     |  \n     |  addfinalizer(self, fin: Callable[[], object]) -> None\n     |      Register a function to be called without arguments when this node is\n     |      finalized.\n     |      \n     |      This method can only be called when this node is active\n     |      in a setup chain, for example during self.setup().\n     |  \n     |  get_closest_marker(self, name: str, default: Optional[_pytest.mark.structures.Mark] = None) -> Optional[_pytest.mark.structures.Mark]\n     |      Return the first marker matching the name, from closest (for\n     |      example function) to farther level (for example module level).\n     |      \n     |      :param default: Fallback return value if no marker was found.\n     |      :param name: Name to filter by.\n     |  \n     |  getparent(self, cls: Type[~_NodeType]) -> Optional[~_NodeType]\n     |      Get the next parent node (including self) which is an instance of\n     |      the given class.\n     |      \n     |      :param cls: The node class to search for.\n     |      :returns: The node, if found.\n     |  \n     |  iter_markers(self, name: Optional[str] = None) -> Iterator[_pytest.mark.structures.Mark]\n     |      Iterate over all markers of the node.\n     |      \n     |      :param name: If given, filter the results by the name attribute.\n     |      :returns: An iterator of the markers of the node.\n     |  \n     |  iter_markers_with_node(self, name: Optional[str] = None) -> Iterator[Tuple[ForwardRef('Node'), _pytest.mark.structures.Mark]]\n     |      Iterate over all markers of the node.\n     |      \n     |      :param name: If given, filter the results by the name attribute.\n     |      :returns: An iterator of (node, mark) tuples.\n     |  \n     |  listchain(self) -> List[ForwardRef('Node')]\n     |      Return list of all parent collectors up to self, starting from\n     |      the root of collection tree.\n     |      \n     |      :returns: The nodes.\n     |  \n     |  listextrakeywords(self) -> Set[str]\n     |      Return a set of all extra keywords in self and any parents.\n     |  \n     |  listnames(self) -> List[str]\n     |  \n     |  setup(self) -> None\n     |  \n     |  teardown(self) -> None\n     |  \n     |  warn(self, warning: Warning) -> None\n     |      Issue a warning for this Node.\n     |      \n     |      Warnings will be displayed after the test session, unless explicitly suppressed.\n     |      \n     |      :param Warning warning:\n     |          The warning instance to issue.\n     |      \n     |      :raises ValueError: If ``warning`` instance is not a subclass of Warning.\n     |      \n     |      Example usage:\n     |      \n     |      .. code-block:: python\n     |      \n     |          node.warn(PytestWarning(\"some message\"))\n     |          node.warn(UserWarning(\"some message\"))\n     |      \n     |      .. versionchanged:: 6.2\n     |          Any subclass of :class:`Warning` is now accepted, rather than only\n     |          :class:`PytestWarning <pytest.PytestWarning>` subclasses.\n     |  \n     |  ----------------------------------------------------------------------\n     |  Readonly properties inherited from Node:\n     |  \n     |  ihook\n     |      fspath-sensitive hook proxy used to call pytest hooks.\n     |  \n     |  nodeid\n     |      A ::-separated string denoting its collection tree address.\n     |  \n     |  ----------------------------------------------------------------------\n     |  Data descriptors inherited from Node:\n     |  \n     |  __dict__\n     |      dictionary for instance variables (if defined)\n     |  \n     |  config\n     |  \n     |  name\n     |  \n     |  parent\n     |  \n     |  path\n     |  \n     |  session\n     |  \n     |  ----------------------------------------------------------------------\n     |  Data and other attributes inherited from Node:\n     |  \n     |  __annotations__ = {'fspath': <class '_pytest._py.path.LocalPath'>}\n    \n    class FixtureLookupError(builtins.LookupError)\n     |  FixtureLookupError(argname: Optional[str], request: _pytest.fixtures.FixtureRequest, msg: Optional[str] = None) -> None\n     |  \n     |  Could not return a requested fixture (missing or invalid).\n     |  \n     |  Method resolution order:\n     |      FixtureLookupError\n     |      builtins.LookupError\n     |      builtins.Exception\n     |      builtins.BaseException\n     |      builtins.object\n     |  \n     |  Methods defined here:\n     |  \n     |  __init__(self, argname: Optional[str], request: _pytest.fixtures.FixtureRequest, msg: Optional[str] = None) -> None\n     |      Initialize self.  See help(type(self)) for accurate signature.\n     |  \n     |  formatrepr(self) -> 'FixtureLookupErrorRepr'\n     |  \n     |  ----------------------------------------------------------------------\n     |  Data descriptors defined here:\n     |  \n     |  __weakref__\n     |      list of weak references to the object (if defined)\n     |  \n     |  ----------------------------------------------------------------------\n     |  Static methods inherited from builtins.LookupError:\n     |  \n     |  __new__(*args, **kwargs) from builtins.type\n     |      Create and return a new object.  See help(type) for accurate signature.\n     |  \n     |  ----------------------------------------------------------------------\n     |  Methods inherited from builtins.BaseException:\n     |  \n     |  __delattr__(self, name, /)\n     |      Implement delattr(self, name).\n     |  \n     |  __getattribute__(self, name, /)\n     |      Return getattr(self, name).\n     |  \n     |  __reduce__(...)\n     |      Helper for pickle.\n     |  \n     |  __repr__(self, /)\n     |      Return repr(self).\n     |  \n     |  __setattr__(self, name, value, /)\n     |      Implement setattr(self, name, value).\n     |  \n     |  __setstate__(...)\n     |  \n     |  __str__(self, /)\n     |      Return str(self).\n     |  \n     |  with_traceback(...)\n     |      Exception.with_traceback(tb) --\n     |      set self.__traceback__ to tb and return self.\n     |  \n     |  ----------------------------------------------------------------------\n     |  Data descriptors inherited from builtins.BaseException:\n     |  \n     |  __cause__\n     |      exception cause\n     |  \n     |  __context__\n     |      exception context\n     |  \n     |  __dict__\n     |  \n     |  __suppress_context__\n     |  \n     |  __traceback__\n     |  \n     |  args\n    \n    class FixtureRequest(builtins.object)\n     |  FixtureRequest(pyfuncitem, *, _ispytest: bool = False) -> None\n     |  \n     |  A request for a fixture from a test or fixture function.\n     |  \n     |  A request object gives access to the requesting test context and has\n     |  an optional ``param`` attribute in case the fixture is parametrized\n     |  indirectly.\n     |  \n     |  Methods defined here:\n     |  \n     |  __init__(self, pyfuncitem, *, _ispytest: bool = False) -> None\n     |      Initialize self.  See help(type(self)) for accurate signature.\n     |  \n     |  __repr__(self) -> str\n     |      Return repr(self).\n     |  \n     |  addfinalizer(self, finalizer: Callable[[], object]) -> None\n     |      Add finalizer/teardown function to be called without arguments after\n     |      the last test within the requesting test context finished execution.\n     |  \n     |  applymarker(self, marker: Union[str, _pytest.mark.structures.MarkDecorator]) -> None\n     |      Apply a marker to a single test function invocation.\n     |      \n     |      This method is useful if you don't want to have a keyword/marker\n     |      on all function invocations.\n     |      \n     |      :param marker:\n     |          An object created by a call to ``pytest.mark.NAME(...)``.\n     |  \n     |  getfixturevalue(self, argname: str) -> Any\n     |      Dynamically run a named fixture function.\n     |      \n     |      Declaring fixtures via function argument is recommended where possible.\n     |      But if you can only decide whether to use another fixture at test\n     |      setup time, you may use this function to retrieve it inside a fixture\n     |      or test function body.\n     |      \n     |      This method can be used during the test setup phase or the test run\n     |      phase, but during the test teardown phase a fixture's value may not\n     |      be available.\n     |      \n     |      :param argname:\n     |          The fixture name.\n     |      :raises pytest.FixtureLookupError:\n     |          If the given fixture could not be found.\n     |  \n     |  raiseerror(self, msg: Optional[str]) -> NoReturn\n     |      Raise a FixtureLookupError exception.\n     |      \n     |      :param msg:\n     |          An optional custom error message.\n     |  \n     |  ----------------------------------------------------------------------\n     |  Readonly properties defined here:\n     |  \n     |  cls\n     |      Class (can be None) where the test function was collected.\n     |  \n     |  config\n     |      The pytest config object associated with this request.\n     |  \n     |  fixturenames\n     |      Names of all active fixtures in this request.\n     |  \n     |  function\n     |      Test function object if the request has a per-function scope.\n     |  \n     |  instance\n     |      Instance (can be None) on which test function was collected.\n     |  \n     |  keywords\n     |      Keywords/markers dictionary for the underlying node.\n     |  \n     |  module\n     |      Python module object where the test function was collected.\n     |  \n     |  node\n     |      Underlying collection node (depends on current request scope).\n     |  \n     |  path\n     |      Path where the test function was collected.\n     |  \n     |  scope\n     |      Scope string, one of \"function\", \"class\", \"module\", \"package\", \"session\".\n     |  \n     |  session\n     |      Pytest session object.\n     |  \n     |  ----------------------------------------------------------------------\n     |  Data descriptors defined here:\n     |  \n     |  __dict__\n     |      dictionary for instance variables (if defined)\n     |  \n     |  __weakref__\n     |      list of weak references to the object (if defined)\n    \n    class Function(PyobjMixin, _pytest.nodes.Item)\n     |  Function(*k, **kw)\n     |  \n     |  An Item responsible for setting up and executing a Python test function.\n     |  \n     |  :param name:\n     |      The full function name, including any decorations like those\n     |      added by parametrization (``my_func[my_param]``).\n     |  :param parent:\n     |      The parent Node.\n     |  :param config:\n     |      The pytest Config object.\n     |  :param callspec:\n     |      If given, this is function has been parametrized and the callspec contains\n     |      meta information about the parametrization.\n     |  :param callobj:\n     |      If given, the object which will be called when the Function is invoked,\n     |      otherwise the callobj will be obtained from ``parent`` using ``originalname``.\n     |  :param keywords:\n     |      Keywords bound to the function object for \"-k\" matching.\n     |  :param session:\n     |      The pytest Session object.\n     |  :param fixtureinfo:\n     |      Fixture information already resolved at this fixture node..\n     |  :param originalname:\n     |      The attribute name to use for accessing the underlying function object.\n     |      Defaults to ``name``. Set this if name is different from the original name,\n     |      for example when it contains decorations like those added by parametrization\n     |      (``my_func[my_param]``).\n     |  \n     |  Method resolution order:\n     |      Function\n     |      PyobjMixin\n     |      _pytest.nodes.Item\n     |      _pytest.nodes.Node\n     |      builtins.object\n     |  \n     |  Methods defined here:\n     |  \n     |  __init__(self, name: str, parent, config: Optional[_pytest.config.Config] = None, callspec: Optional[_pytest.python.CallSpec2] = None, callobj=<NotSetType.token: 0>, keywords: Optional[Mapping[str, Any]] = None, session: Optional[_pytest.main.Session] = None, fixtureinfo: Optional[_pytest.fixtures.FuncFixtureInfo] = None, originalname: Optional[str] = None) -> None\n     |      Initialize self.  See help(type(self)) for accurate signature.\n     |  \n     |  repr_failure(self, excinfo: _pytest._code.code.ExceptionInfo[BaseException]) -> Union[str, _pytest._code.code.TerminalRepr]\n     |      Return a representation of a collection or test failure.\n     |      \n     |      .. seealso:: :ref:`non-python tests`\n     |      \n     |      :param excinfo: Exception information for the failure.\n     |  \n     |  runtest(self) -> None\n     |      Execute the underlying test function.\n     |  \n     |  setup(self) -> None\n     |  \n     |  ----------------------------------------------------------------------\n     |  Class methods defined here:\n     |  \n     |  from_parent(parent, **kw) from _pytest.nodes.NodeMeta\n     |      The public constructor.\n     |  \n     |  ----------------------------------------------------------------------\n     |  Readonly properties defined here:\n     |  \n     |  function\n     |      Underlying python 'function' object.\n     |  \n     |  ----------------------------------------------------------------------\n     |  Methods inherited from PyobjMixin:\n     |  \n     |  getmodpath(self, stopatmodule: bool = True, includemodule: bool = False) -> str\n     |      Return Python path relative to the containing module.\n     |  \n     |  reportinfo(self) -> Tuple[Union[ForwardRef('os.PathLike[str]'), str], Optional[int], str]\n     |  \n     |  ----------------------------------------------------------------------\n     |  Readonly properties inherited from PyobjMixin:\n     |  \n     |  cls\n     |      Python class object this node was collected from (can be None).\n     |  \n     |  instance\n     |      Python instance object the function is bound to.\n     |      \n     |      Returns None if not a test method, e.g. for a standalone test function,\n     |      a staticmethod, a class or a module.\n     |  \n     |  module\n     |      Python module object this node was collected from (can be None).\n     |  \n     |  ----------------------------------------------------------------------\n     |  Data descriptors inherited from PyobjMixin:\n     |  \n     |  __weakref__\n     |      list of weak references to the object (if defined)\n     |  \n     |  obj\n     |      Underlying Python object.\n     |  \n     |  ----------------------------------------------------------------------\n     |  Methods inherited from _pytest.nodes.Item:\n     |  \n     |  add_report_section(self, when: str, key: str, content: str) -> None\n     |      Add a new report section, similar to what's done internally to add\n     |      stdout and stderr captured output::\n     |      \n     |          item.add_report_section(\"call\", \"stdout\", \"report section contents\")\n     |      \n     |      :param str when:\n     |          One of the possible capture states, ``\"setup\"``, ``\"call\"``, ``\"teardown\"``.\n     |      :param str key:\n     |          Name of the section, can be customized at will. Pytest uses ``\"stdout\"`` and\n     |          ``\"stderr\"`` internally.\n     |      :param str content:\n     |          The full contents as a string.\n     |  \n     |  location = <functools.cached_property object>\n     |      Returns a tuple of ``(relfspath, lineno, testname)`` for this item\n     |      where ``relfspath`` is file path relative to ``config.rootpath``\n     |      and lineno is a 0-based line number.\n     |  \n     |  ----------------------------------------------------------------------\n     |  Data and other attributes inherited from _pytest.nodes.Item:\n     |  \n     |  nextitem = None\n     |  \n     |  ----------------------------------------------------------------------\n     |  Methods inherited from _pytest.nodes.Node:\n     |  \n     |  __hash__(self) -> int\n     |      Return hash(self).\n     |  \n     |  __repr__(self) -> str\n     |      Return repr(self).\n     |  \n     |  add_marker(self, marker: Union[str, _pytest.mark.structures.MarkDecorator], append: bool = True) -> None\n     |      Dynamically add a marker object to the node.\n     |      \n     |      :param marker:\n     |          The marker.\n     |      :param append:\n     |          Whether to append the marker, or prepend it.\n     |  \n     |  addfinalizer(self, fin: Callable[[], object]) -> None\n     |      Register a function to be called without arguments when this node is\n     |      finalized.\n     |      \n     |      This method can only be called when this node is active\n     |      in a setup chain, for example during self.setup().\n     |  \n     |  get_closest_marker(self, name: str, default: Optional[_pytest.mark.structures.Mark] = None) -> Optional[_pytest.mark.structures.Mark]\n     |      Return the first marker matching the name, from closest (for\n     |      example function) to farther level (for example module level).\n     |      \n     |      :param default: Fallback return value if no marker was found.\n     |      :param name: Name to filter by.\n     |  \n     |  getparent(self, cls: Type[~_NodeType]) -> Optional[~_NodeType]\n     |      Get the next parent node (including self) which is an instance of\n     |      the given class.\n     |      \n     |      :param cls: The node class to search for.\n     |      :returns: The node, if found.\n     |  \n     |  iter_markers(self, name: Optional[str] = None) -> Iterator[_pytest.mark.structures.Mark]\n     |      Iterate over all markers of the node.\n     |      \n     |      :param name: If given, filter the results by the name attribute.\n     |      :returns: An iterator of the markers of the node.\n     |  \n     |  iter_markers_with_node(self, name: Optional[str] = None) -> Iterator[Tuple[ForwardRef('Node'), _pytest.mark.structures.Mark]]\n     |      Iterate over all markers of the node.\n     |      \n     |      :param name: If given, filter the results by the name attribute.\n     |      :returns: An iterator of (node, mark) tuples.\n     |  \n     |  listchain(self) -> List[ForwardRef('Node')]\n     |      Return list of all parent collectors up to self, starting from\n     |      the root of collection tree.\n     |      \n     |      :returns: The nodes.\n     |  \n     |  listextrakeywords(self) -> Set[str]\n     |      Return a set of all extra keywords in self and any parents.\n     |  \n     |  listnames(self) -> List[str]\n     |  \n     |  teardown(self) -> None\n     |  \n     |  warn(self, warning: Warning) -> None\n     |      Issue a warning for this Node.\n     |      \n     |      Warnings will be displayed after the test session, unless explicitly suppressed.\n     |      \n     |      :param Warning warning:\n     |          The warning instance to issue.\n     |      \n     |      :raises ValueError: If ``warning`` instance is not a subclass of Warning.\n     |      \n     |      Example usage:\n     |      \n     |      .. code-block:: python\n     |      \n     |          node.warn(PytestWarning(\"some message\"))\n     |          node.warn(UserWarning(\"some message\"))\n     |      \n     |      .. versionchanged:: 6.2\n     |          Any subclass of :class:`Warning` is now accepted, rather than only\n     |          :class:`PytestWarning <pytest.PytestWarning>` subclasses.\n     |  \n     |  ----------------------------------------------------------------------\n     |  Readonly properties inherited from _pytest.nodes.Node:\n     |  \n     |  ihook\n     |      fspath-sensitive hook proxy used to call pytest hooks.\n     |  \n     |  nodeid\n     |      A ::-separated string denoting its collection tree address.\n     |  \n     |  ----------------------------------------------------------------------\n     |  Data descriptors inherited from _pytest.nodes.Node:\n     |  \n     |  __dict__\n     |      dictionary for instance variables (if defined)\n     |  \n     |  config\n     |  \n     |  name\n     |  \n     |  parent\n     |  \n     |  path\n     |  \n     |  session\n     |  \n     |  ----------------------------------------------------------------------\n     |  Data and other attributes inherited from _pytest.nodes.Node:\n     |  \n     |  __annotations__ = {'fspath': <class '_pytest._py.path.LocalPath'>}\n    \n    class HookRecorder(builtins.object)\n     |  HookRecorder(pluginmanager: _pytest.config.PytestPluginManager, *, _ispytest: bool = False) -> None\n     |  \n     |  Record all hooks called in a plugin manager.\n     |  \n     |  Hook recorders are created by :class:`Pytester`.\n     |  \n     |  This wraps all the hook calls in the plugin manager, recording each call\n     |  before propagating the normal calls.\n     |  \n     |  Methods defined here:\n     |  \n     |  __init__(self, pluginmanager: _pytest.config.PytestPluginManager, *, _ispytest: bool = False) -> None\n     |      Initialize self.  See help(type(self)) for accurate signature.\n     |  \n     |  assert_contains(self, entries: Sequence[Tuple[str, str]]) -> None\n     |  \n     |  assertoutcome(self, passed: int = 0, skipped: int = 0, failed: int = 0) -> None\n     |  \n     |  clear(self) -> None\n     |  \n     |  countoutcomes(self) -> List[int]\n     |  \n     |  finish_recording(self) -> None\n     |  \n     |  getcall(self, name: str) -> _pytest.pytester.RecordedHookCall\n     |  \n     |  getcalls(self, names: Union[str, Iterable[str]]) -> List[_pytest.pytester.RecordedHookCall]\n     |      Get all recorded calls to hooks with the given names (or name).\n     |  \n     |  getfailedcollections(self) -> Sequence[_pytest.reports.CollectReport]\n     |  \n     |  getfailures(self, names: Union[str, Iterable[str]] = ('pytest_collectreport', 'pytest_runtest_logreport')) -> Sequence[Union[_pytest.reports.CollectReport, _pytest.reports.TestReport]]\n     |  \n     |  getreports(self, names: Union[str, Iterable[str]] = ('pytest_collectreport', 'pytest_runtest_logreport')) -> Sequence[Union[_pytest.reports.CollectReport, _pytest.reports.TestReport]]\n     |  \n     |  listoutcomes(self) -> Tuple[Sequence[_pytest.reports.TestReport], Sequence[Union[_pytest.reports.CollectReport, _pytest.reports.TestReport]], Sequence[Union[_pytest.reports.CollectReport, _pytest.reports.TestReport]]]\n     |  \n     |  matchreport(self, inamepart: str = '', names: Union[str, Iterable[str]] = ('pytest_runtest_logreport', 'pytest_collectreport'), when: Optional[str] = None) -> Union[_pytest.reports.CollectReport, _pytest.reports.TestReport]\n     |      Return a testreport whose dotted import path matches.\n     |  \n     |  popcall(self, name: str) -> _pytest.pytester.RecordedHookCall\n     |  \n     |  ----------------------------------------------------------------------\n     |  Data descriptors defined here:\n     |  \n     |  __dict__\n     |      dictionary for instance variables (if defined)\n     |  \n     |  __weakref__\n     |      list of weak references to the object (if defined)\n    \n    class Item(Node)\n     |  Item(*k, **kw)\n     |  \n     |  A basic test invocation item.\n     |  \n     |  Note that for a single function there might be multiple test invocation items.\n     |  \n     |  Method resolution order:\n     |      Item\n     |      Node\n     |      builtins.object\n     |  \n     |  Methods defined here:\n     |  \n     |  __init__(self, name, parent=None, config: Optional[_pytest.config.Config] = None, session: Optional[ForwardRef('Session')] = None, nodeid: Optional[str] = None, **kw) -> None\n     |      Initialize self.  See help(type(self)) for accurate signature.\n     |  \n     |  add_report_section(self, when: str, key: str, content: str) -> None\n     |      Add a new report section, similar to what's done internally to add\n     |      stdout and stderr captured output::\n     |      \n     |          item.add_report_section(\"call\", \"stdout\", \"report section contents\")\n     |      \n     |      :param str when:\n     |          One of the possible capture states, ``\"setup\"``, ``\"call\"``, ``\"teardown\"``.\n     |      :param str key:\n     |          Name of the section, can be customized at will. Pytest uses ``\"stdout\"`` and\n     |          ``\"stderr\"`` internally.\n     |      :param str content:\n     |          The full contents as a string.\n     |  \n     |  location = <functools.cached_property object>\n     |      Returns a tuple of ``(relfspath, lineno, testname)`` for this item\n     |      where ``relfspath`` is file path relative to ``config.rootpath``\n     |      and lineno is a 0-based line number.\n     |  \n     |  reportinfo(self) -> Tuple[Union[ForwardRef('os.PathLike[str]'), str], Optional[int], str]\n     |      Get location information for this item for test reports.\n     |      \n     |      Returns a tuple with three elements:\n     |      \n     |      - The path of the test (default ``self.path``)\n     |      - The 0-based line number of the test (default ``None``)\n     |      - A name of the test to be shown (default ``\"\"``)\n     |      \n     |      .. seealso:: :ref:`non-python tests`\n     |  \n     |  runtest(self) -> None\n     |      Run the test case for this item.\n     |      \n     |      Must be implemented by subclasses.\n     |      \n     |      .. seealso:: :ref:`non-python tests`\n     |  \n     |  ----------------------------------------------------------------------\n     |  Data descriptors defined here:\n     |  \n     |  __weakref__\n     |      list of weak references to the object (if defined)\n     |  \n     |  ----------------------------------------------------------------------\n     |  Data and other attributes defined here:\n     |  \n     |  nextitem = None\n     |  \n     |  ----------------------------------------------------------------------\n     |  Methods inherited from Node:\n     |  \n     |  __hash__(self) -> int\n     |      Return hash(self).\n     |  \n     |  __repr__(self) -> str\n     |      Return repr(self).\n     |  \n     |  add_marker(self, marker: Union[str, _pytest.mark.structures.MarkDecorator], append: bool = True) -> None\n     |      Dynamically add a marker object to the node.\n     |      \n     |      :param marker:\n     |          The marker.\n     |      :param append:\n     |          Whether to append the marker, or prepend it.\n     |  \n     |  addfinalizer(self, fin: Callable[[], object]) -> None\n     |      Register a function to be called without arguments when this node is\n     |      finalized.\n     |      \n     |      This method can only be called when this node is active\n     |      in a setup chain, for example during self.setup().\n     |  \n     |  get_closest_marker(self, name: str, default: Optional[_pytest.mark.structures.Mark] = None) -> Optional[_pytest.mark.structures.Mark]\n     |      Return the first marker matching the name, from closest (for\n     |      example function) to farther level (for example module level).\n     |      \n     |      :param default: Fallback return value if no marker was found.\n     |      :param name: Name to filter by.\n     |  \n     |  getparent(self, cls: Type[~_NodeType]) -> Optional[~_NodeType]\n     |      Get the next parent node (including self) which is an instance of\n     |      the given class.\n     |      \n     |      :param cls: The node class to search for.\n     |      :returns: The node, if found.\n     |  \n     |  iter_markers(self, name: Optional[str] = None) -> Iterator[_pytest.mark.structures.Mark]\n     |      Iterate over all markers of the node.\n     |      \n     |      :param name: If given, filter the results by the name attribute.\n     |      :returns: An iterator of the markers of the node.\n     |  \n     |  iter_markers_with_node(self, name: Optional[str] = None) -> Iterator[Tuple[ForwardRef('Node'), _pytest.mark.structures.Mark]]\n     |      Iterate over all markers of the node.\n     |      \n     |      :param name: If given, filter the results by the name attribute.\n     |      :returns: An iterator of (node, mark) tuples.\n     |  \n     |  listchain(self) -> List[ForwardRef('Node')]\n     |      Return list of all parent collectors up to self, starting from\n     |      the root of collection tree.\n     |      \n     |      :returns: The nodes.\n     |  \n     |  listextrakeywords(self) -> Set[str]\n     |      Return a set of all extra keywords in self and any parents.\n     |  \n     |  listnames(self) -> List[str]\n     |  \n     |  repr_failure(self, excinfo: _pytest._code.code.ExceptionInfo[BaseException], style: 'Optional[_TracebackStyle]' = None) -> Union[str, _pytest._code.code.TerminalRepr]\n     |      Return a representation of a collection or test failure.\n     |      \n     |      .. seealso:: :ref:`non-python tests`\n     |      \n     |      :param excinfo: Exception information for the failure.\n     |  \n     |  setup(self) -> None\n     |  \n     |  teardown(self) -> None\n     |  \n     |  warn(self, warning: Warning) -> None\n     |      Issue a warning for this Node.\n     |      \n     |      Warnings will be displayed after the test session, unless explicitly suppressed.\n     |      \n     |      :param Warning warning:\n     |          The warning instance to issue.\n     |      \n     |      :raises ValueError: If ``warning`` instance is not a subclass of Warning.\n     |      \n     |      Example usage:\n     |      \n     |      .. code-block:: python\n     |      \n     |          node.warn(PytestWarning(\"some message\"))\n     |          node.warn(UserWarning(\"some message\"))\n     |      \n     |      .. versionchanged:: 6.2\n     |          Any subclass of :class:`Warning` is now accepted, rather than only\n     |          :class:`PytestWarning <pytest.PytestWarning>` subclasses.\n     |  \n     |  ----------------------------------------------------------------------\n     |  Class methods inherited from Node:\n     |  \n     |  from_parent(parent: 'Node', **kw) from _pytest.nodes.NodeMeta\n     |      Public constructor for Nodes.\n     |      \n     |      This indirection got introduced in order to enable removing\n     |      the fragile logic from the node constructors.\n     |      \n     |      Subclasses can use ``super().from_parent(...)`` when overriding the\n     |      construction.\n     |      \n     |      :param parent: The parent node of this Node.\n     |  \n     |  ----------------------------------------------------------------------\n     |  Readonly properties inherited from Node:\n     |  \n     |  ihook\n     |      fspath-sensitive hook proxy used to call pytest hooks.\n     |  \n     |  nodeid\n     |      A ::-separated string denoting its collection tree address.\n     |  \n     |  ----------------------------------------------------------------------\n     |  Data descriptors inherited from Node:\n     |  \n     |  __dict__\n     |      dictionary for instance variables (if defined)\n     |  \n     |  config\n     |  \n     |  name\n     |  \n     |  parent\n     |  \n     |  path\n     |  \n     |  session\n     |  \n     |  ----------------------------------------------------------------------\n     |  Data and other attributes inherited from Node:\n     |  \n     |  __annotations__ = {'fspath': <class '_pytest._py.path.LocalPath'>}\n    \n    class LineMatcher(builtins.object)\n     |  LineMatcher(lines: List[str]) -> None\n     |  \n     |  Flexible matching of text.\n     |  \n     |  This is a convenience class to test large texts like the output of\n     |  commands.\n     |  \n     |  The constructor takes a list of lines without their trailing newlines, i.e.\n     |  ``text.splitlines()``.\n     |  \n     |  Methods defined here:\n     |  \n     |  __init__(self, lines: List[str]) -> None\n     |      Initialize self.  See help(type(self)) for accurate signature.\n     |  \n     |  __str__(self) -> str\n     |      Return the entire original text.\n     |      \n     |      .. versionadded:: 6.2\n     |          You can use :meth:`str` in older versions.\n     |  \n     |  fnmatch_lines(self, lines2: Sequence[str], *, consecutive: bool = False) -> None\n     |      Check lines exist in the output (using :func:`python:fnmatch.fnmatch`).\n     |      \n     |      The argument is a list of lines which have to match and can use glob\n     |      wildcards.  If they do not match a pytest.fail() is called.  The\n     |      matches and non-matches are also shown as part of the error message.\n     |      \n     |      :param lines2: String patterns to match.\n     |      :param consecutive: Match lines consecutively?\n     |  \n     |  fnmatch_lines_random(self, lines2: Sequence[str]) -> None\n     |      Check lines exist in the output in any order (using :func:`python:fnmatch.fnmatch`).\n     |  \n     |  get_lines_after(self, fnline: str) -> Sequence[str]\n     |      Return all lines following the given line in the text.\n     |      \n     |      The given line can contain glob wildcards.\n     |  \n     |  no_fnmatch_line(self, pat: str) -> None\n     |      Ensure captured lines do not match the given pattern, using ``fnmatch.fnmatch``.\n     |      \n     |      :param str pat: The pattern to match lines.\n     |  \n     |  no_re_match_line(self, pat: str) -> None\n     |      Ensure captured lines do not match the given pattern, using ``re.match``.\n     |      \n     |      :param str pat: The regular expression to match lines.\n     |  \n     |  re_match_lines(self, lines2: Sequence[str], *, consecutive: bool = False) -> None\n     |      Check lines exist in the output (using :func:`python:re.match`).\n     |      \n     |      The argument is a list of lines which have to match using ``re.match``.\n     |      If they do not match a pytest.fail() is called.\n     |      \n     |      The matches and non-matches are also shown as part of the error message.\n     |      \n     |      :param lines2: string patterns to match.\n     |      :param consecutive: match lines consecutively?\n     |  \n     |  re_match_lines_random(self, lines2: Sequence[str]) -> None\n     |      Check lines exist in the output in any order (using :func:`python:re.match`).\n     |  \n     |  str(self) -> str\n     |      Return the entire original text.\n     |  \n     |  ----------------------------------------------------------------------\n     |  Data descriptors defined here:\n     |  \n     |  __dict__\n     |      dictionary for instance variables (if defined)\n     |  \n     |  __weakref__\n     |      list of weak references to the object (if defined)\n    \n    class LogCaptureFixture(builtins.object)\n     |  LogCaptureFixture(item: _pytest.nodes.Node, *, _ispytest: bool = False) -> None\n     |  \n     |  Provides access and control of log capturing.\n     |  \n     |  Methods defined here:\n     |  \n     |  __init__(self, item: _pytest.nodes.Node, *, _ispytest: bool = False) -> None\n     |      Initialize self.  See help(type(self)) for accurate signature.\n     |  \n     |  at_level(self, level: Union[int, str], logger: Optional[str] = None) -> Generator[NoneType, NoneType, NoneType]\n     |      Context manager that sets the level for capturing of logs. After\n     |      the end of the 'with' statement the level is restored to its original\n     |      value.\n     |      \n     |      Will enable the requested logging level if it was disabled via :meth:`logging.disable`.\n     |      \n     |      :param level: The level.\n     |      :param logger: The logger to update. If not given, the root logger.\n     |  \n     |  clear(self) -> None\n     |      Reset the list of log records and the captured log text.\n     |  \n     |  get_records(self, when: \"Literal['setup', 'call', 'teardown']\") -> List[logging.LogRecord]\n     |      Get the logging records for one of the possible test phases.\n     |      \n     |      :param when:\n     |          Which test phase to obtain the records from.\n     |          Valid values are: \"setup\", \"call\" and \"teardown\".\n     |      \n     |      :returns: The list of captured records at the given stage.\n     |      \n     |      .. versionadded:: 3.4\n     |  \n     |  set_level(self, level: Union[int, str], logger: Optional[str] = None) -> None\n     |      Set the threshold level of a logger for the duration of a test.\n     |      \n     |      Logging messages which are less severe than this level will not be captured.\n     |      \n     |      .. versionchanged:: 3.4\n     |          The levels of the loggers changed by this function will be\n     |          restored to their initial values at the end of the test.\n     |      \n     |      Will enable the requested logging level if it was disabled via :meth:`logging.disable`.\n     |      \n     |      :param level: The level.\n     |      :param logger: The logger to update. If not given, the root logger.\n     |  \n     |  ----------------------------------------------------------------------\n     |  Readonly properties defined here:\n     |  \n     |  handler\n     |      Get the logging handler used by the fixture.\n     |  \n     |  messages\n     |      A list of format-interpolated log messages.\n     |      \n     |      Unlike 'records', which contains the format string and parameters for\n     |      interpolation, log messages in this list are all interpolated.\n     |      \n     |      Unlike 'text', which contains the output from the handler, log\n     |      messages in this list are unadorned with levels, timestamps, etc,\n     |      making exact comparisons more reliable.\n     |      \n     |      Note that traceback or stack info (from :func:`logging.exception` or\n     |      the `exc_info` or `stack_info` arguments to the logging functions) is\n     |      not included, as this is added by the formatter in the handler.\n     |      \n     |      .. versionadded:: 3.7\n     |  \n     |  record_tuples\n     |      A list of a stripped down version of log records intended\n     |      for use in assertion comparison.\n     |      \n     |      The format of the tuple is:\n     |      \n     |          (logger_name, log_level, message)\n     |  \n     |  records\n     |      The list of log records.\n     |  \n     |  text\n     |      The formatted log text.\n     |  \n     |  ----------------------------------------------------------------------\n     |  Data descriptors defined here:\n     |  \n     |  __dict__\n     |      dictionary for instance variables (if defined)\n     |  \n     |  __weakref__\n     |      list of weak references to the object (if defined)\n    \n    class Mark(builtins.object)\n     |  Mark(name: str, args: Tuple[Any, ...], kwargs: Mapping[str, Any], param_ids_from: Optional[ForwardRef('Mark')] = None, param_ids_generated: Optional[Sequence[str]] = None, *, _ispytest: bool = False) -> None\n     |  \n     |  A pytest mark.\n     |  \n     |  Methods defined here:\n     |  \n     |  __delattr__(self, name)\n     |  \n     |  __eq__(self, other)\n     |  \n     |  __hash__(self)\n     |  \n     |  __init__(self, name: str, args: Tuple[Any, ...], kwargs: Mapping[str, Any], param_ids_from: Optional[ForwardRef('Mark')] = None, param_ids_generated: Optional[Sequence[str]] = None, *, _ispytest: bool = False) -> None\n     |      :meta private:\n     |  \n     |  __repr__(self)\n     |  \n     |  __setattr__(self, name, value)\n     |  \n     |  combined_with(self, other: 'Mark') -> 'Mark'\n     |      Return a new Mark which is a combination of this\n     |      Mark and another Mark.\n     |      \n     |      Combines by appending args and merging kwargs.\n     |      \n     |      :param Mark other: The mark to combine with.\n     |      :rtype: Mark\n     |  \n     |  ----------------------------------------------------------------------\n     |  Data descriptors defined here:\n     |  \n     |  __dict__\n     |      dictionary for instance variables (if defined)\n     |  \n     |  __weakref__\n     |      list of weak references to the object (if defined)\n     |  \n     |  ----------------------------------------------------------------------\n     |  Data and other attributes defined here:\n     |  \n     |  __annotations__ = {'_param_ids_from': typing.Optional[ForwardRef('Mark...\n     |  \n     |  __dataclass_fields__ = {'_param_ids_from': Field(name='_param_ids_from...\n     |  \n     |  __dataclass_params__ = _DataclassParams(init=True,repr=True,eq=True,or...\n    \n    class MarkDecorator(builtins.object)\n     |  MarkDecorator(mark: _pytest.mark.structures.Mark, *, _ispytest: bool = False) -> None\n     |  \n     |  A decorator for applying a mark on test functions and classes.\n     |  \n     |  ``MarkDecorators`` are created with ``pytest.mark``::\n     |  \n     |      mark1 = pytest.mark.NAME              # Simple MarkDecorator\n     |      mark2 = pytest.mark.NAME(name1=value) # Parametrized MarkDecorator\n     |  \n     |  and can then be applied as decorators to test functions::\n     |  \n     |      @mark2\n     |      def test_function():\n     |          pass\n     |  \n     |  When a ``MarkDecorator`` is called, it does the following:\n     |  \n     |  1. If called with a single class as its only positional argument and no\n     |     additional keyword arguments, it attaches the mark to the class so it\n     |     gets applied automatically to all test cases found in that class.\n     |  \n     |  2. If called with a single function as its only positional argument and\n     |     no additional keyword arguments, it attaches the mark to the function,\n     |     containing all the arguments already stored internally in the\n     |     ``MarkDecorator``.\n     |  \n     |  3. When called in any other case, it returns a new ``MarkDecorator``\n     |     instance with the original ``MarkDecorator``'s content updated with\n     |     the arguments passed to this call.\n     |  \n     |  Note: The rules above prevent a ``MarkDecorator`` from storing only a\n     |  single function or class reference as its positional argument with no\n     |  additional keyword or positional arguments. You can work around this by\n     |  using `with_args()`.\n     |  \n     |  Methods defined here:\n     |  \n     |  __call__(self, *args: object, **kwargs: object)\n     |      Call the MarkDecorator.\n     |  \n     |  __eq__(self, other)\n     |  \n     |  __init__(self, mark: _pytest.mark.structures.Mark, *, _ispytest: bool = False) -> None\n     |      :meta private:\n     |  \n     |  __repr__(self)\n     |  \n     |  with_args(self, *args: object, **kwargs: object) -> 'MarkDecorator'\n     |      Return a MarkDecorator with extra arguments added.\n     |      \n     |      Unlike calling the MarkDecorator, with_args() can be used even\n     |      if the sole argument is a callable/class.\n     |  \n     |  ----------------------------------------------------------------------\n     |  Readonly properties defined here:\n     |  \n     |  args\n     |      Alias for mark.args.\n     |  \n     |  kwargs\n     |      Alias for mark.kwargs.\n     |  \n     |  markname\n     |      :meta private:\n     |  \n     |  name\n     |      Alias for mark.name.\n     |  \n     |  ----------------------------------------------------------------------\n     |  Data descriptors defined here:\n     |  \n     |  __dict__\n     |      dictionary for instance variables (if defined)\n     |  \n     |  __weakref__\n     |      list of weak references to the object (if defined)\n     |  \n     |  ----------------------------------------------------------------------\n     |  Data and other attributes defined here:\n     |  \n     |  __annotations__ = {'mark': <class '_pytest.mark.structures.Mark'>}\n     |  \n     |  __dataclass_fields__ = {'mark': Field(name='mark',type=<class '_pytest...\n     |  \n     |  __dataclass_params__ = _DataclassParams(init=True,repr=True,eq=True,or...\n     |  \n     |  __hash__ = None\n    \n    class MarkGenerator(builtins.object)\n     |  MarkGenerator(*, _ispytest: bool = False) -> None\n     |  \n     |  Factory for :class:`MarkDecorator` objects - exposed as\n     |  a ``pytest.mark`` singleton instance.\n     |  \n     |  Example::\n     |  \n     |       import pytest\n     |  \n     |       @pytest.mark.slowtest\n     |       def test_function():\n     |          pass\n     |  \n     |  applies a 'slowtest' :class:`Mark` on ``test_function``.\n     |  \n     |  Methods defined here:\n     |  \n     |  __getattr__(self, name: str) -> _pytest.mark.structures.MarkDecorator\n     |      Generate a new :class:`MarkDecorator` with the given name.\n     |  \n     |  __init__(self, *, _ispytest: bool = False) -> None\n     |      Initialize self.  See help(type(self)) for accurate signature.\n     |  \n     |  ----------------------------------------------------------------------\n     |  Data descriptors defined here:\n     |  \n     |  __dict__\n     |      dictionary for instance variables (if defined)\n     |  \n     |  __weakref__\n     |      list of weak references to the object (if defined)\n     |  \n     |  ----------------------------------------------------------------------\n     |  Data and other attributes defined here:\n     |  \n     |  __annotations__ = {}\n    \n    class Metafunc(builtins.object)\n     |  Metafunc(definition: 'FunctionDefinition', fixtureinfo: _pytest.fixtures.FuncFixtureInfo, config: _pytest.config.Config, cls=None, module=None, *, _ispytest: bool = False) -> None\n     |  \n     |  Objects passed to the :hook:`pytest_generate_tests` hook.\n     |  \n     |  They help to inspect a test function and to generate tests according to\n     |  test configuration or values specified in the class or module where a\n     |  test function is defined.\n     |  \n     |  Methods defined here:\n     |  \n     |  __init__(self, definition: 'FunctionDefinition', fixtureinfo: _pytest.fixtures.FuncFixtureInfo, config: _pytest.config.Config, cls=None, module=None, *, _ispytest: bool = False) -> None\n     |      Initialize self.  See help(type(self)) for accurate signature.\n     |  \n     |  parametrize(self, argnames: Union[str, Sequence[str]], argvalues: Iterable[Union[_pytest.mark.structures.ParameterSet, Sequence[object], object]], indirect: Union[bool, Sequence[str]] = False, ids: Union[Iterable[Optional[object]], Callable[[Any], Optional[object]], NoneType] = None, scope: 'Optional[_ScopeName]' = None, *, _param_mark: Optional[_pytest.mark.structures.Mark] = None) -> None\n     |      Add new invocations to the underlying test function using the list\n     |      of argvalues for the given argnames. Parametrization is performed\n     |      during the collection phase. If you need to setup expensive resources\n     |      see about setting indirect to do it rather than at test setup time.\n     |      \n     |      Can be called multiple times, in which case each call parametrizes all\n     |      previous parametrizations, e.g.\n     |      \n     |      ::\n     |      \n     |          unparametrized:         t\n     |          parametrize [\"x\", \"y\"]: t[x], t[y]\n     |          parametrize [1, 2]:     t[x-1], t[x-2], t[y-1], t[y-2]\n     |      \n     |      :param argnames:\n     |          A comma-separated string denoting one or more argument names, or\n     |          a list/tuple of argument strings.\n     |      \n     |      :param argvalues:\n     |          The list of argvalues determines how often a test is invoked with\n     |          different argument values.\n     |      \n     |          If only one argname was specified argvalues is a list of values.\n     |          If N argnames were specified, argvalues must be a list of\n     |          N-tuples, where each tuple-element specifies a value for its\n     |          respective argname.\n     |      \n     |      :param indirect:\n     |          A list of arguments' names (subset of argnames) or a boolean.\n     |          If True the list contains all names from the argnames. Each\n     |          argvalue corresponding to an argname in this list will\n     |          be passed as request.param to its respective argname fixture\n     |          function so that it can perform more expensive setups during the\n     |          setup phase of a test rather than at collection time.\n     |      \n     |      :param ids:\n     |          Sequence of (or generator for) ids for ``argvalues``,\n     |          or a callable to return part of the id for each argvalue.\n     |      \n     |          With sequences (and generators like ``itertools.count()``) the\n     |          returned ids should be of type ``string``, ``int``, ``float``,\n     |          ``bool``, or ``None``.\n     |          They are mapped to the corresponding index in ``argvalues``.\n     |          ``None`` means to use the auto-generated id.\n     |      \n     |          If it is a callable it will be called for each entry in\n     |          ``argvalues``, and the return value is used as part of the\n     |          auto-generated id for the whole set (where parts are joined with\n     |          dashes (\"-\")).\n     |          This is useful to provide more specific ids for certain items, e.g.\n     |          dates.  Returning ``None`` will use an auto-generated id.\n     |      \n     |          If no ids are provided they will be generated automatically from\n     |          the argvalues.\n     |      \n     |      :param scope:\n     |          If specified it denotes the scope of the parameters.\n     |          The scope is used for grouping tests by parameter instances.\n     |          It will also override any fixture-function defined scope, allowing\n     |          to set a dynamic scope using test context or configuration.\n     |  \n     |  ----------------------------------------------------------------------\n     |  Data descriptors defined here:\n     |  \n     |  __dict__\n     |      dictionary for instance variables (if defined)\n     |  \n     |  __weakref__\n     |      list of weak references to the object (if defined)\n    \n    class Module(_pytest.nodes.File, PyCollector)\n     |  Module(*k, **kw)\n     |  \n     |  Collector for test classes and functions.\n     |  \n     |  Method resolution order:\n     |      Module\n     |      _pytest.nodes.File\n     |      _pytest.nodes.FSCollector\n     |      PyCollector\n     |      PyobjMixin\n     |      _pytest.nodes.Collector\n     |      _pytest.nodes.Node\n     |      builtins.object\n     |  \n     |  Methods defined here:\n     |  \n     |  collect(self) -> Iterable[Union[_pytest.nodes.Item, _pytest.nodes.Collector]]\n     |      Return a list of children (items and collectors) for this\n     |      collection node.\n     |  \n     |  ----------------------------------------------------------------------\n     |  Methods inherited from _pytest.nodes.FSCollector:\n     |  \n     |  __init__(self, fspath: Optional[_pytest._py.path.LocalPath] = None, path_or_parent: Union[pathlib.Path, _pytest.nodes.Node, NoneType] = None, path: Optional[pathlib.Path] = None, name: Optional[str] = None, parent: Optional[_pytest.nodes.Node] = None, config: Optional[_pytest.config.Config] = None, session: Optional[ForwardRef('Session')] = None, nodeid: Optional[str] = None) -> None\n     |      Initialize self.  See help(type(self)) for accurate signature.\n     |  \n     |  gethookproxy(self, fspath: 'os.PathLike[str]')\n     |  \n     |  isinitpath(self, path: Union[str, ForwardRef('os.PathLike[str]')]) -> bool\n     |  \n     |  ----------------------------------------------------------------------\n     |  Class methods inherited from _pytest.nodes.FSCollector:\n     |  \n     |  from_parent(parent, *, fspath: Optional[_pytest._py.path.LocalPath] = None, path: Optional[pathlib.Path] = None, **kw) from _pytest.nodes.NodeMeta\n     |      The public constructor.\n     |  \n     |  ----------------------------------------------------------------------\n     |  Methods inherited from PyCollector:\n     |  \n     |  classnamefilter(self, name: str) -> bool\n     |  \n     |  funcnamefilter(self, name: str) -> bool\n     |  \n     |  isnosetest(self, obj: object) -> bool\n     |      Look for the __test__ attribute, which is applied by the\n     |      @nose.tools.istest decorator.\n     |  \n     |  istestclass(self, obj: object, name: str) -> bool\n     |  \n     |  istestfunction(self, obj: object, name: str) -> bool\n     |  \n     |  ----------------------------------------------------------------------\n     |  Methods inherited from PyobjMixin:\n     |  \n     |  getmodpath(self, stopatmodule: bool = True, includemodule: bool = False) -> str\n     |      Return Python path relative to the containing module.\n     |  \n     |  reportinfo(self) -> Tuple[Union[ForwardRef('os.PathLike[str]'), str], Optional[int], str]\n     |  \n     |  ----------------------------------------------------------------------\n     |  Readonly properties inherited from PyobjMixin:\n     |  \n     |  cls\n     |      Python class object this node was collected from (can be None).\n     |  \n     |  instance\n     |      Python instance object the function is bound to.\n     |      \n     |      Returns None if not a test method, e.g. for a standalone test function,\n     |      a staticmethod, a class or a module.\n     |  \n     |  module\n     |      Python module object this node was collected from (can be None).\n     |  \n     |  ----------------------------------------------------------------------\n     |  Data descriptors inherited from PyobjMixin:\n     |  \n     |  __weakref__\n     |      list of weak references to the object (if defined)\n     |  \n     |  obj\n     |      Underlying Python object.\n     |  \n     |  ----------------------------------------------------------------------\n     |  Methods inherited from _pytest.nodes.Collector:\n     |  \n     |  repr_failure(self, excinfo: _pytest._code.code.ExceptionInfo[BaseException]) -> Union[str, _pytest._code.code.TerminalRepr]\n     |      Return a representation of a collection failure.\n     |      \n     |      :param excinfo: Exception information for the failure.\n     |  \n     |  ----------------------------------------------------------------------\n     |  Data and other attributes inherited from _pytest.nodes.Collector:\n     |  \n     |  CollectError = <class '_pytest.nodes.Collector.CollectError'>\n     |      An error during collection, contains a custom message.\n     |  \n     |  \n     |  ----------------------------------------------------------------------\n     |  Methods inherited from _pytest.nodes.Node:\n     |  \n     |  __hash__(self) -> int\n     |      Return hash(self).\n     |  \n     |  __repr__(self) -> str\n     |      Return repr(self).\n     |  \n     |  add_marker(self, marker: Union[str, _pytest.mark.structures.MarkDecorator], append: bool = True) -> None\n     |      Dynamically add a marker object to the node.\n     |      \n     |      :param marker:\n     |          The marker.\n     |      :param append:\n     |          Whether to append the marker, or prepend it.\n     |  \n     |  addfinalizer(self, fin: Callable[[], object]) -> None\n     |      Register a function to be called without arguments when this node is\n     |      finalized.\n     |      \n     |      This method can only be called when this node is active\n     |      in a setup chain, for example during self.setup().\n     |  \n     |  get_closest_marker(self, name: str, default: Optional[_pytest.mark.structures.Mark] = None) -> Optional[_pytest.mark.structures.Mark]\n     |      Return the first marker matching the name, from closest (for\n     |      example function) to farther level (for example module level).\n     |      \n     |      :param default: Fallback return value if no marker was found.\n     |      :param name: Name to filter by.\n     |  \n     |  getparent(self, cls: Type[~_NodeType]) -> Optional[~_NodeType]\n     |      Get the next parent node (including self) which is an instance of\n     |      the given class.\n     |      \n     |      :param cls: The node class to search for.\n     |      :returns: The node, if found.\n     |  \n     |  iter_markers(self, name: Optional[str] = None) -> Iterator[_pytest.mark.structures.Mark]\n     |      Iterate over all markers of the node.\n     |      \n     |      :param name: If given, filter the results by the name attribute.\n     |      :returns: An iterator of the markers of the node.\n     |  \n     |  iter_markers_with_node(self, name: Optional[str] = None) -> Iterator[Tuple[ForwardRef('Node'), _pytest.mark.structures.Mark]]\n     |      Iterate over all markers of the node.\n     |      \n     |      :param name: If given, filter the results by the name attribute.\n     |      :returns: An iterator of (node, mark) tuples.\n     |  \n     |  listchain(self) -> List[ForwardRef('Node')]\n     |      Return list of all parent collectors up to self, starting from\n     |      the root of collection tree.\n     |      \n     |      :returns: The nodes.\n     |  \n     |  listextrakeywords(self) -> Set[str]\n     |      Return a set of all extra keywords in self and any parents.\n     |  \n     |  listnames(self) -> List[str]\n     |  \n     |  setup(self) -> None\n     |  \n     |  teardown(self) -> None\n     |  \n     |  warn(self, warning: Warning) -> None\n     |      Issue a warning for this Node.\n     |      \n     |      Warnings will be displayed after the test session, unless explicitly suppressed.\n     |      \n     |      :param Warning warning:\n     |          The warning instance to issue.\n     |      \n     |      :raises ValueError: If ``warning`` instance is not a subclass of Warning.\n     |      \n     |      Example usage:\n     |      \n     |      .. code-block:: python\n     |      \n     |          node.warn(PytestWarning(\"some message\"))\n     |          node.warn(UserWarning(\"some message\"))\n     |      \n     |      .. versionchanged:: 6.2\n     |          Any subclass of :class:`Warning` is now accepted, rather than only\n     |          :class:`PytestWarning <pytest.PytestWarning>` subclasses.\n     |  \n     |  ----------------------------------------------------------------------\n     |  Readonly properties inherited from _pytest.nodes.Node:\n     |  \n     |  ihook\n     |      fspath-sensitive hook proxy used to call pytest hooks.\n     |  \n     |  nodeid\n     |      A ::-separated string denoting its collection tree address.\n     |  \n     |  ----------------------------------------------------------------------\n     |  Data descriptors inherited from _pytest.nodes.Node:\n     |  \n     |  __dict__\n     |      dictionary for instance variables (if defined)\n     |  \n     |  config\n     |  \n     |  name\n     |  \n     |  parent\n     |  \n     |  path\n     |  \n     |  session\n     |  \n     |  ----------------------------------------------------------------------\n     |  Data and other attributes inherited from _pytest.nodes.Node:\n     |  \n     |  __annotations__ = {'fspath': <class '_pytest._py.path.LocalPath'>}\n    \n    class MonkeyPatch(builtins.object)\n     |  MonkeyPatch() -> None\n     |  \n     |  Helper to conveniently monkeypatch attributes/items/environment\n     |  variables/syspath.\n     |  \n     |  Returned by the :fixture:`monkeypatch` fixture.\n     |  \n     |  .. versionchanged:: 6.2\n     |      Can now also be used directly as `pytest.MonkeyPatch()`, for when\n     |      the fixture is not available. In this case, use\n     |      :meth:`with MonkeyPatch.context() as mp: <context>` or remember to call\n     |      :meth:`undo` explicitly.\n     |  \n     |  Methods defined here:\n     |  \n     |  __init__(self) -> None\n     |      Initialize self.  See help(type(self)) for accurate signature.\n     |  \n     |  chdir(self, path: Union[str, ForwardRef('os.PathLike[str]')]) -> None\n     |      Change the current working directory to the specified path.\n     |      \n     |      :param path:\n     |          The path to change into.\n     |  \n     |  delattr(self, target: Union[object, str], name: Union[str, _pytest.monkeypatch.Notset] = <notset>, raising: bool = True) -> None\n     |      Delete attribute ``name`` from ``target``.\n     |      \n     |      If no ``name`` is specified and ``target`` is a string\n     |      it will be interpreted as a dotted import path with the\n     |      last part being the attribute name.\n     |      \n     |      Raises AttributeError it the attribute does not exist, unless\n     |      ``raising`` is set to False.\n     |  \n     |  delenv(self, name: str, raising: bool = True) -> None\n     |      Delete ``name`` from the environment.\n     |      \n     |      Raises ``KeyError`` if it does not exist, unless ``raising`` is set to\n     |      False.\n     |  \n     |  delitem(self, dic: Mapping[~K, ~V], name: ~K, raising: bool = True) -> None\n     |      Delete ``name`` from dict.\n     |      \n     |      Raises ``KeyError`` if it doesn't exist, unless ``raising`` is set to\n     |      False.\n     |  \n     |  setattr(self, target: Union[str, object], name: Union[object, str], value: object = <notset>, raising: bool = True) -> None\n     |      Set attribute value on target, memorizing the old value.\n     |      \n     |      For example:\n     |      \n     |      .. code-block:: python\n     |      \n     |          import os\n     |      \n     |          monkeypatch.setattr(os, \"getcwd\", lambda: \"/\")\n     |      \n     |      The code above replaces the :func:`os.getcwd` function by a ``lambda`` which\n     |      always returns ``\"/\"``.\n     |      \n     |      For convenience, you can specify a string as ``target`` which\n     |      will be interpreted as a dotted import path, with the last part\n     |      being the attribute name:\n     |      \n     |      .. code-block:: python\n     |      \n     |          monkeypatch.setattr(\"os.getcwd\", lambda: \"/\")\n     |      \n     |      Raises :class:`AttributeError` if the attribute does not exist, unless\n     |      ``raising`` is set to False.\n     |      \n     |      **Where to patch**\n     |      \n     |      ``monkeypatch.setattr`` works by (temporarily) changing the object that a name points to with another one.\n     |      There can be many names pointing to any individual object, so for patching to work you must ensure\n     |      that you patch the name used by the system under test.\n     |      \n     |      See the section :ref:`Where to patch <python:where-to-patch>` in the :mod:`unittest.mock`\n     |      docs for a complete explanation, which is meant for :func:`unittest.mock.patch` but\n     |      applies to ``monkeypatch.setattr`` as well.\n     |  \n     |  setenv(self, name: str, value: str, prepend: Optional[str] = None) -> None\n     |      Set environment variable ``name`` to ``value``.\n     |      \n     |      If ``prepend`` is a character, read the current environment variable\n     |      value and prepend the ``value`` adjoined with the ``prepend``\n     |      character.\n     |  \n     |  setitem(self, dic: Mapping[~K, ~V], name: ~K, value: ~V) -> None\n     |      Set dictionary entry ``name`` to value.\n     |  \n     |  syspath_prepend(self, path) -> None\n     |      Prepend ``path`` to ``sys.path`` list of import locations.\n     |  \n     |  undo(self) -> None\n     |      Undo previous changes.\n     |      \n     |      This call consumes the undo stack. Calling it a second time has no\n     |      effect unless you do more monkeypatching after the undo call.\n     |      \n     |      There is generally no need to call `undo()`, since it is\n     |      called automatically during tear-down.\n     |      \n     |      .. note::\n     |          The same `monkeypatch` fixture is used across a\n     |          single test function invocation. If `monkeypatch` is used both by\n     |          the test function itself and one of the test fixtures,\n     |          calling `undo()` will undo all of the changes made in\n     |          both functions.\n     |      \n     |          Prefer to use :meth:`context() <pytest.MonkeyPatch.context>` instead.\n     |  \n     |  ----------------------------------------------------------------------\n     |  Class methods defined here:\n     |  \n     |  context() -> Generator[ForwardRef('MonkeyPatch'), NoneType, NoneType] from builtins.type\n     |      Context manager that returns a new :class:`MonkeyPatch` object\n     |      which undoes any patching done inside the ``with`` block upon exit.\n     |      \n     |      Example:\n     |      \n     |      .. code-block:: python\n     |      \n     |          import functools\n     |      \n     |      \n     |          def test_partial(monkeypatch):\n     |              with monkeypatch.context() as m:\n     |                  m.setattr(functools, \"partial\", 3)\n     |      \n     |      Useful in situations where it is desired to undo some patches before the test ends,\n     |      such as mocking ``stdlib`` functions that might break pytest itself if mocked (for examples\n     |      of this see :issue:`3290`).\n     |  \n     |  ----------------------------------------------------------------------\n     |  Data descriptors defined here:\n     |  \n     |  __dict__\n     |      dictionary for instance variables (if defined)\n     |  \n     |  __weakref__\n     |      list of weak references to the object (if defined)\n    \n    class OptionGroup(builtins.object)\n     |  OptionGroup(name: str, description: str = '', parser: Optional[_pytest.config.argparsing.Parser] = None, *, _ispytest: bool = False) -> None\n     |  \n     |  A group of options shown in its own section.\n     |  \n     |  Methods defined here:\n     |  \n     |  __init__(self, name: str, description: str = '', parser: Optional[_pytest.config.argparsing.Parser] = None, *, _ispytest: bool = False) -> None\n     |      Initialize self.  See help(type(self)) for accurate signature.\n     |  \n     |  addoption(self, *opts: str, **attrs: Any) -> None\n     |      Add an option to this group.\n     |      \n     |      If a shortened version of a long option is specified, it will\n     |      be suppressed in the help. ``addoption('--twowords', '--two-words')``\n     |      results in help showing ``--two-words`` only, but ``--twowords`` gets\n     |      accepted **and** the automatic destination is in ``args.twowords``.\n     |      \n     |      :param opts:\n     |          Option names, can be short or long options.\n     |      :param attrs:\n     |          Same attributes as the argparse library's :py:func:`add_argument()\n     |          <argparse.ArgumentParser.add_argument>` function accepts.\n     |  \n     |  ----------------------------------------------------------------------\n     |  Data descriptors defined here:\n     |  \n     |  __dict__\n     |      dictionary for instance variables (if defined)\n     |  \n     |  __weakref__\n     |      list of weak references to the object (if defined)\n    \n    class Package(Module)\n     |  Package(*k, **kw)\n     |  \n     |  Method resolution order:\n     |      Package\n     |      Module\n     |      _pytest.nodes.File\n     |      _pytest.nodes.FSCollector\n     |      PyCollector\n     |      PyobjMixin\n     |      _pytest.nodes.Collector\n     |      _pytest.nodes.Node\n     |      builtins.object\n     |  \n     |  Methods defined here:\n     |  \n     |  __init__(self, fspath: Optional[_pytest._py.path.LocalPath], parent: _pytest.nodes.Collector, config=None, session=None, nodeid=None, path: Optional[pathlib.Path] = None) -> None\n     |      Initialize self.  See help(type(self)) for accurate signature.\n     |  \n     |  collect(self) -> Iterable[Union[_pytest.nodes.Item, _pytest.nodes.Collector]]\n     |      Return a list of children (items and collectors) for this\n     |      collection node.\n     |  \n     |  setup(self) -> None\n     |  \n     |  ----------------------------------------------------------------------\n     |  Methods inherited from _pytest.nodes.FSCollector:\n     |  \n     |  gethookproxy(self, fspath: 'os.PathLike[str]')\n     |  \n     |  isinitpath(self, path: Union[str, ForwardRef('os.PathLike[str]')]) -> bool\n     |  \n     |  ----------------------------------------------------------------------\n     |  Class methods inherited from _pytest.nodes.FSCollector:\n     |  \n     |  from_parent(parent, *, fspath: Optional[_pytest._py.path.LocalPath] = None, path: Optional[pathlib.Path] = None, **kw) from _pytest.nodes.NodeMeta\n     |      The public constructor.\n     |  \n     |  ----------------------------------------------------------------------\n     |  Methods inherited from PyCollector:\n     |  \n     |  classnamefilter(self, name: str) -> bool\n     |  \n     |  funcnamefilter(self, name: str) -> bool\n     |  \n     |  isnosetest(self, obj: object) -> bool\n     |      Look for the __test__ attribute, which is applied by the\n     |      @nose.tools.istest decorator.\n     |  \n     |  istestclass(self, obj: object, name: str) -> bool\n     |  \n     |  istestfunction(self, obj: object, name: str) -> bool\n     |  \n     |  ----------------------------------------------------------------------\n     |  Methods inherited from PyobjMixin:\n     |  \n     |  getmodpath(self, stopatmodule: bool = True, includemodule: bool = False) -> str\n     |      Return Python path relative to the containing module.\n     |  \n     |  reportinfo(self) -> Tuple[Union[ForwardRef('os.PathLike[str]'), str], Optional[int], str]\n     |  \n     |  ----------------------------------------------------------------------\n     |  Readonly properties inherited from PyobjMixin:\n     |  \n     |  cls\n     |      Python class object this node was collected from (can be None).\n     |  \n     |  instance\n     |      Python instance object the function is bound to.\n     |      \n     |      Returns None if not a test method, e.g. for a standalone test function,\n     |      a staticmethod, a class or a module.\n     |  \n     |  module\n     |      Python module object this node was collected from (can be None).\n     |  \n     |  ----------------------------------------------------------------------\n     |  Data descriptors inherited from PyobjMixin:\n     |  \n     |  __weakref__\n     |      list of weak references to the object (if defined)\n     |  \n     |  obj\n     |      Underlying Python object.\n     |  \n     |  ----------------------------------------------------------------------\n     |  Methods inherited from _pytest.nodes.Collector:\n     |  \n     |  repr_failure(self, excinfo: _pytest._code.code.ExceptionInfo[BaseException]) -> Union[str, _pytest._code.code.TerminalRepr]\n     |      Return a representation of a collection failure.\n     |      \n     |      :param excinfo: Exception information for the failure.\n     |  \n     |  ----------------------------------------------------------------------\n     |  Data and other attributes inherited from _pytest.nodes.Collector:\n     |  \n     |  CollectError = <class '_pytest.nodes.Collector.CollectError'>\n     |      An error during collection, contains a custom message.\n     |  \n     |  \n     |  ----------------------------------------------------------------------\n     |  Methods inherited from _pytest.nodes.Node:\n     |  \n     |  __hash__(self) -> int\n     |      Return hash(self).\n     |  \n     |  __repr__(self) -> str\n     |      Return repr(self).\n     |  \n     |  add_marker(self, marker: Union[str, _pytest.mark.structures.MarkDecorator], append: bool = True) -> None\n     |      Dynamically add a marker object to the node.\n     |      \n     |      :param marker:\n     |          The marker.\n     |      :param append:\n     |          Whether to append the marker, or prepend it.\n     |  \n     |  addfinalizer(self, fin: Callable[[], object]) -> None\n     |      Register a function to be called without arguments when this node is\n     |      finalized.\n     |      \n     |      This method can only be called when this node is active\n     |      in a setup chain, for example during self.setup().\n     |  \n     |  get_closest_marker(self, name: str, default: Optional[_pytest.mark.structures.Mark] = None) -> Optional[_pytest.mark.structures.Mark]\n     |      Return the first marker matching the name, from closest (for\n     |      example function) to farther level (for example module level).\n     |      \n     |      :param default: Fallback return value if no marker was found.\n     |      :param name: Name to filter by.\n     |  \n     |  getparent(self, cls: Type[~_NodeType]) -> Optional[~_NodeType]\n     |      Get the next parent node (including self) which is an instance of\n     |      the given class.\n     |      \n     |      :param cls: The node class to search for.\n     |      :returns: The node, if found.\n     |  \n     |  iter_markers(self, name: Optional[str] = None) -> Iterator[_pytest.mark.structures.Mark]\n     |      Iterate over all markers of the node.\n     |      \n     |      :param name: If given, filter the results by the name attribute.\n     |      :returns: An iterator of the markers of the node.\n     |  \n     |  iter_markers_with_node(self, name: Optional[str] = None) -> Iterator[Tuple[ForwardRef('Node'), _pytest.mark.structures.Mark]]\n     |      Iterate over all markers of the node.\n     |      \n     |      :param name: If given, filter the results by the name attribute.\n     |      :returns: An iterator of (node, mark) tuples.\n     |  \n     |  listchain(self) -> List[ForwardRef('Node')]\n     |      Return list of all parent collectors up to self, starting from\n     |      the root of collection tree.\n     |      \n     |      :returns: The nodes.\n     |  \n     |  listextrakeywords(self) -> Set[str]\n     |      Return a set of all extra keywords in self and any parents.\n     |  \n     |  listnames(self) -> List[str]\n     |  \n     |  teardown(self) -> None\n     |  \n     |  warn(self, warning: Warning) -> None\n     |      Issue a warning for this Node.\n     |      \n     |      Warnings will be displayed after the test session, unless explicitly suppressed.\n     |      \n     |      :param Warning warning:\n     |          The warning instance to issue.\n     |      \n     |      :raises ValueError: If ``warning`` instance is not a subclass of Warning.\n     |      \n     |      Example usage:\n     |      \n     |      .. code-block:: python\n     |      \n     |          node.warn(PytestWarning(\"some message\"))\n     |          node.warn(UserWarning(\"some message\"))\n     |      \n     |      .. versionchanged:: 6.2\n     |          Any subclass of :class:`Warning` is now accepted, rather than only\n     |          :class:`PytestWarning <pytest.PytestWarning>` subclasses.\n     |  \n     |  ----------------------------------------------------------------------\n     |  Readonly properties inherited from _pytest.nodes.Node:\n     |  \n     |  ihook\n     |      fspath-sensitive hook proxy used to call pytest hooks.\n     |  \n     |  nodeid\n     |      A ::-separated string denoting its collection tree address.\n     |  \n     |  ----------------------------------------------------------------------\n     |  Data descriptors inherited from _pytest.nodes.Node:\n     |  \n     |  __dict__\n     |      dictionary for instance variables (if defined)\n     |  \n     |  config\n     |  \n     |  name\n     |  \n     |  parent\n     |  \n     |  path\n     |  \n     |  session\n     |  \n     |  ----------------------------------------------------------------------\n     |  Data and other attributes inherited from _pytest.nodes.Node:\n     |  \n     |  __annotations__ = {'fspath': <class '_pytest._py.path.LocalPath'>}\n    \n    class Parser(builtins.object)\n     |  Parser(usage: Optional[str] = None, processopt: Optional[Callable[[ForwardRef('Argument')], NoneType]] = None, *, _ispytest: bool = False) -> None\n     |  \n     |  Parser for command line arguments and ini-file values.\n     |  \n     |  :ivar extra_info: Dict of generic param -> value to display in case\n     |      there's an error processing the command line arguments.\n     |  \n     |  Methods defined here:\n     |  \n     |  __init__(self, usage: Optional[str] = None, processopt: Optional[Callable[[ForwardRef('Argument')], NoneType]] = None, *, _ispytest: bool = False) -> None\n     |      Initialize self.  See help(type(self)) for accurate signature.\n     |  \n     |  addini(self, name: str, help: str, type: Optional[ForwardRef(\"Literal['string', 'paths', 'pathlist', 'args', 'linelist', 'bool']\")] = None, default: Any = None) -> None\n     |      Register an ini-file option.\n     |      \n     |      :param name:\n     |          Name of the ini-variable.\n     |      :param type:\n     |          Type of the variable. Can be:\n     |      \n     |              * ``string``: a string\n     |              * ``bool``: a boolean\n     |              * ``args``: a list of strings, separated as in a shell\n     |              * ``linelist``: a list of strings, separated by line breaks\n     |              * ``paths``: a list of :class:`pathlib.Path`, separated as in a shell\n     |              * ``pathlist``: a list of ``py.path``, separated as in a shell\n     |      \n     |          .. versionadded:: 7.0\n     |              The ``paths`` variable type.\n     |      \n     |          Defaults to ``string`` if ``None`` or not passed.\n     |      :param default:\n     |          Default value if no ini-file option exists but is queried.\n     |      \n     |      The value of ini-variables can be retrieved via a call to\n     |      :py:func:`config.getini(name) <pytest.Config.getini>`.\n     |  \n     |  addoption(self, *opts: str, **attrs: Any) -> None\n     |      Register a command line option.\n     |      \n     |      :param opts:\n     |          Option names, can be short or long options.\n     |      :param attrs:\n     |          Same attributes as the argparse library's :py:func:`add_argument()\n     |          <argparse.ArgumentParser.add_argument>` function accepts.\n     |      \n     |      After command line parsing, options are available on the pytest config\n     |      object via ``config.option.NAME`` where ``NAME`` is usually set\n     |      by passing a ``dest`` attribute, for example\n     |      ``addoption(\"--long\", dest=\"NAME\", ...)``.\n     |  \n     |  getgroup(self, name: str, description: str = '', after: Optional[str] = None) -> 'OptionGroup'\n     |      Get (or create) a named option Group.\n     |      \n     |      :param name: Name of the option group.\n     |      :param description: Long description for --help output.\n     |      :param after: Name of another group, used for ordering --help output.\n     |      :returns: The option group.\n     |      \n     |      The returned group object has an ``addoption`` method with the same\n     |      signature as :func:`parser.addoption <pytest.Parser.addoption>` but\n     |      will be shown in the respective group in the output of\n     |      ``pytest --help``.\n     |  \n     |  parse(self, args: Sequence[Union[str, ForwardRef('os.PathLike[str]')]], namespace: Optional[argparse.Namespace] = None) -> argparse.Namespace\n     |  \n     |  parse_known_and_unknown_args(self, args: Sequence[Union[str, ForwardRef('os.PathLike[str]')]], namespace: Optional[argparse.Namespace] = None) -> Tuple[argparse.Namespace, List[str]]\n     |      Parse the known arguments at this point, and also return the\n     |      remaining unknown arguments.\n     |      \n     |      :returns:\n     |          A tuple containing an argparse namespace object for the known\n     |          arguments, and a list of the unknown arguments.\n     |  \n     |  parse_known_args(self, args: Sequence[Union[str, ForwardRef('os.PathLike[str]')]], namespace: Optional[argparse.Namespace] = None) -> argparse.Namespace\n     |      Parse the known arguments at this point.\n     |      \n     |      :returns: An argparse namespace object.\n     |  \n     |  parse_setoption(self, args: Sequence[Union[str, ForwardRef('os.PathLike[str]')]], option: argparse.Namespace, namespace: Optional[argparse.Namespace] = None) -> List[str]\n     |  \n     |  processoption(self, option: 'Argument') -> None\n     |  \n     |  ----------------------------------------------------------------------\n     |  Data descriptors defined here:\n     |  \n     |  __dict__\n     |      dictionary for instance variables (if defined)\n     |  \n     |  __weakref__\n     |      list of weak references to the object (if defined)\n     |  \n     |  ----------------------------------------------------------------------\n     |  Data and other attributes defined here:\n     |  \n     |  __annotations__ = {'prog': typing.Optional[str]}\n     |  \n     |  prog = None\n    \n    class PytestAssertRewriteWarning(PytestWarning)\n     |  Warning emitted by the pytest assert rewrite module.\n     |  \n     |  Method resolution order:\n     |      PytestAssertRewriteWarning\n     |      PytestWarning\n     |      builtins.UserWarning\n     |      builtins.Warning\n     |      builtins.Exception\n     |      builtins.BaseException\n     |      builtins.object\n     |  \n     |  Data descriptors inherited from PytestWarning:\n     |  \n     |  __weakref__\n     |      list of weak references to the object (if defined)\n     |  \n     |  ----------------------------------------------------------------------\n     |  Methods inherited from builtins.UserWarning:\n     |  \n     |  __init__(self, /, *args, **kwargs)\n     |      Initialize self.  See help(type(self)) for accurate signature.\n     |  \n     |  ----------------------------------------------------------------------\n     |  Static methods inherited from builtins.UserWarning:\n     |  \n     |  __new__(*args, **kwargs) from builtins.type\n     |      Create and return a new object.  See help(type) for accurate signature.\n     |  \n     |  ----------------------------------------------------------------------\n     |  Methods inherited from builtins.BaseException:\n     |  \n     |  __delattr__(self, name, /)\n     |      Implement delattr(self, name).\n     |  \n     |  __getattribute__(self, name, /)\n     |      Return getattr(self, name).\n     |  \n     |  __reduce__(...)\n     |      Helper for pickle.\n     |  \n     |  __repr__(self, /)\n     |      Return repr(self).\n     |  \n     |  __setattr__(self, name, value, /)\n     |      Implement setattr(self, name, value).\n     |  \n     |  __setstate__(...)\n     |  \n     |  __str__(self, /)\n     |      Return str(self).\n     |  \n     |  with_traceback(...)\n     |      Exception.with_traceback(tb) --\n     |      set self.__traceback__ to tb and return self.\n     |  \n     |  ----------------------------------------------------------------------\n     |  Data descriptors inherited from builtins.BaseException:\n     |  \n     |  __cause__\n     |      exception cause\n     |  \n     |  __context__\n     |      exception context\n     |  \n     |  __dict__\n     |  \n     |  __suppress_context__\n     |  \n     |  __traceback__\n     |  \n     |  args\n    \n    class PytestCacheWarning(PytestWarning)\n     |  Warning emitted by the cache plugin in various situations.\n     |  \n     |  Method resolution order:\n     |      PytestCacheWarning\n     |      PytestWarning\n     |      builtins.UserWarning\n     |      builtins.Warning\n     |      builtins.Exception\n     |      builtins.BaseException\n     |      builtins.object\n     |  \n     |  Data descriptors inherited from PytestWarning:\n     |  \n     |  __weakref__\n     |      list of weak references to the object (if defined)\n     |  \n     |  ----------------------------------------------------------------------\n     |  Methods inherited from builtins.UserWarning:\n     |  \n     |  __init__(self, /, *args, **kwargs)\n     |      Initialize self.  See help(type(self)) for accurate signature.\n     |  \n     |  ----------------------------------------------------------------------\n     |  Static methods inherited from builtins.UserWarning:\n     |  \n     |  __new__(*args, **kwargs) from builtins.type\n     |      Create and return a new object.  See help(type) for accurate signature.\n     |  \n     |  ----------------------------------------------------------------------\n     |  Methods inherited from builtins.BaseException:\n     |  \n     |  __delattr__(self, name, /)\n     |      Implement delattr(self, name).\n     |  \n     |  __getattribute__(self, name, /)\n     |      Return getattr(self, name).\n     |  \n     |  __reduce__(...)\n     |      Helper for pickle.\n     |  \n     |  __repr__(self, /)\n     |      Return repr(self).\n     |  \n     |  __setattr__(self, name, value, /)\n     |      Implement setattr(self, name, value).\n     |  \n     |  __setstate__(...)\n     |  \n     |  __str__(self, /)\n     |      Return str(self).\n     |  \n     |  with_traceback(...)\n     |      Exception.with_traceback(tb) --\n     |      set self.__traceback__ to tb and return self.\n     |  \n     |  ----------------------------------------------------------------------\n     |  Data descriptors inherited from builtins.BaseException:\n     |  \n     |  __cause__\n     |      exception cause\n     |  \n     |  __context__\n     |      exception context\n     |  \n     |  __dict__\n     |  \n     |  __suppress_context__\n     |  \n     |  __traceback__\n     |  \n     |  args\n    \n    class PytestCollectionWarning(PytestWarning)\n     |  Warning emitted when pytest is not able to collect a file or symbol in a module.\n     |  \n     |  Method resolution order:\n     |      PytestCollectionWarning\n     |      PytestWarning\n     |      builtins.UserWarning\n     |      builtins.Warning\n     |      builtins.Exception\n     |      builtins.BaseException\n     |      builtins.object\n     |  \n     |  Data descriptors inherited from PytestWarning:\n     |  \n     |  __weakref__\n     |      list of weak references to the object (if defined)\n     |  \n     |  ----------------------------------------------------------------------\n     |  Methods inherited from builtins.UserWarning:\n     |  \n     |  __init__(self, /, *args, **kwargs)\n     |      Initialize self.  See help(type(self)) for accurate signature.\n     |  \n     |  ----------------------------------------------------------------------\n     |  Static methods inherited from builtins.UserWarning:\n     |  \n     |  __new__(*args, **kwargs) from builtins.type\n     |      Create and return a new object.  See help(type) for accurate signature.\n     |  \n     |  ----------------------------------------------------------------------\n     |  Methods inherited from builtins.BaseException:\n     |  \n     |  __delattr__(self, name, /)\n     |      Implement delattr(self, name).\n     |  \n     |  __getattribute__(self, name, /)\n     |      Return getattr(self, name).\n     |  \n     |  __reduce__(...)\n     |      Helper for pickle.\n     |  \n     |  __repr__(self, /)\n     |      Return repr(self).\n     |  \n     |  __setattr__(self, name, value, /)\n     |      Implement setattr(self, name, value).\n     |  \n     |  __setstate__(...)\n     |  \n     |  __str__(self, /)\n     |      Return str(self).\n     |  \n     |  with_traceback(...)\n     |      Exception.with_traceback(tb) --\n     |      set self.__traceback__ to tb and return self.\n     |  \n     |  ----------------------------------------------------------------------\n     |  Data descriptors inherited from builtins.BaseException:\n     |  \n     |  __cause__\n     |      exception cause\n     |  \n     |  __context__\n     |      exception context\n     |  \n     |  __dict__\n     |  \n     |  __suppress_context__\n     |  \n     |  __traceback__\n     |  \n     |  args\n    \n    class PytestConfigWarning(PytestWarning)\n     |  Warning emitted for configuration issues.\n     |  \n     |  Method resolution order:\n     |      PytestConfigWarning\n     |      PytestWarning\n     |      builtins.UserWarning\n     |      builtins.Warning\n     |      builtins.Exception\n     |      builtins.BaseException\n     |      builtins.object\n     |  \n     |  Data descriptors inherited from PytestWarning:\n     |  \n     |  __weakref__\n     |      list of weak references to the object (if defined)\n     |  \n     |  ----------------------------------------------------------------------\n     |  Methods inherited from builtins.UserWarning:\n     |  \n     |  __init__(self, /, *args, **kwargs)\n     |      Initialize self.  See help(type(self)) for accurate signature.\n     |  \n     |  ----------------------------------------------------------------------\n     |  Static methods inherited from builtins.UserWarning:\n     |  \n     |  __new__(*args, **kwargs) from builtins.type\n     |      Create and return a new object.  See help(type) for accurate signature.\n     |  \n     |  ----------------------------------------------------------------------\n     |  Methods inherited from builtins.BaseException:\n     |  \n     |  __delattr__(self, name, /)\n     |      Implement delattr(self, name).\n     |  \n     |  __getattribute__(self, name, /)\n     |      Return getattr(self, name).\n     |  \n     |  __reduce__(...)\n     |      Helper for pickle.\n     |  \n     |  __repr__(self, /)\n     |      Return repr(self).\n     |  \n     |  __setattr__(self, name, value, /)\n     |      Implement setattr(self, name, value).\n     |  \n     |  __setstate__(...)\n     |  \n     |  __str__(self, /)\n     |      Return str(self).\n     |  \n     |  with_traceback(...)\n     |      Exception.with_traceback(tb) --\n     |      set self.__traceback__ to tb and return self.\n     |  \n     |  ----------------------------------------------------------------------\n     |  Data descriptors inherited from builtins.BaseException:\n     |  \n     |  __cause__\n     |      exception cause\n     |  \n     |  __context__\n     |      exception context\n     |  \n     |  __dict__\n     |  \n     |  __suppress_context__\n     |  \n     |  __traceback__\n     |  \n     |  args\n    \n    class PytestDeprecationWarning(PytestWarning, builtins.DeprecationWarning)\n     |  Warning class for features that will be removed in a future version.\n     |  \n     |  Method resolution order:\n     |      PytestDeprecationWarning\n     |      PytestWarning\n     |      builtins.UserWarning\n     |      builtins.DeprecationWarning\n     |      builtins.Warning\n     |      builtins.Exception\n     |      builtins.BaseException\n     |      builtins.object\n     |  \n     |  Data descriptors inherited from PytestWarning:\n     |  \n     |  __weakref__\n     |      list of weak references to the object (if defined)\n     |  \n     |  ----------------------------------------------------------------------\n     |  Methods inherited from builtins.UserWarning:\n     |  \n     |  __init__(self, /, *args, **kwargs)\n     |      Initialize self.  See help(type(self)) for accurate signature.\n     |  \n     |  ----------------------------------------------------------------------\n     |  Static methods inherited from builtins.UserWarning:\n     |  \n     |  __new__(*args, **kwargs) from builtins.type\n     |      Create and return a new object.  See help(type) for accurate signature.\n     |  \n     |  ----------------------------------------------------------------------\n     |  Methods inherited from builtins.BaseException:\n     |  \n     |  __delattr__(self, name, /)\n     |      Implement delattr(self, name).\n     |  \n     |  __getattribute__(self, name, /)\n     |      Return getattr(self, name).\n     |  \n     |  __reduce__(...)\n     |      Helper for pickle.\n     |  \n     |  __repr__(self, /)\n     |      Return repr(self).\n     |  \n     |  __setattr__(self, name, value, /)\n     |      Implement setattr(self, name, value).\n     |  \n     |  __setstate__(...)\n     |  \n     |  __str__(self, /)\n     |      Return str(self).\n     |  \n     |  with_traceback(...)\n     |      Exception.with_traceback(tb) --\n     |      set self.__traceback__ to tb and return self.\n     |  \n     |  ----------------------------------------------------------------------\n     |  Data descriptors inherited from builtins.BaseException:\n     |  \n     |  __cause__\n     |      exception cause\n     |  \n     |  __context__\n     |      exception context\n     |  \n     |  __dict__\n     |  \n     |  __suppress_context__\n     |  \n     |  __traceback__\n     |  \n     |  args\n    \n    class PytestExperimentalApiWarning(PytestWarning, builtins.FutureWarning)\n     |  Warning category used to denote experiments in pytest.\n     |  \n     |  Use sparingly as the API might change or even be removed completely in a\n     |  future version.\n     |  \n     |  Method resolution order:\n     |      PytestExperimentalApiWarning\n     |      PytestWarning\n     |      builtins.UserWarning\n     |      builtins.FutureWarning\n     |      builtins.Warning\n     |      builtins.Exception\n     |      builtins.BaseException\n     |      builtins.object\n     |  \n     |  Class methods defined here:\n     |  \n     |  simple(apiname: str) -> 'PytestExperimentalApiWarning' from builtins.type\n     |  \n     |  ----------------------------------------------------------------------\n     |  Data descriptors inherited from PytestWarning:\n     |  \n     |  __weakref__\n     |      list of weak references to the object (if defined)\n     |  \n     |  ----------------------------------------------------------------------\n     |  Methods inherited from builtins.UserWarning:\n     |  \n     |  __init__(self, /, *args, **kwargs)\n     |      Initialize self.  See help(type(self)) for accurate signature.\n     |  \n     |  ----------------------------------------------------------------------\n     |  Static methods inherited from builtins.UserWarning:\n     |  \n     |  __new__(*args, **kwargs) from builtins.type\n     |      Create and return a new object.  See help(type) for accurate signature.\n     |  \n     |  ----------------------------------------------------------------------\n     |  Methods inherited from builtins.BaseException:\n     |  \n     |  __delattr__(self, name, /)\n     |      Implement delattr(self, name).\n     |  \n     |  __getattribute__(self, name, /)\n     |      Return getattr(self, name).\n     |  \n     |  __reduce__(...)\n     |      Helper for pickle.\n     |  \n     |  __repr__(self, /)\n     |      Return repr(self).\n     |  \n     |  __setattr__(self, name, value, /)\n     |      Implement setattr(self, name, value).\n     |  \n     |  __setstate__(...)\n     |  \n     |  __str__(self, /)\n     |      Return str(self).\n     |  \n     |  with_traceback(...)\n     |      Exception.with_traceback(tb) --\n     |      set self.__traceback__ to tb and return self.\n     |  \n     |  ----------------------------------------------------------------------\n     |  Data descriptors inherited from builtins.BaseException:\n     |  \n     |  __cause__\n     |      exception cause\n     |  \n     |  __context__\n     |      exception context\n     |  \n     |  __dict__\n     |  \n     |  __suppress_context__\n     |  \n     |  __traceback__\n     |  \n     |  args\n    \n    class PytestPluginManager(pluggy._manager.PluginManager)\n     |  PytestPluginManager() -> None\n     |  \n     |  A :py:class:`pluggy.PluginManager <pluggy.PluginManager>` with\n     |  additional pytest-specific functionality:\n     |  \n     |  * Loading plugins from the command line, ``PYTEST_PLUGINS`` env variable and\n     |    ``pytest_plugins`` global variables found in plugins being loaded.\n     |  * ``conftest.py`` loading during start-up.\n     |  \n     |  Method resolution order:\n     |      PytestPluginManager\n     |      pluggy._manager.PluginManager\n     |      builtins.object\n     |  \n     |  Methods defined here:\n     |  \n     |  __init__(self) -> None\n     |      Initialize self.  See help(type(self)) for accurate signature.\n     |  \n     |  consider_conftest(self, conftestmodule: module) -> None\n     |      :meta private:\n     |  \n     |  consider_env(self) -> None\n     |      :meta private:\n     |  \n     |  consider_module(self, mod: module) -> None\n     |      :meta private:\n     |  \n     |  consider_pluginarg(self, arg: str) -> None\n     |      :meta private:\n     |  \n     |  consider_preparse(self, args: Sequence[str], *, exclude_only: bool = False) -> None\n     |      :meta private:\n     |  \n     |  getplugin(self, name: str)\n     |  \n     |  hasplugin(self, name: str) -> bool\n     |      Return whether a plugin with the given name is registered.\n     |  \n     |  import_plugin(self, modname: str, consider_entry_points: bool = False) -> None\n     |      Import a plugin with ``modname``.\n     |      \n     |      If ``consider_entry_points`` is True, entry point names are also\n     |      considered to find a plugin.\n     |  \n     |  parse_hookimpl_opts(self, plugin: object, name: str)\n     |      Try to obtain a hook implementation from an item with the given name\n     |      in the given plugin which is being searched for hook impls.\n     |      \n     |      :returns:\n     |          The parsed hookimpl options, or None to skip the given item.\n     |      \n     |      This method can be overridden by ``PluginManager`` subclasses to\n     |      customize how hook implementation are picked up. By default, returns the\n     |      options for items decorated with :class:`HookimplMarker`.\n     |  \n     |  parse_hookspec_opts(self, module_or_class, name: str)\n     |      Try to obtain a hook specification from an item with the given name\n     |      in the given module or class which is being searched for hook specs.\n     |      \n     |      :returns:\n     |          The parsed hookspec options for defining a hook, or None to skip the\n     |          given item.\n     |      \n     |      This method can be overridden by ``PluginManager`` subclasses to\n     |      customize how hook specifications are picked up. By default, returns the\n     |      options for items decorated with :class:`HookspecMarker`.\n     |  \n     |  pytest_configure(self, config: 'Config') -> None\n     |      :meta private:\n     |  \n     |  register(self, plugin: object, name: Optional[str] = None) -> Optional[str]\n     |      Register a plugin and return its name.\n     |      \n     |      :param name:\n     |          The name under which to register the plugin. If not specified, a\n     |          name is generated using :func:`get_canonical_name`.\n     |      \n     |      :returns:\n     |          The plugin name. If the name is blocked from registering, returns\n     |          ``None``.\n     |      \n     |      If the plugin is already registered, raises a :exc:`ValueError`.\n     |  \n     |  ----------------------------------------------------------------------\n     |  Methods inherited from pluggy._manager.PluginManager:\n     |  \n     |  add_hookcall_monitoring(self, before: '_BeforeTrace', after: '_AfterTrace') -> 'Callable[[], None]'\n     |      Add before/after tracing functions for all hooks.\n     |      \n     |      Returns an undo function which, when called, removes the added tracers.\n     |      \n     |      ``before(hook_name, hook_impls, kwargs)`` will be called ahead\n     |      of all hook calls and receive a hookcaller instance, a list\n     |      of HookImpl instances and the keyword arguments for the hook call.\n     |      \n     |      ``after(outcome, hook_name, hook_impls, kwargs)`` receives the\n     |      same arguments as ``before`` but also a :class:`~pluggy.Result` object\n     |      which represents the result of the overall hook call.\n     |  \n     |  add_hookspecs(self, module_or_class: '_Namespace') -> 'None'\n     |      Add new hook specifications defined in the given ``module_or_class``.\n     |      \n     |      Functions are recognized as hook specifications if they have been\n     |      decorated with a matching :class:`HookspecMarker`.\n     |  \n     |  check_pending(self) -> 'None'\n     |      Verify that all hooks which have not been verified against a\n     |      hook specification are optional, otherwise raise\n     |      :exc:`PluginValidationError`.\n     |  \n     |  enable_tracing(self) -> 'Callable[[], None]'\n     |      Enable tracing of hook calls.\n     |      \n     |      Returns an undo function which, when called, removes the added tracing.\n     |  \n     |  get_canonical_name(self, plugin: '_Plugin') -> 'str'\n     |      Return a canonical name for a plugin object.\n     |      \n     |      Note that a plugin may be registered under a different name\n     |      specified by the caller of :meth:`register(plugin, name) <register>`.\n     |      To obtain the name of a registered plugin use :meth:`get_name(plugin)\n     |      <get_name>` instead.\n     |  \n     |  get_hookcallers(self, plugin: '_Plugin') -> 'list[HookCaller] | None'\n     |      Get all hook callers for the specified plugin.\n     |      \n     |      :returns:\n     |          The hook callers, or ``None`` if ``plugin`` is not registered in\n     |          this plugin manager.\n     |  \n     |  get_name(self, plugin: '_Plugin') -> 'str | None'\n     |      Return the name the plugin is registered under, or ``None`` if\n     |      is isn't.\n     |  \n     |  get_plugin(self, name: 'str') -> 'Any | None'\n     |      Return the plugin registered under the given name, if any.\n     |  \n     |  get_plugins(self) -> 'set[Any]'\n     |      Return a set of all registered plugin objects.\n     |  \n     |  has_plugin(self, name: 'str') -> 'bool'\n     |      Return whether a plugin with the given name is registered.\n     |  \n     |  is_blocked(self, name: 'str') -> 'bool'\n     |      Return whether the given plugin name is blocked.\n     |  \n     |  is_registered(self, plugin: '_Plugin') -> 'bool'\n     |      Return whether the plugin is already registered.\n     |  \n     |  list_name_plugin(self) -> 'list[tuple[str, _Plugin]]'\n     |      Return a list of (name, plugin) pairs for all registered plugins.\n     |  \n     |  list_plugin_distinfo(self) -> 'list[tuple[_Plugin, DistFacade]]'\n     |      Return a list of (plugin, distinfo) pairs for all\n     |      setuptools-registered plugins.\n     |  \n     |  load_setuptools_entrypoints(self, group: 'str', name: 'str | None' = None) -> 'int'\n     |      Load modules from querying the specified setuptools ``group``.\n     |      \n     |      :param group:\n     |          Entry point group to load plugins.\n     |      :param name:\n     |          If given, loads only plugins with the given ``name``.\n     |      \n     |      :return:\n     |          The number of plugins loaded by this call.\n     |  \n     |  set_blocked(self, name: 'str') -> 'None'\n     |      Block registrations of the given name, unregister if already registered.\n     |  \n     |  subset_hook_caller(self, name: 'str', remove_plugins: 'Iterable[_Plugin]') -> 'HookCaller'\n     |      Return a proxy :class:`~pluggy.HookCaller` instance for the named\n     |      method which manages calls to all registered plugins except the ones\n     |      from remove_plugins.\n     |  \n     |  unregister(self, plugin: '_Plugin | None' = None, name: 'str | None' = None) -> 'Any | None'\n     |      Unregister a plugin and all of its hook implementations.\n     |      \n     |      The plugin can be specified either by the plugin object or the plugin\n     |      name. If both are specified, they must agree.\n     |      \n     |      Returns the unregistered plugin, or ``None`` if not found.\n     |  \n     |  ----------------------------------------------------------------------\n     |  Data descriptors inherited from pluggy._manager.PluginManager:\n     |  \n     |  __dict__\n     |      dictionary for instance variables (if defined)\n     |  \n     |  __weakref__\n     |      list of weak references to the object (if defined)\n    \n    class PytestRemovedIn8Warning(PytestDeprecationWarning)\n     |  Warning class for features that will be removed in pytest 8.\n     |  \n     |  Method resolution order:\n     |      PytestRemovedIn8Warning\n     |      PytestDeprecationWarning\n     |      PytestWarning\n     |      builtins.UserWarning\n     |      builtins.DeprecationWarning\n     |      builtins.Warning\n     |      builtins.Exception\n     |      builtins.BaseException\n     |      builtins.object\n     |  \n     |  Data descriptors inherited from PytestWarning:\n     |  \n     |  __weakref__\n     |      list of weak references to the object (if defined)\n     |  \n     |  ----------------------------------------------------------------------\n     |  Methods inherited from builtins.UserWarning:\n     |  \n     |  __init__(self, /, *args, **kwargs)\n     |      Initialize self.  See help(type(self)) for accurate signature.\n     |  \n     |  ----------------------------------------------------------------------\n     |  Static methods inherited from builtins.UserWarning:\n     |  \n     |  __new__(*args, **kwargs) from builtins.type\n     |      Create and return a new object.  See help(type) for accurate signature.\n     |  \n     |  ----------------------------------------------------------------------\n     |  Methods inherited from builtins.BaseException:\n     |  \n     |  __delattr__(self, name, /)\n     |      Implement delattr(self, name).\n     |  \n     |  __getattribute__(self, name, /)\n     |      Return getattr(self, name).\n     |  \n     |  __reduce__(...)\n     |      Helper for pickle.\n     |  \n     |  __repr__(self, /)\n     |      Return repr(self).\n     |  \n     |  __setattr__(self, name, value, /)\n     |      Implement setattr(self, name, value).\n     |  \n     |  __setstate__(...)\n     |  \n     |  __str__(self, /)\n     |      Return str(self).\n     |  \n     |  with_traceback(...)\n     |      Exception.with_traceback(tb) --\n     |      set self.__traceback__ to tb and return self.\n     |  \n     |  ----------------------------------------------------------------------\n     |  Data descriptors inherited from builtins.BaseException:\n     |  \n     |  __cause__\n     |      exception cause\n     |  \n     |  __context__\n     |      exception context\n     |  \n     |  __dict__\n     |  \n     |  __suppress_context__\n     |  \n     |  __traceback__\n     |  \n     |  args\n    \n    class PytestRemovedIn9Warning(PytestDeprecationWarning)\n     |  Warning class for features that will be removed in pytest 9.\n     |  \n     |  Method resolution order:\n     |      PytestRemovedIn9Warning\n     |      PytestDeprecationWarning\n     |      PytestWarning\n     |      builtins.UserWarning\n     |      builtins.DeprecationWarning\n     |      builtins.Warning\n     |      builtins.Exception\n     |      builtins.BaseException\n     |      builtins.object\n     |  \n     |  Data descriptors inherited from PytestWarning:\n     |  \n     |  __weakref__\n     |      list of weak references to the object (if defined)\n     |  \n     |  ----------------------------------------------------------------------\n     |  Methods inherited from builtins.UserWarning:\n     |  \n     |  __init__(self, /, *args, **kwargs)\n     |      Initialize self.  See help(type(self)) for accurate signature.\n     |  \n     |  ----------------------------------------------------------------------\n     |  Static methods inherited from builtins.UserWarning:\n     |  \n     |  __new__(*args, **kwargs) from builtins.type\n     |      Create and return a new object.  See help(type) for accurate signature.\n     |  \n     |  ----------------------------------------------------------------------\n     |  Methods inherited from builtins.BaseException:\n     |  \n     |  __delattr__(self, name, /)\n     |      Implement delattr(self, name).\n     |  \n     |  __getattribute__(self, name, /)\n     |      Return getattr(self, name).\n     |  \n     |  __reduce__(...)\n     |      Helper for pickle.\n     |  \n     |  __repr__(self, /)\n     |      Return repr(self).\n     |  \n     |  __setattr__(self, name, value, /)\n     |      Implement setattr(self, name, value).\n     |  \n     |  __setstate__(...)\n     |  \n     |  __str__(self, /)\n     |      Return str(self).\n     |  \n     |  with_traceback(...)\n     |      Exception.with_traceback(tb) --\n     |      set self.__traceback__ to tb and return self.\n     |  \n     |  ----------------------------------------------------------------------\n     |  Data descriptors inherited from builtins.BaseException:\n     |  \n     |  __cause__\n     |      exception cause\n     |  \n     |  __context__\n     |      exception context\n     |  \n     |  __dict__\n     |  \n     |  __suppress_context__\n     |  \n     |  __traceback__\n     |  \n     |  args\n    \n    class PytestReturnNotNoneWarning(PytestRemovedIn8Warning)\n     |  Warning emitted when a test function is returning value other than None.\n     |  \n     |  Method resolution order:\n     |      PytestReturnNotNoneWarning\n     |      PytestRemovedIn8Warning\n     |      PytestDeprecationWarning\n     |      PytestWarning\n     |      builtins.UserWarning\n     |      builtins.DeprecationWarning\n     |      builtins.Warning\n     |      builtins.Exception\n     |      builtins.BaseException\n     |      builtins.object\n     |  \n     |  Data descriptors inherited from PytestWarning:\n     |  \n     |  __weakref__\n     |      list of weak references to the object (if defined)\n     |  \n     |  ----------------------------------------------------------------------\n     |  Methods inherited from builtins.UserWarning:\n     |  \n     |  __init__(self, /, *args, **kwargs)\n     |      Initialize self.  See help(type(self)) for accurate signature.\n     |  \n     |  ----------------------------------------------------------------------\n     |  Static methods inherited from builtins.UserWarning:\n     |  \n     |  __new__(*args, **kwargs) from builtins.type\n     |      Create and return a new object.  See help(type) for accurate signature.\n     |  \n     |  ----------------------------------------------------------------------\n     |  Methods inherited from builtins.BaseException:\n     |  \n     |  __delattr__(self, name, /)\n     |      Implement delattr(self, name).\n     |  \n     |  __getattribute__(self, name, /)\n     |      Return getattr(self, name).\n     |  \n     |  __reduce__(...)\n     |      Helper for pickle.\n     |  \n     |  __repr__(self, /)\n     |      Return repr(self).\n     |  \n     |  __setattr__(self, name, value, /)\n     |      Implement setattr(self, name, value).\n     |  \n     |  __setstate__(...)\n     |  \n     |  __str__(self, /)\n     |      Return str(self).\n     |  \n     |  with_traceback(...)\n     |      Exception.with_traceback(tb) --\n     |      set self.__traceback__ to tb and return self.\n     |  \n     |  ----------------------------------------------------------------------\n     |  Data descriptors inherited from builtins.BaseException:\n     |  \n     |  __cause__\n     |      exception cause\n     |  \n     |  __context__\n     |      exception context\n     |  \n     |  __dict__\n     |  \n     |  __suppress_context__\n     |  \n     |  __traceback__\n     |  \n     |  args\n    \n    class PytestUnhandledCoroutineWarning(PytestReturnNotNoneWarning)\n     |  Warning emitted for an unhandled coroutine.\n     |  \n     |  A coroutine was encountered when collecting test functions, but was not\n     |  handled by any async-aware plugin.\n     |  Coroutine test functions are not natively supported.\n     |  \n     |  Method resolution order:\n     |      PytestUnhandledCoroutineWarning\n     |      PytestReturnNotNoneWarning\n     |      PytestRemovedIn8Warning\n     |      PytestDeprecationWarning\n     |      PytestWarning\n     |      builtins.UserWarning\n     |      builtins.DeprecationWarning\n     |      builtins.Warning\n     |      builtins.Exception\n     |      builtins.BaseException\n     |      builtins.object\n     |  \n     |  Data descriptors inherited from PytestWarning:\n     |  \n     |  __weakref__\n     |      list of weak references to the object (if defined)\n     |  \n     |  ----------------------------------------------------------------------\n     |  Methods inherited from builtins.UserWarning:\n     |  \n     |  __init__(self, /, *args, **kwargs)\n     |      Initialize self.  See help(type(self)) for accurate signature.\n     |  \n     |  ----------------------------------------------------------------------\n     |  Static methods inherited from builtins.UserWarning:\n     |  \n     |  __new__(*args, **kwargs) from builtins.type\n     |      Create and return a new object.  See help(type) for accurate signature.\n     |  \n     |  ----------------------------------------------------------------------\n     |  Methods inherited from builtins.BaseException:\n     |  \n     |  __delattr__(self, name, /)\n     |      Implement delattr(self, name).\n     |  \n     |  __getattribute__(self, name, /)\n     |      Return getattr(self, name).\n     |  \n     |  __reduce__(...)\n     |      Helper for pickle.\n     |  \n     |  __repr__(self, /)\n     |      Return repr(self).\n     |  \n     |  __setattr__(self, name, value, /)\n     |      Implement setattr(self, name, value).\n     |  \n     |  __setstate__(...)\n     |  \n     |  __str__(self, /)\n     |      Return str(self).\n     |  \n     |  with_traceback(...)\n     |      Exception.with_traceback(tb) --\n     |      set self.__traceback__ to tb and return self.\n     |  \n     |  ----------------------------------------------------------------------\n     |  Data descriptors inherited from builtins.BaseException:\n     |  \n     |  __cause__\n     |      exception cause\n     |  \n     |  __context__\n     |      exception context\n     |  \n     |  __dict__\n     |  \n     |  __suppress_context__\n     |  \n     |  __traceback__\n     |  \n     |  args\n    \n    class PytestUnhandledThreadExceptionWarning(PytestWarning)\n     |  An unhandled exception occurred in a :class:`~threading.Thread`.\n     |  \n     |  Such exceptions don't propagate normally.\n     |  \n     |  Method resolution order:\n     |      PytestUnhandledThreadExceptionWarning\n     |      PytestWarning\n     |      builtins.UserWarning\n     |      builtins.Warning\n     |      builtins.Exception\n     |      builtins.BaseException\n     |      builtins.object\n     |  \n     |  Data descriptors inherited from PytestWarning:\n     |  \n     |  __weakref__\n     |      list of weak references to the object (if defined)\n     |  \n     |  ----------------------------------------------------------------------\n     |  Methods inherited from builtins.UserWarning:\n     |  \n     |  __init__(self, /, *args, **kwargs)\n     |      Initialize self.  See help(type(self)) for accurate signature.\n     |  \n     |  ----------------------------------------------------------------------\n     |  Static methods inherited from builtins.UserWarning:\n     |  \n     |  __new__(*args, **kwargs) from builtins.type\n     |      Create and return a new object.  See help(type) for accurate signature.\n     |  \n     |  ----------------------------------------------------------------------\n     |  Methods inherited from builtins.BaseException:\n     |  \n     |  __delattr__(self, name, /)\n     |      Implement delattr(self, name).\n     |  \n     |  __getattribute__(self, name, /)\n     |      Return getattr(self, name).\n     |  \n     |  __reduce__(...)\n     |      Helper for pickle.\n     |  \n     |  __repr__(self, /)\n     |      Return repr(self).\n     |  \n     |  __setattr__(self, name, value, /)\n     |      Implement setattr(self, name, value).\n     |  \n     |  __setstate__(...)\n     |  \n     |  __str__(self, /)\n     |      Return str(self).\n     |  \n     |  with_traceback(...)\n     |      Exception.with_traceback(tb) --\n     |      set self.__traceback__ to tb and return self.\n     |  \n     |  ----------------------------------------------------------------------\n     |  Data descriptors inherited from builtins.BaseException:\n     |  \n     |  __cause__\n     |      exception cause\n     |  \n     |  __context__\n     |      exception context\n     |  \n     |  __dict__\n     |  \n     |  __suppress_context__\n     |  \n     |  __traceback__\n     |  \n     |  args\n    \n    class PytestUnknownMarkWarning(PytestWarning)\n     |  Warning emitted on use of unknown markers.\n     |  \n     |  See :ref:`mark` for details.\n     |  \n     |  Method resolution order:\n     |      PytestUnknownMarkWarning\n     |      PytestWarning\n     |      builtins.UserWarning\n     |      builtins.Warning\n     |      builtins.Exception\n     |      builtins.BaseException\n     |      builtins.object\n     |  \n     |  Data descriptors inherited from PytestWarning:\n     |  \n     |  __weakref__\n     |      list of weak references to the object (if defined)\n     |  \n     |  ----------------------------------------------------------------------\n     |  Methods inherited from builtins.UserWarning:\n     |  \n     |  __init__(self, /, *args, **kwargs)\n     |      Initialize self.  See help(type(self)) for accurate signature.\n     |  \n     |  ----------------------------------------------------------------------\n     |  Static methods inherited from builtins.UserWarning:\n     |  \n     |  __new__(*args, **kwargs) from builtins.type\n     |      Create and return a new object.  See help(type) for accurate signature.\n     |  \n     |  ----------------------------------------------------------------------\n     |  Methods inherited from builtins.BaseException:\n     |  \n     |  __delattr__(self, name, /)\n     |      Implement delattr(self, name).\n     |  \n     |  __getattribute__(self, name, /)\n     |      Return getattr(self, name).\n     |  \n     |  __reduce__(...)\n     |      Helper for pickle.\n     |  \n     |  __repr__(self, /)\n     |      Return repr(self).\n     |  \n     |  __setattr__(self, name, value, /)\n     |      Implement setattr(self, name, value).\n     |  \n     |  __setstate__(...)\n     |  \n     |  __str__(self, /)\n     |      Return str(self).\n     |  \n     |  with_traceback(...)\n     |      Exception.with_traceback(tb) --\n     |      set self.__traceback__ to tb and return self.\n     |  \n     |  ----------------------------------------------------------------------\n     |  Data descriptors inherited from builtins.BaseException:\n     |  \n     |  __cause__\n     |      exception cause\n     |  \n     |  __context__\n     |      exception context\n     |  \n     |  __dict__\n     |  \n     |  __suppress_context__\n     |  \n     |  __traceback__\n     |  \n     |  args\n    \n    class PytestUnraisableExceptionWarning(PytestWarning)\n     |  An unraisable exception was reported.\n     |  \n     |  Unraisable exceptions are exceptions raised in :meth:`__del__ <object.__del__>`\n     |  implementations and similar situations when the exception cannot be raised\n     |  as normal.\n     |  \n     |  Method resolution order:\n     |      PytestUnraisableExceptionWarning\n     |      PytestWarning\n     |      builtins.UserWarning\n     |      builtins.Warning\n     |      builtins.Exception\n     |      builtins.BaseException\n     |      builtins.object\n     |  \n     |  Data descriptors inherited from PytestWarning:\n     |  \n     |  __weakref__\n     |      list of weak references to the object (if defined)\n     |  \n     |  ----------------------------------------------------------------------\n     |  Methods inherited from builtins.UserWarning:\n     |  \n     |  __init__(self, /, *args, **kwargs)\n     |      Initialize self.  See help(type(self)) for accurate signature.\n     |  \n     |  ----------------------------------------------------------------------\n     |  Static methods inherited from builtins.UserWarning:\n     |  \n     |  __new__(*args, **kwargs) from builtins.type\n     |      Create and return a new object.  See help(type) for accurate signature.\n     |  \n     |  ----------------------------------------------------------------------\n     |  Methods inherited from builtins.BaseException:\n     |  \n     |  __delattr__(self, name, /)\n     |      Implement delattr(self, name).\n     |  \n     |  __getattribute__(self, name, /)\n     |      Return getattr(self, name).\n     |  \n     |  __reduce__(...)\n     |      Helper for pickle.\n     |  \n     |  __repr__(self, /)\n     |      Return repr(self).\n     |  \n     |  __setattr__(self, name, value, /)\n     |      Implement setattr(self, name, value).\n     |  \n     |  __setstate__(...)\n     |  \n     |  __str__(self, /)\n     |      Return str(self).\n     |  \n     |  with_traceback(...)\n     |      Exception.with_traceback(tb) --\n     |      set self.__traceback__ to tb and return self.\n     |  \n     |  ----------------------------------------------------------------------\n     |  Data descriptors inherited from builtins.BaseException:\n     |  \n     |  __cause__\n     |      exception cause\n     |  \n     |  __context__\n     |      exception context\n     |  \n     |  __dict__\n     |  \n     |  __suppress_context__\n     |  \n     |  __traceback__\n     |  \n     |  args\n    \n    class PytestWarning(builtins.UserWarning)\n     |  Base class for all warnings emitted by pytest.\n     |  \n     |  Method resolution order:\n     |      PytestWarning\n     |      builtins.UserWarning\n     |      builtins.Warning\n     |      builtins.Exception\n     |      builtins.BaseException\n     |      builtins.object\n     |  \n     |  Data descriptors defined here:\n     |  \n     |  __weakref__\n     |      list of weak references to the object (if defined)\n     |  \n     |  ----------------------------------------------------------------------\n     |  Methods inherited from builtins.UserWarning:\n     |  \n     |  __init__(self, /, *args, **kwargs)\n     |      Initialize self.  See help(type(self)) for accurate signature.\n     |  \n     |  ----------------------------------------------------------------------\n     |  Static methods inherited from builtins.UserWarning:\n     |  \n     |  __new__(*args, **kwargs) from builtins.type\n     |      Create and return a new object.  See help(type) for accurate signature.\n     |  \n     |  ----------------------------------------------------------------------\n     |  Methods inherited from builtins.BaseException:\n     |  \n     |  __delattr__(self, name, /)\n     |      Implement delattr(self, name).\n     |  \n     |  __getattribute__(self, name, /)\n     |      Return getattr(self, name).\n     |  \n     |  __reduce__(...)\n     |      Helper for pickle.\n     |  \n     |  __repr__(self, /)\n     |      Return repr(self).\n     |  \n     |  __setattr__(self, name, value, /)\n     |      Implement setattr(self, name, value).\n     |  \n     |  __setstate__(...)\n     |  \n     |  __str__(self, /)\n     |      Return str(self).\n     |  \n     |  with_traceback(...)\n     |      Exception.with_traceback(tb) --\n     |      set self.__traceback__ to tb and return self.\n     |  \n     |  ----------------------------------------------------------------------\n     |  Data descriptors inherited from builtins.BaseException:\n     |  \n     |  __cause__\n     |      exception cause\n     |  \n     |  __context__\n     |      exception context\n     |  \n     |  __dict__\n     |  \n     |  __suppress_context__\n     |  \n     |  __traceback__\n     |  \n     |  args\n    \n    class Pytester(builtins.object)\n     |  Pytester(request: _pytest.fixtures.FixtureRequest, tmp_path_factory: _pytest.tmpdir.TempPathFactory, monkeypatch: _pytest.monkeypatch.MonkeyPatch, *, _ispytest: bool = False) -> None\n     |  \n     |  Facilities to write tests/configuration files, execute pytest in isolation, and match\n     |  against expected output, perfect for black-box testing of pytest plugins.\n     |  \n     |  It attempts to isolate the test run from external factors as much as possible, modifying\n     |  the current working directory to :attr:`path` and environment variables during initialization.\n     |  \n     |  Methods defined here:\n     |  \n     |  __init__(self, request: _pytest.fixtures.FixtureRequest, tmp_path_factory: _pytest.tmpdir.TempPathFactory, monkeypatch: _pytest.monkeypatch.MonkeyPatch, *, _ispytest: bool = False) -> None\n     |      Initialize self.  See help(type(self)) for accurate signature.\n     |  \n     |  __repr__(self) -> str\n     |      Return repr(self).\n     |  \n     |  chdir(self) -> None\n     |      Cd into the temporary directory.\n     |      \n     |      This is done automatically upon instantiation.\n     |  \n     |  collect_by_name(self, modcol: _pytest.nodes.Collector, name: str) -> Union[_pytest.nodes.Item, _pytest.nodes.Collector, NoneType]\n     |      Return the collection node for name from the module collection.\n     |      \n     |      Searches a module collection node for a collection node matching the\n     |      given name.\n     |      \n     |      :param modcol: A module collection node; see :py:meth:`getmodulecol`.\n     |      :param name: The name of the node to return.\n     |  \n     |  copy_example(self, name: Optional[str] = None) -> pathlib.Path\n     |      Copy file from project's directory into the testdir.\n     |      \n     |      :param name:\n     |          The name of the file to copy.\n     |      :return:\n     |          Path to the copied directory (inside ``self.path``).\n     |  \n     |  genitems(self, colitems: Sequence[Union[_pytest.nodes.Item, _pytest.nodes.Collector]]) -> List[_pytest.nodes.Item]\n     |      Generate all test items from a collection node.\n     |      \n     |      This recurses into the collection node and returns a list of all the\n     |      test items contained within.\n     |      \n     |      :param colitems:\n     |          The collection nodes.\n     |      :returns:\n     |          The collected items.\n     |  \n     |  getinicfg(self, source: str) -> iniconfig.SectionWrapper\n     |      Return the pytest section from the tox.ini config file.\n     |  \n     |  getitem(self, source: Union[str, ForwardRef('os.PathLike[str]')], funcname: str = 'test_func') -> _pytest.nodes.Item\n     |      Return the test item for a test function.\n     |      \n     |      Writes the source to a python file and runs pytest's collection on\n     |      the resulting module, returning the test item for the requested\n     |      function name.\n     |      \n     |      :param source:\n     |          The module source.\n     |      :param funcname:\n     |          The name of the test function for which to return a test item.\n     |      :returns:\n     |          The test item.\n     |  \n     |  getitems(self, source: Union[str, ForwardRef('os.PathLike[str]')]) -> List[_pytest.nodes.Item]\n     |      Return all test items collected from the module.\n     |      \n     |      Writes the source to a Python file and runs pytest's collection on\n     |      the resulting module, returning all test items contained within.\n     |  \n     |  getmodulecol(self, source: Union[str, ForwardRef('os.PathLike[str]')], configargs=(), *, withinit: bool = False)\n     |      Return the module collection node for ``source``.\n     |      \n     |      Writes ``source`` to a file using :py:meth:`makepyfile` and then\n     |      runs the pytest collection on it, returning the collection node for the\n     |      test module.\n     |      \n     |      :param source:\n     |          The source code of the module to collect.\n     |      \n     |      :param configargs:\n     |          Any extra arguments to pass to :py:meth:`parseconfigure`.\n     |      \n     |      :param withinit:\n     |          Whether to also write an ``__init__.py`` file to the same\n     |          directory to ensure it is a package.\n     |  \n     |  getnode(self, config: _pytest.config.Config, arg: Union[str, ForwardRef('os.PathLike[str]')]) -> Union[_pytest.nodes.Collector, _pytest.nodes.Item]\n     |      Get the collection node of a file.\n     |      \n     |      :param config:\n     |         A pytest config.\n     |         See :py:meth:`parseconfig` and :py:meth:`parseconfigure` for creating it.\n     |      :param arg:\n     |          Path to the file.\n     |      :returns:\n     |          The node.\n     |  \n     |  getpathnode(self, path: Union[str, ForwardRef('os.PathLike[str]')]) -> Union[_pytest.nodes.Collector, _pytest.nodes.Item]\n     |      Return the collection node of a file.\n     |      \n     |      This is like :py:meth:`getnode` but uses :py:meth:`parseconfigure` to\n     |      create the (configured) pytest Config instance.\n     |      \n     |      :param path:\n     |          Path to the file.\n     |      :returns:\n     |          The node.\n     |  \n     |  inline_genitems(self, *args) -> Tuple[List[_pytest.nodes.Item], _pytest.pytester.HookRecorder]\n     |      Run ``pytest.main(['--collectonly'])`` in-process.\n     |      \n     |      Runs the :py:func:`pytest.main` function to run all of pytest inside\n     |      the test process itself like :py:meth:`inline_run`, but returns a\n     |      tuple of the collected items and a :py:class:`HookRecorder` instance.\n     |  \n     |  inline_run(self, *args: Union[str, ForwardRef('os.PathLike[str]')], plugins=(), no_reraise_ctrlc: bool = False) -> _pytest.pytester.HookRecorder\n     |      Run ``pytest.main()`` in-process, returning a HookRecorder.\n     |      \n     |      Runs the :py:func:`pytest.main` function to run all of pytest inside\n     |      the test process itself.  This means it can return a\n     |      :py:class:`HookRecorder` instance which gives more detailed results\n     |      from that run than can be done by matching stdout/stderr from\n     |      :py:meth:`runpytest`.\n     |      \n     |      :param args:\n     |          Command line arguments to pass to :py:func:`pytest.main`.\n     |      :param plugins:\n     |          Extra plugin instances the ``pytest.main()`` instance should use.\n     |      :param no_reraise_ctrlc:\n     |          Typically we reraise keyboard interrupts from the child run. If\n     |          True, the KeyboardInterrupt exception is captured.\n     |  \n     |  inline_runsource(self, source: str, *cmdlineargs) -> _pytest.pytester.HookRecorder\n     |      Run a test module in process using ``pytest.main()``.\n     |      \n     |      This run writes \"source\" into a temporary file and runs\n     |      ``pytest.main()`` on it, returning a :py:class:`HookRecorder` instance\n     |      for the result.\n     |      \n     |      :param source: The source code of the test module.\n     |      :param cmdlineargs: Any extra command line arguments to use.\n     |  \n     |  make_hook_recorder(self, pluginmanager: _pytest.config.PytestPluginManager) -> _pytest.pytester.HookRecorder\n     |      Create a new :class:`HookRecorder` for a :class:`PytestPluginManager`.\n     |  \n     |  makeconftest(self, source: str) -> pathlib.Path\n     |      Write a contest.py file.\n     |      \n     |      :param source: The contents.\n     |      :returns: The conftest.py file.\n     |  \n     |  makefile(self, ext: str, *args: str, **kwargs: str) -> pathlib.Path\n     |      Create new text file(s) in the test directory.\n     |      \n     |      :param ext:\n     |          The extension the file(s) should use, including the dot, e.g. `.py`.\n     |      :param args:\n     |          All args are treated as strings and joined using newlines.\n     |          The result is written as contents to the file.  The name of the\n     |          file is based on the test function requesting this fixture.\n     |      :param kwargs:\n     |          Each keyword is the name of a file, while the value of it will\n     |          be written as contents of the file.\n     |      :returns:\n     |          The first created file.\n     |      \n     |      Examples:\n     |      \n     |      .. code-block:: python\n     |      \n     |          pytester.makefile(\".txt\", \"line1\", \"line2\")\n     |      \n     |          pytester.makefile(\".ini\", pytest=\"[pytest]\\naddopts=-rs\\n\")\n     |      \n     |      To create binary files, use :meth:`pathlib.Path.write_bytes` directly:\n     |      \n     |      .. code-block:: python\n     |      \n     |          filename = pytester.path.joinpath(\"foo.bin\")\n     |          filename.write_bytes(b\"...\")\n     |  \n     |  makeini(self, source: str) -> pathlib.Path\n     |      Write a tox.ini file.\n     |      \n     |      :param source: The contents.\n     |      :returns: The tox.ini file.\n     |  \n     |  makepyfile(self, *args, **kwargs) -> pathlib.Path\n     |      Shortcut for .makefile() with a .py extension.\n     |      \n     |      Defaults to the test name with a '.py' extension, e.g test_foobar.py, overwriting\n     |      existing files.\n     |      \n     |      Examples:\n     |      \n     |      .. code-block:: python\n     |      \n     |          def test_something(pytester):\n     |              # Initial file is created test_something.py.\n     |              pytester.makepyfile(\"foobar\")\n     |              # To create multiple files, pass kwargs accordingly.\n     |              pytester.makepyfile(custom=\"foobar\")\n     |              # At this point, both 'test_something.py' & 'custom.py' exist in the test directory.\n     |  \n     |  makepyprojecttoml(self, source: str) -> pathlib.Path\n     |      Write a pyproject.toml file.\n     |      \n     |      :param source: The contents.\n     |      :returns: The pyproject.ini file.\n     |      \n     |      .. versionadded:: 6.0\n     |  \n     |  maketxtfile(self, *args, **kwargs) -> pathlib.Path\n     |      Shortcut for .makefile() with a .txt extension.\n     |      \n     |      Defaults to the test name with a '.txt' extension, e.g test_foobar.txt, overwriting\n     |      existing files.\n     |      \n     |      Examples:\n     |      \n     |      .. code-block:: python\n     |      \n     |          def test_something(pytester):\n     |              # Initial file is created test_something.txt.\n     |              pytester.maketxtfile(\"foobar\")\n     |              # To create multiple files, pass kwargs accordingly.\n     |              pytester.maketxtfile(custom=\"foobar\")\n     |              # At this point, both 'test_something.txt' & 'custom.txt' exist in the test directory.\n     |  \n     |  mkdir(self, name: Union[str, ForwardRef('os.PathLike[str]')]) -> pathlib.Path\n     |      Create a new (sub)directory.\n     |      \n     |      :param name:\n     |          The name of the directory, relative to the pytester path.\n     |      :returns:\n     |          The created directory.\n     |  \n     |  mkpydir(self, name: Union[str, ForwardRef('os.PathLike[str]')]) -> pathlib.Path\n     |      Create a new python package.\n     |      \n     |      This creates a (sub)directory with an empty ``__init__.py`` file so it\n     |      gets recognised as a Python package.\n     |  \n     |  parseconfig(self, *args: Union[str, ForwardRef('os.PathLike[str]')]) -> _pytest.config.Config\n     |      Return a new pytest :class:`pytest.Config` instance from given\n     |      commandline args.\n     |      \n     |      This invokes the pytest bootstrapping code in _pytest.config to create a\n     |      new :py:class:`pytest.PytestPluginManager` and call the\n     |      :hook:`pytest_cmdline_parse` hook to create a new :class:`pytest.Config`\n     |      instance.\n     |      \n     |      If :attr:`plugins` has been populated they should be plugin modules\n     |      to be registered with the plugin manager.\n     |  \n     |  parseconfigure(self, *args: Union[str, ForwardRef('os.PathLike[str]')]) -> _pytest.config.Config\n     |      Return a new pytest configured Config instance.\n     |      \n     |      Returns a new :py:class:`pytest.Config` instance like\n     |      :py:meth:`parseconfig`, but also calls the :hook:`pytest_configure`\n     |      hook.\n     |  \n     |  popen(self, cmdargs: Sequence[Union[str, ForwardRef('os.PathLike[str]')]], stdout: Union[int, TextIO] = -1, stderr: Union[int, TextIO] = -1, stdin: Union[_pytest.compat.NotSetType, bytes, IO[Any], int] = <NotSetType.token: 0>, **kw)\n     |      Invoke :py:class:`subprocess.Popen`.\n     |      \n     |      Calls :py:class:`subprocess.Popen` making sure the current working\n     |      directory is in ``PYTHONPATH``.\n     |      \n     |      You probably want to use :py:meth:`run` instead.\n     |  \n     |  run(self, *cmdargs: Union[str, ForwardRef('os.PathLike[str]')], timeout: Optional[float] = None, stdin: Union[_pytest.compat.NotSetType, bytes, IO[Any], int] = <NotSetType.token: 0>) -> _pytest.pytester.RunResult\n     |      Run a command with arguments.\n     |      \n     |      Run a process using :py:class:`subprocess.Popen` saving the stdout and\n     |      stderr.\n     |      \n     |      :param cmdargs:\n     |          The sequence of arguments to pass to :py:class:`subprocess.Popen`,\n     |          with path-like objects being converted to :py:class:`str`\n     |          automatically.\n     |      :param timeout:\n     |          The period in seconds after which to timeout and raise\n     |          :py:class:`Pytester.TimeoutExpired`.\n     |      :param stdin:\n     |          Optional standard input.\n     |      \n     |          - If it is :py:attr:`CLOSE_STDIN` (Default), then this method calls\n     |            :py:class:`subprocess.Popen` with ``stdin=subprocess.PIPE``, and\n     |            the standard input is closed immediately after the new command is\n     |            started.\n     |      \n     |          - If it is of type :py:class:`bytes`, these bytes are sent to the\n     |            standard input of the command.\n     |      \n     |          - Otherwise, it is passed through to :py:class:`subprocess.Popen`.\n     |            For further information in this case, consult the document of the\n     |            ``stdin`` parameter in :py:class:`subprocess.Popen`.\n     |      :returns:\n     |          The result.\n     |  \n     |  runitem(self, source: str) -> Any\n     |      Run the \"test_func\" Item.\n     |      \n     |      The calling test instance (class containing the test method) must\n     |      provide a ``.getrunner()`` method which should return a runner which\n     |      can run the test protocol for a single item, e.g.\n     |      :py:func:`_pytest.runner.runtestprotocol`.\n     |  \n     |  runpytest(self, *args: Union[str, ForwardRef('os.PathLike[str]')], **kwargs: Any) -> _pytest.pytester.RunResult\n     |      Run pytest inline or in a subprocess, depending on the command line\n     |      option \"--runpytest\" and return a :py:class:`~pytest.RunResult`.\n     |  \n     |  runpytest_inprocess(self, *args: Union[str, ForwardRef('os.PathLike[str]')], **kwargs: Any) -> _pytest.pytester.RunResult\n     |      Return result of running pytest in-process, providing a similar\n     |      interface to what self.runpytest() provides.\n     |  \n     |  runpytest_subprocess(self, *args: Union[str, ForwardRef('os.PathLike[str]')], timeout: Optional[float] = None) -> _pytest.pytester.RunResult\n     |      Run pytest as a subprocess with given arguments.\n     |      \n     |      Any plugins added to the :py:attr:`plugins` list will be added using the\n     |      ``-p`` command line option.  Additionally ``--basetemp`` is used to put\n     |      any temporary files and directories in a numbered directory prefixed\n     |      with \"runpytest-\" to not conflict with the normal numbered pytest\n     |      location for temporary files and directories.\n     |      \n     |      :param args:\n     |          The sequence of arguments to pass to the pytest subprocess.\n     |      :param timeout:\n     |          The period in seconds after which to timeout and raise\n     |          :py:class:`Pytester.TimeoutExpired`.\n     |      :returns:\n     |          The result.\n     |  \n     |  runpython(self, script: 'os.PathLike[str]') -> _pytest.pytester.RunResult\n     |      Run a python script using sys.executable as interpreter.\n     |  \n     |  runpython_c(self, command: str) -> _pytest.pytester.RunResult\n     |      Run ``python -c \"command\"``.\n     |  \n     |  spawn(self, cmd: str, expect_timeout: float = 10.0) -> 'pexpect.spawn'\n     |      Run a command using pexpect.\n     |      \n     |      The pexpect child is returned.\n     |  \n     |  spawn_pytest(self, string: str, expect_timeout: float = 10.0) -> 'pexpect.spawn'\n     |      Run pytest using pexpect.\n     |      \n     |      This makes sure to use the right pytest and sets up the temporary\n     |      directory locations.\n     |      \n     |      The pexpect child is returned.\n     |  \n     |  syspathinsert(self, path: Union[str, ForwardRef('os.PathLike[str]'), NoneType] = None) -> None\n     |      Prepend a directory to sys.path, defaults to :attr:`path`.\n     |      \n     |      This is undone automatically when this object dies at the end of each\n     |      test.\n     |      \n     |      :param path:\n     |          The path.\n     |  \n     |  ----------------------------------------------------------------------\n     |  Readonly properties defined here:\n     |  \n     |  path\n     |      Temporary directory path used to create files/run tests from, etc.\n     |  \n     |  ----------------------------------------------------------------------\n     |  Data descriptors defined here:\n     |  \n     |  __dict__\n     |      dictionary for instance variables (if defined)\n     |  \n     |  __weakref__\n     |      list of weak references to the object (if defined)\n     |  \n     |  ----------------------------------------------------------------------\n     |  Data and other attributes defined here:\n     |  \n     |  CLOSE_STDIN = <NotSetType.token: 0>\n     |  \n     |  TimeoutExpired = <class '_pytest.pytester.Pytester.TimeoutExpired'>\n     |  \n     |  __annotations__ = {'CLOSE_STDIN': 'Final'}\n     |  \n     |  __test__ = False\n    \n    class RecordedHookCall(builtins.object)\n     |  RecordedHookCall(name: str, kwargs) -> None\n     |  \n     |  A recorded call to a hook.\n     |  \n     |  The arguments to the hook call are set as attributes.\n     |  For example:\n     |  \n     |  .. code-block:: python\n     |  \n     |      calls = hook_recorder.getcalls(\"pytest_runtest_setup\")\n     |      # Suppose pytest_runtest_setup was called once with `item=an_item`.\n     |      assert calls[0].item is an_item\n     |  \n     |  Methods defined here:\n     |  \n     |  __init__(self, name: str, kwargs) -> None\n     |      Initialize self.  See help(type(self)) for accurate signature.\n     |  \n     |  __repr__(self) -> str\n     |      Return repr(self).\n     |  \n     |  ----------------------------------------------------------------------\n     |  Data descriptors defined here:\n     |  \n     |  __dict__\n     |      dictionary for instance variables (if defined)\n     |  \n     |  __weakref__\n     |      list of weak references to the object (if defined)\n    \n    class RunResult(builtins.object)\n     |  RunResult(ret: Union[int, _pytest.config.ExitCode], outlines: List[str], errlines: List[str], duration: float) -> None\n     |  \n     |  The result of running a command from :class:`~pytest.Pytester`.\n     |  \n     |  Methods defined here:\n     |  \n     |  __init__(self, ret: Union[int, _pytest.config.ExitCode], outlines: List[str], errlines: List[str], duration: float) -> None\n     |      Initialize self.  See help(type(self)) for accurate signature.\n     |  \n     |  __repr__(self) -> str\n     |      Return repr(self).\n     |  \n     |  assert_outcomes(self, passed: int = 0, skipped: int = 0, failed: int = 0, errors: int = 0, xpassed: int = 0, xfailed: int = 0, warnings: Optional[int] = None, deselected: Optional[int] = None) -> None\n     |      Assert that the specified outcomes appear with the respective\n     |      numbers (0 means it didn't occur) in the text output from a test run.\n     |      \n     |      ``warnings`` and ``deselected`` are only checked if not None.\n     |  \n     |  parseoutcomes(self) -> Dict[str, int]\n     |      Return a dictionary of outcome noun -> count from parsing the terminal\n     |      output that the test process produced.\n     |      \n     |      The returned nouns will always be in plural form::\n     |      \n     |          ======= 1 failed, 1 passed, 1 warning, 1 error in 0.13s ====\n     |      \n     |      Will return ``{\"failed\": 1, \"passed\": 1, \"warnings\": 1, \"errors\": 1}``.\n     |  \n     |  ----------------------------------------------------------------------\n     |  Class methods defined here:\n     |  \n     |  parse_summary_nouns(lines) -> Dict[str, int] from builtins.type\n     |      Extract the nouns from a pytest terminal summary line.\n     |      \n     |      It always returns the plural noun for consistency::\n     |      \n     |          ======= 1 failed, 1 passed, 1 warning, 1 error in 0.13s ====\n     |      \n     |      Will return ``{\"failed\": 1, \"passed\": 1, \"warnings\": 1, \"errors\": 1}``.\n     |  \n     |  ----------------------------------------------------------------------\n     |  Data descriptors defined here:\n     |  \n     |  __dict__\n     |      dictionary for instance variables (if defined)\n     |  \n     |  __weakref__\n     |      list of weak references to the object (if defined)\n    \n    class Session(_pytest.nodes.FSCollector)\n     |  Session(*k, **kw)\n     |  \n     |  Method resolution order:\n     |      Session\n     |      _pytest.nodes.FSCollector\n     |      _pytest.nodes.Collector\n     |      _pytest.nodes.Node\n     |      builtins.object\n     |  \n     |  Methods defined here:\n     |  \n     |  __init__(self, config: _pytest.config.Config) -> None\n     |      Initialize self.  See help(type(self)) for accurate signature.\n     |  \n     |  __repr__(self) -> str\n     |      Return repr(self).\n     |  \n     |  collect(self) -> Iterator[Union[_pytest.nodes.Item, _pytest.nodes.Collector]]\n     |      Return a list of children (items and collectors) for this\n     |      collection node.\n     |  \n     |  genitems(self, node: Union[_pytest.nodes.Item, _pytest.nodes.Collector]) -> Iterator[_pytest.nodes.Item]\n     |  \n     |  gethookproxy(self, fspath: 'os.PathLike[str]')\n     |  \n     |  isinitpath(self, path: Union[str, ForwardRef('os.PathLike[str]')]) -> bool\n     |  \n     |  perform_collect(self, args: Optional[Sequence[str]] = None, genitems: bool = True) -> Sequence[Union[_pytest.nodes.Item, _pytest.nodes.Collector]]\n     |      Perform the collection phase for this session.\n     |      \n     |      This is called by the default :hook:`pytest_collection` hook\n     |      implementation; see the documentation of this hook for more details.\n     |      For testing purposes, it may also be called directly on a fresh\n     |      ``Session``.\n     |      \n     |      This function normally recursively expands any collectors collected\n     |      from the session to their items, and only items are returned. For\n     |      testing purposes, this may be suppressed by passing ``genitems=False``,\n     |      in which case the return value contains these collectors unexpanded,\n     |      and ``session.items`` is empty.\n     |  \n     |  pytest_collectreport = pytest_runtest_logreport(self, report: Union[_pytest.reports.TestReport, _pytest.reports.CollectReport]) -> None\n     |  \n     |  pytest_collectstart(self) -> None\n     |  \n     |  pytest_runtest_logreport(self, report: Union[_pytest.reports.TestReport, _pytest.reports.CollectReport]) -> None\n     |  \n     |  ----------------------------------------------------------------------\n     |  Class methods defined here:\n     |  \n     |  from_config(config: _pytest.config.Config) -> 'Session' from _pytest.nodes.NodeMeta\n     |  \n     |  ----------------------------------------------------------------------\n     |  Readonly properties defined here:\n     |  \n     |  startpath\n     |      The path from which pytest was invoked.\n     |      \n     |      .. versionadded:: 7.0.0\n     |  \n     |  ----------------------------------------------------------------------\n     |  Data and other attributes defined here:\n     |  \n     |  Failed = <class '_pytest.main.Failed'>\n     |      Signals a stop as failed test run.\n     |  \n     |  \n     |  Interrupted = <class 'Interrupted'>\n     |      Signals that the test run was interrupted.\n     |  \n     |  \n     |  __annotations__ = {'_fixturemanager': <class '_pytest.fixtures.Fixture...\n     |  \n     |  ----------------------------------------------------------------------\n     |  Class methods inherited from _pytest.nodes.FSCollector:\n     |  \n     |  from_parent(parent, *, fspath: Optional[_pytest._py.path.LocalPath] = None, path: Optional[pathlib.Path] = None, **kw) from _pytest.nodes.NodeMeta\n     |      The public constructor.\n     |  \n     |  ----------------------------------------------------------------------\n     |  Methods inherited from _pytest.nodes.Collector:\n     |  \n     |  repr_failure(self, excinfo: _pytest._code.code.ExceptionInfo[BaseException]) -> Union[str, _pytest._code.code.TerminalRepr]\n     |      Return a representation of a collection failure.\n     |      \n     |      :param excinfo: Exception information for the failure.\n     |  \n     |  ----------------------------------------------------------------------\n     |  Data descriptors inherited from _pytest.nodes.Collector:\n     |  \n     |  __weakref__\n     |      list of weak references to the object (if defined)\n     |  \n     |  ----------------------------------------------------------------------\n     |  Data and other attributes inherited from _pytest.nodes.Collector:\n     |  \n     |  CollectError = <class '_pytest.nodes.Collector.CollectError'>\n     |      An error during collection, contains a custom message.\n     |  \n     |  \n     |  ----------------------------------------------------------------------\n     |  Methods inherited from _pytest.nodes.Node:\n     |  \n     |  __hash__(self) -> int\n     |      Return hash(self).\n     |  \n     |  add_marker(self, marker: Union[str, _pytest.mark.structures.MarkDecorator], append: bool = True) -> None\n     |      Dynamically add a marker object to the node.\n     |      \n     |      :param marker:\n     |          The marker.\n     |      :param append:\n     |          Whether to append the marker, or prepend it.\n     |  \n     |  addfinalizer(self, fin: Callable[[], object]) -> None\n     |      Register a function to be called without arguments when this node is\n     |      finalized.\n     |      \n     |      This method can only be called when this node is active\n     |      in a setup chain, for example during self.setup().\n     |  \n     |  get_closest_marker(self, name: str, default: Optional[_pytest.mark.structures.Mark] = None) -> Optional[_pytest.mark.structures.Mark]\n     |      Return the first marker matching the name, from closest (for\n     |      example function) to farther level (for example module level).\n     |      \n     |      :param default: Fallback return value if no marker was found.\n     |      :param name: Name to filter by.\n     |  \n     |  getparent(self, cls: Type[~_NodeType]) -> Optional[~_NodeType]\n     |      Get the next parent node (including self) which is an instance of\n     |      the given class.\n     |      \n     |      :param cls: The node class to search for.\n     |      :returns: The node, if found.\n     |  \n     |  iter_markers(self, name: Optional[str] = None) -> Iterator[_pytest.mark.structures.Mark]\n     |      Iterate over all markers of the node.\n     |      \n     |      :param name: If given, filter the results by the name attribute.\n     |      :returns: An iterator of the markers of the node.\n     |  \n     |  iter_markers_with_node(self, name: Optional[str] = None) -> Iterator[Tuple[ForwardRef('Node'), _pytest.mark.structures.Mark]]\n     |      Iterate over all markers of the node.\n     |      \n     |      :param name: If given, filter the results by the name attribute.\n     |      :returns: An iterator of (node, mark) tuples.\n     |  \n     |  listchain(self) -> List[ForwardRef('Node')]\n     |      Return list of all parent collectors up to self, starting from\n     |      the root of collection tree.\n     |      \n     |      :returns: The nodes.\n     |  \n     |  listextrakeywords(self) -> Set[str]\n     |      Return a set of all extra keywords in self and any parents.\n     |  \n     |  listnames(self) -> List[str]\n     |  \n     |  setup(self) -> None\n     |  \n     |  teardown(self) -> None\n     |  \n     |  warn(self, warning: Warning) -> None\n     |      Issue a warning for this Node.\n     |      \n     |      Warnings will be displayed after the test session, unless explicitly suppressed.\n     |      \n     |      :param Warning warning:\n     |          The warning instance to issue.\n     |      \n     |      :raises ValueError: If ``warning`` instance is not a subclass of Warning.\n     |      \n     |      Example usage:\n     |      \n     |      .. code-block:: python\n     |      \n     |          node.warn(PytestWarning(\"some message\"))\n     |          node.warn(UserWarning(\"some message\"))\n     |      \n     |      .. versionchanged:: 6.2\n     |          Any subclass of :class:`Warning` is now accepted, rather than only\n     |          :class:`PytestWarning <pytest.PytestWarning>` subclasses.\n     |  \n     |  ----------------------------------------------------------------------\n     |  Readonly properties inherited from _pytest.nodes.Node:\n     |  \n     |  ihook\n     |      fspath-sensitive hook proxy used to call pytest hooks.\n     |  \n     |  nodeid\n     |      A ::-separated string denoting its collection tree address.\n     |  \n     |  ----------------------------------------------------------------------\n     |  Data descriptors inherited from _pytest.nodes.Node:\n     |  \n     |  __dict__\n     |      dictionary for instance variables (if defined)\n     |  \n     |  config\n     |  \n     |  name\n     |  \n     |  parent\n     |  \n     |  path\n     |  \n     |  session\n    \n    class Stash(builtins.object)\n     |  Stash() -> None\n     |  \n     |  ``Stash`` is a type-safe heterogeneous mutable mapping that\n     |  allows keys and value types to be defined separately from\n     |  where it (the ``Stash``) is created.\n     |  \n     |  Usually you will be given an object which has a ``Stash``, for example\n     |  :class:`~pytest.Config` or a :class:`~_pytest.nodes.Node`:\n     |  \n     |  .. code-block:: python\n     |  \n     |      stash: Stash = some_object.stash\n     |  \n     |  If a module or plugin wants to store data in this ``Stash``, it creates\n     |  :class:`StashKey`\\s for its keys (at the module level):\n     |  \n     |  .. code-block:: python\n     |  \n     |      # At the top-level of the module\n     |      some_str_key = StashKey[str]()\n     |      some_bool_key = StashKey[bool]()\n     |  \n     |  To store information:\n     |  \n     |  .. code-block:: python\n     |  \n     |      # Value type must match the key.\n     |      stash[some_str_key] = \"value\"\n     |      stash[some_bool_key] = True\n     |  \n     |  To retrieve the information:\n     |  \n     |  .. code-block:: python\n     |  \n     |      # The static type of some_str is str.\n     |      some_str = stash[some_str_key]\n     |      # The static type of some_bool is bool.\n     |      some_bool = stash[some_bool_key]\n     |  \n     |  Methods defined here:\n     |  \n     |  __contains__(self, key: _pytest.stash.StashKey[~T]) -> bool\n     |      Return whether key was set.\n     |  \n     |  __delitem__(self, key: _pytest.stash.StashKey[~T]) -> None\n     |      Delete the value for key.\n     |      \n     |      Raises ``KeyError`` if the key wasn't set before.\n     |  \n     |  __getitem__(self, key: _pytest.stash.StashKey[~T]) -> ~T\n     |      Get the value for key.\n     |      \n     |      Raises ``KeyError`` if the key wasn't set before.\n     |  \n     |  __init__(self) -> None\n     |      Initialize self.  See help(type(self)) for accurate signature.\n     |  \n     |  __len__(self) -> int\n     |      Return how many items exist in the stash.\n     |  \n     |  __setitem__(self, key: _pytest.stash.StashKey[~T], value: ~T) -> None\n     |      Set a value for key.\n     |  \n     |  get(self, key: _pytest.stash.StashKey[~T], default: ~D) -> Union[~T, ~D]\n     |      Get the value for key, or return default if the key wasn't set\n     |      before.\n     |  \n     |  setdefault(self, key: _pytest.stash.StashKey[~T], default: ~T) -> ~T\n     |      Return the value of key if already set, otherwise set the value\n     |      of key to default and return default.\n    \n    class StashKey(typing.Generic)\n     |  ``StashKey`` is an object used as a key to a :class:`Stash`.\n     |  \n     |  A ``StashKey`` is associated with the type ``T`` of the value of the key.\n     |  \n     |  A ``StashKey`` is unique and cannot conflict with another key.\n     |  \n     |  Method resolution order:\n     |      StashKey\n     |      typing.Generic\n     |      builtins.object\n     |  \n     |  Data and other attributes defined here:\n     |  \n     |  __orig_bases__ = (typing.Generic[~T],)\n     |  \n     |  __parameters__ = (~T,)\n     |  \n     |  ----------------------------------------------------------------------\n     |  Class methods inherited from typing.Generic:\n     |  \n     |  __class_getitem__(params) from builtins.type\n     |  \n     |  __init_subclass__(*args, **kwargs) from builtins.type\n     |      This method is called when a class is subclassed.\n     |      \n     |      The default implementation does nothing. It may be\n     |      overridden to extend subclasses.\n    \n    class TempPathFactory(builtins.object)\n     |  TempPathFactory(given_basetemp: Optional[pathlib.Path], retention_count: int, retention_policy: 'RetentionType', trace, basetemp: Optional[pathlib.Path] = None, *, _ispytest: bool = False) -> None\n     |  \n     |  Factory for temporary directories under the common base temp directory.\n     |  \n     |  The base directory can be configured using the ``--basetemp`` option.\n     |  \n     |  Methods defined here:\n     |  \n     |  __eq__(self, other)\n     |  \n     |  __init__(self, given_basetemp: Optional[pathlib.Path], retention_count: int, retention_policy: 'RetentionType', trace, basetemp: Optional[pathlib.Path] = None, *, _ispytest: bool = False) -> None\n     |      Initialize self.  See help(type(self)) for accurate signature.\n     |  \n     |  __repr__(self)\n     |  \n     |  getbasetemp(self) -> pathlib.Path\n     |      Return the base temporary directory, creating it if needed.\n     |      \n     |      :returns:\n     |          The base temporary directory.\n     |  \n     |  mktemp(self, basename: str, numbered: bool = True) -> pathlib.Path\n     |      Create a new temporary directory managed by the factory.\n     |      \n     |      :param basename:\n     |          Directory base name, must be a relative path.\n     |      \n     |      :param numbered:\n     |          If ``True``, ensure the directory is unique by adding a numbered\n     |          suffix greater than any existing one: ``basename=\"foo-\"`` and ``numbered=True``\n     |          means that this function will create directories named ``\"foo-0\"``,\n     |          ``\"foo-1\"``, ``\"foo-2\"`` and so on.\n     |      \n     |      :returns:\n     |          The path to the new directory.\n     |  \n     |  ----------------------------------------------------------------------\n     |  Class methods defined here:\n     |  \n     |  from_config(config: _pytest.config.Config, *, _ispytest: bool = False) -> 'TempPathFactory' from builtins.type\n     |      Create a factory according to pytest configuration.\n     |      \n     |      :meta private:\n     |  \n     |  ----------------------------------------------------------------------\n     |  Data descriptors defined here:\n     |  \n     |  __dict__\n     |      dictionary for instance variables (if defined)\n     |  \n     |  __weakref__\n     |      list of weak references to the object (if defined)\n     |  \n     |  ----------------------------------------------------------------------\n     |  Data and other attributes defined here:\n     |  \n     |  __annotations__ = {'_basetemp': typing.Optional[pathlib.Path], '_given...\n     |  \n     |  __dataclass_fields__ = {'_basetemp': Field(name='_basetemp',type=typin...\n     |  \n     |  __dataclass_params__ = _DataclassParams(init=True,repr=True,eq=True,or...\n     |  \n     |  __hash__ = None\n    \n    class TempdirFactory(builtins.object)\n     |  TempdirFactory(tmppath_factory: _pytest.tmpdir.TempPathFactory, *, _ispytest: bool = False) -> None\n     |  \n     |  Backward compatibility wrapper that implements :class:`py.path.local`\n     |  for :class:`TempPathFactory`.\n     |  \n     |  .. note::\n     |      These days, it is preferred to use ``tmp_path_factory``.\n     |  \n     |      :ref:`About the tmpdir and tmpdir_factory fixtures<tmpdir and tmpdir_factory>`.\n     |  \n     |  Methods defined here:\n     |  \n     |  __eq__(self, other)\n     |  \n     |  __init__(self, tmppath_factory: _pytest.tmpdir.TempPathFactory, *, _ispytest: bool = False) -> None\n     |      Initialize self.  See help(type(self)) for accurate signature.\n     |  \n     |  __repr__(self)\n     |  \n     |  getbasetemp(self) -> _pytest._py.path.LocalPath\n     |      Same as :meth:`TempPathFactory.getbasetemp`, but returns a :class:`py.path.local` object.\n     |  \n     |  mktemp(self, basename: str, numbered: bool = True) -> _pytest._py.path.LocalPath\n     |      Same as :meth:`TempPathFactory.mktemp`, but returns a :class:`py.path.local` object.\n     |  \n     |  ----------------------------------------------------------------------\n     |  Data descriptors defined here:\n     |  \n     |  __dict__\n     |      dictionary for instance variables (if defined)\n     |  \n     |  __weakref__\n     |      list of weak references to the object (if defined)\n     |  \n     |  ----------------------------------------------------------------------\n     |  Data and other attributes defined here:\n     |  \n     |  __annotations__ = {'_tmppath_factory': <class '_pytest.tmpdir.TempPath...\n     |  \n     |  __dataclass_fields__ = {'_tmppath_factory': Field(name='_tmppath_facto...\n     |  \n     |  __dataclass_params__ = _DataclassParams(init=True,repr=True,eq=True,or...\n     |  \n     |  __hash__ = None\n    \n    class TestReport(BaseReport)\n     |  TestReport(nodeid: str, location: Tuple[str, Optional[int], str], keywords: Mapping[str, Any], outcome: \"Literal['passed', 'failed', 'skipped']\", longrepr: Union[NoneType, _pytest._code.code.ExceptionInfo[BaseException], Tuple[str, int, str], str, _pytest._code.code.TerminalRepr], when: \"Literal['setup', 'call', 'teardown']\", sections: Iterable[Tuple[str, str]] = (), duration: float = 0, start: float = 0, stop: float = 0, user_properties: Optional[Iterable[Tuple[str, object]]] = None, **extra) -> None\n     |  \n     |  Basic test report object (also used for setup and teardown calls if\n     |  they fail).\n     |  \n     |  Reports can contain arbitrary extra attributes.\n     |  \n     |  Method resolution order:\n     |      TestReport\n     |      BaseReport\n     |      builtins.object\n     |  \n     |  Methods defined here:\n     |  \n     |  __init__(self, nodeid: str, location: Tuple[str, Optional[int], str], keywords: Mapping[str, Any], outcome: \"Literal['passed', 'failed', 'skipped']\", longrepr: Union[NoneType, _pytest._code.code.ExceptionInfo[BaseException], Tuple[str, int, str], str, _pytest._code.code.TerminalRepr], when: \"Literal['setup', 'call', 'teardown']\", sections: Iterable[Tuple[str, str]] = (), duration: float = 0, start: float = 0, stop: float = 0, user_properties: Optional[Iterable[Tuple[str, object]]] = None, **extra) -> None\n     |      Initialize self.  See help(type(self)) for accurate signature.\n     |  \n     |  __repr__(self) -> str\n     |      Return repr(self).\n     |  \n     |  ----------------------------------------------------------------------\n     |  Class methods defined here:\n     |  \n     |  from_item_and_call(item: _pytest.nodes.Item, call: 'CallInfo[None]') -> 'TestReport' from builtins.type\n     |      Create and fill a TestReport with standard item and call info.\n     |      \n     |      :param item: The item.\n     |      :param call: The call info.\n     |  \n     |  ----------------------------------------------------------------------\n     |  Data and other attributes defined here:\n     |  \n     |  __test__ = False\n     |  \n     |  ----------------------------------------------------------------------\n     |  Methods inherited from BaseReport:\n     |  \n     |  get_sections(self, prefix: str) -> Iterator[Tuple[str, str]]\n     |  \n     |  toterminal(self, out: _pytest._io.terminalwriter.TerminalWriter) -> None\n     |  \n     |  ----------------------------------------------------------------------\n     |  Readonly properties inherited from BaseReport:\n     |  \n     |  caplog\n     |      Return captured log lines, if log capturing is enabled.\n     |      \n     |      .. versionadded:: 3.5\n     |  \n     |  capstderr\n     |      Return captured text from stderr, if capturing is enabled.\n     |      \n     |      .. versionadded:: 3.0\n     |  \n     |  capstdout\n     |      Return captured text from stdout, if capturing is enabled.\n     |      \n     |      .. versionadded:: 3.0\n     |  \n     |  count_towards_summary\n     |      **Experimental** Whether this report should be counted towards the\n     |      totals shown at the end of the test session: \"1 passed, 1 failure, etc\".\n     |      \n     |      .. note::\n     |      \n     |          This function is considered **experimental**, so beware that it is subject to changes\n     |          even in patch releases.\n     |  \n     |  failed\n     |      Whether the outcome is failed.\n     |  \n     |  fspath\n     |      The path portion of the reported node, as a string.\n     |  \n     |  head_line\n     |      **Experimental** The head line shown with longrepr output for this\n     |      report, more commonly during traceback representation during\n     |      failures::\n     |      \n     |          ________ Test.foo ________\n     |      \n     |      \n     |      In the example above, the head_line is \"Test.foo\".\n     |      \n     |      .. note::\n     |      \n     |          This function is considered **experimental**, so beware that it is subject to changes\n     |          even in patch releases.\n     |  \n     |  longreprtext\n     |      Read-only property that returns the full string representation of\n     |      ``longrepr``.\n     |      \n     |      .. versionadded:: 3.0\n     |  \n     |  passed\n     |      Whether the outcome is passed.\n     |  \n     |  skipped\n     |      Whether the outcome is skipped.\n     |  \n     |  ----------------------------------------------------------------------\n     |  Data descriptors inherited from BaseReport:\n     |  \n     |  __dict__\n     |      dictionary for instance variables (if defined)\n     |  \n     |  __weakref__\n     |      list of weak references to the object (if defined)\n     |  \n     |  ----------------------------------------------------------------------\n     |  Data and other attributes inherited from BaseReport:\n     |  \n     |  __annotations__ = {'location': typing.Optional[typing.Tuple[str, typin...\n    \n    class TestShortLogReport(builtins.tuple)\n     |  TestShortLogReport(category: str, letter: str, word: Union[str, Tuple[str, Mapping[str, bool]]])\n     |  \n     |  Used to store the test status result category, shortletter and verbose word.\n     |  For example ``\"rerun\", \"R\", (\"RERUN\", {\"yellow\": True})``.\n     |  \n     |  :ivar category:\n     |      The class of result, for example ``\u201cpassed\u201d``, ``\u201cskipped\u201d``, ``\u201cerror\u201d``, or the empty string.\n     |  \n     |  :ivar letter:\n     |      The short letter shown as testing progresses, for example ``\".\"``, ``\"s\"``, ``\"E\"``, or the empty string.\n     |  \n     |  :ivar word:\n     |      Verbose word is shown as testing progresses in verbose mode, for example ``\"PASSED\"``, ``\"SKIPPED\"``,\n     |      ``\"ERROR\"``, or the empty string.\n     |  \n     |  Method resolution order:\n     |      TestShortLogReport\n     |      builtins.tuple\n     |      builtins.object\n     |  \n     |  Methods defined here:\n     |  \n     |  __getnewargs__(self)\n     |      Return self as a plain tuple.  Used by copy and pickle.\n     |  \n     |  __repr__(self)\n     |      Return a nicely formatted representation string\n     |  \n     |  _asdict(self)\n     |      Return a new dict which maps field names to their values.\n     |  \n     |  _replace(self, /, **kwds)\n     |      Return a new TestShortLogReport object replacing specified fields with new values\n     |  \n     |  ----------------------------------------------------------------------\n     |  Class methods defined here:\n     |  \n     |  _make(iterable) from builtins.type\n     |      Make a new TestShortLogReport object from a sequence or iterable\n     |  \n     |  ----------------------------------------------------------------------\n     |  Static methods defined here:\n     |  \n     |  __new__(_cls, category: str, letter: str, word: Union[str, Tuple[str, Mapping[str, bool]]])\n     |      Create new instance of TestShortLogReport(category, letter, word)\n     |  \n     |  ----------------------------------------------------------------------\n     |  Data descriptors defined here:\n     |  \n     |  category\n     |      Alias for field number 0\n     |  \n     |  letter\n     |      Alias for field number 1\n     |  \n     |  word\n     |      Alias for field number 2\n     |  \n     |  ----------------------------------------------------------------------\n     |  Data and other attributes defined here:\n     |  \n     |  __annotations__ = {'category': <class 'str'>, 'letter': <class 'str'>,...\n     |  \n     |  __orig_bases__ = (<function NamedTuple>,)\n     |  \n     |  _field_defaults = {}\n     |  \n     |  _fields = ('category', 'letter', 'word')\n     |  \n     |  ----------------------------------------------------------------------\n     |  Methods inherited from builtins.tuple:\n     |  \n     |  __add__(self, value, /)\n     |      Return self+value.\n     |  \n     |  __contains__(self, key, /)\n     |      Return key in self.\n     |  \n     |  __eq__(self, value, /)\n     |      Return self==value.\n     |  \n     |  __ge__(self, value, /)\n     |      Return self>=value.\n     |  \n     |  __getattribute__(self, name, /)\n     |      Return getattr(self, name).\n     |  \n     |  __getitem__(self, key, /)\n     |      Return self[key].\n     |  \n     |  __gt__(self, value, /)\n     |      Return self>value.\n     |  \n     |  __hash__(self, /)\n     |      Return hash(self).\n     |  \n     |  __iter__(self, /)\n     |      Implement iter(self).\n     |  \n     |  __le__(self, value, /)\n     |      Return self<=value.\n     |  \n     |  __len__(self, /)\n     |      Return len(self).\n     |  \n     |  __lt__(self, value, /)\n     |      Return self<value.\n     |  \n     |  __mul__(self, value, /)\n     |      Return self*value.\n     |  \n     |  __ne__(self, value, /)\n     |      Return self!=value.\n     |  \n     |  __rmul__(self, value, /)\n     |      Return value*self.\n     |  \n     |  count(self, value, /)\n     |      Return number of occurrences of value.\n     |  \n     |  index(self, value, start=0, stop=9223372036854775807, /)\n     |      Return first index of value.\n     |      \n     |      Raises ValueError if the value is not present.\n     |  \n     |  ----------------------------------------------------------------------\n     |  Class methods inherited from builtins.tuple:\n     |  \n     |  __class_getitem__(...) from builtins.type\n     |      See PEP 585\n    \n    class Testdir(builtins.object)\n     |  Testdir(pytester: _pytest.pytester.Pytester, *, _ispytest: bool = False) -> None\n     |  \n     |  Similar to :class:`Pytester`, but this class works with legacy legacy_path objects instead.\n     |  \n     |  All methods just forward to an internal :class:`Pytester` instance, converting results\n     |  to `legacy_path` objects as necessary.\n     |  \n     |  Methods defined here:\n     |  \n     |  __init__(self, pytester: _pytest.pytester.Pytester, *, _ispytest: bool = False) -> None\n     |      Initialize self.  See help(type(self)) for accurate signature.\n     |  \n     |  __repr__(self) -> str\n     |      Return repr(self).\n     |  \n     |  __str__(self) -> str\n     |      Return str(self).\n     |  \n     |  chdir(self) -> None\n     |      See :meth:`Pytester.chdir`.\n     |  \n     |  collect_by_name(self, modcol: _pytest.nodes.Collector, name: str) -> Union[_pytest.nodes.Item, _pytest.nodes.Collector, NoneType]\n     |      See :meth:`Pytester.collect_by_name`.\n     |  \n     |  copy_example(self, name=None) -> _pytest._py.path.LocalPath\n     |      See :meth:`Pytester.copy_example`.\n     |  \n     |  finalize(self) -> None\n     |      See :meth:`Pytester._finalize`.\n     |  \n     |  genitems(self, colitems: List[Union[_pytest.nodes.Item, _pytest.nodes.Collector]]) -> List[_pytest.nodes.Item]\n     |      See :meth:`Pytester.genitems`.\n     |  \n     |  getinicfg(self, source: str) -> iniconfig.SectionWrapper\n     |      See :meth:`Pytester.getinicfg`.\n     |  \n     |  getitem(self, source, funcname='test_func')\n     |      See :meth:`Pytester.getitem`.\n     |  \n     |  getitems(self, source)\n     |      See :meth:`Pytester.getitems`.\n     |  \n     |  getmodulecol(self, source, configargs=(), withinit=False)\n     |      See :meth:`Pytester.getmodulecol`.\n     |  \n     |  getnode(self, config: _pytest.config.Config, arg) -> Union[_pytest.nodes.Item, _pytest.nodes.Collector, NoneType]\n     |      See :meth:`Pytester.getnode`.\n     |  \n     |  getpathnode(self, path)\n     |      See :meth:`Pytester.getpathnode`.\n     |  \n     |  inline_genitems(self, *args)\n     |      See :meth:`Pytester.inline_genitems`.\n     |  \n     |  inline_run(self, *args, plugins=(), no_reraise_ctrlc: bool = False)\n     |      See :meth:`Pytester.inline_run`.\n     |  \n     |  inline_runsource(self, source, *cmdlineargs)\n     |      See :meth:`Pytester.inline_runsource`.\n     |  \n     |  make_hook_recorder(self, pluginmanager) -> _pytest.pytester.HookRecorder\n     |      See :meth:`Pytester.make_hook_recorder`.\n     |  \n     |  makeconftest(self, source) -> _pytest._py.path.LocalPath\n     |      See :meth:`Pytester.makeconftest`.\n     |  \n     |  makefile(self, ext, *args, **kwargs) -> _pytest._py.path.LocalPath\n     |      See :meth:`Pytester.makefile`.\n     |  \n     |  makeini(self, source) -> _pytest._py.path.LocalPath\n     |      See :meth:`Pytester.makeini`.\n     |  \n     |  makepyfile(self, *args, **kwargs) -> _pytest._py.path.LocalPath\n     |      See :meth:`Pytester.makepyfile`.\n     |  \n     |  makepyprojecttoml(self, source) -> _pytest._py.path.LocalPath\n     |      See :meth:`Pytester.makepyprojecttoml`.\n     |  \n     |  maketxtfile(self, *args, **kwargs) -> _pytest._py.path.LocalPath\n     |      See :meth:`Pytester.maketxtfile`.\n     |  \n     |  mkdir(self, name) -> _pytest._py.path.LocalPath\n     |      See :meth:`Pytester.mkdir`.\n     |  \n     |  mkpydir(self, name) -> _pytest._py.path.LocalPath\n     |      See :meth:`Pytester.mkpydir`.\n     |  \n     |  parseconfig(self, *args) -> _pytest.config.Config\n     |      See :meth:`Pytester.parseconfig`.\n     |  \n     |  parseconfigure(self, *args) -> _pytest.config.Config\n     |      See :meth:`Pytester.parseconfigure`.\n     |  \n     |  popen(self, cmdargs, stdout=-1, stderr=-1, stdin=<NotSetType.token: 0>, **kw)\n     |      See :meth:`Pytester.popen`.\n     |  \n     |  run(self, *cmdargs, timeout=None, stdin=<NotSetType.token: 0>) -> _pytest.pytester.RunResult\n     |      See :meth:`Pytester.run`.\n     |  \n     |  runitem(self, source)\n     |      See :meth:`Pytester.runitem`.\n     |  \n     |  runpytest(self, *args, **kwargs) -> _pytest.pytester.RunResult\n     |      See :meth:`Pytester.runpytest`.\n     |  \n     |  runpytest_inprocess(self, *args, **kwargs) -> _pytest.pytester.RunResult\n     |      See :meth:`Pytester.runpytest_inprocess`.\n     |  \n     |  runpytest_subprocess(self, *args, timeout=None) -> _pytest.pytester.RunResult\n     |      See :meth:`Pytester.runpytest_subprocess`.\n     |  \n     |  runpython(self, script) -> _pytest.pytester.RunResult\n     |      See :meth:`Pytester.runpython`.\n     |  \n     |  runpython_c(self, command)\n     |      See :meth:`Pytester.runpython_c`.\n     |  \n     |  spawn(self, cmd: str, expect_timeout: float = 10.0) -> 'pexpect.spawn'\n     |      See :meth:`Pytester.spawn`.\n     |  \n     |  spawn_pytest(self, string: str, expect_timeout: float = 10.0) -> 'pexpect.spawn'\n     |      See :meth:`Pytester.spawn_pytest`.\n     |  \n     |  syspathinsert(self, path=None) -> None\n     |      See :meth:`Pytester.syspathinsert`.\n     |  \n     |  ----------------------------------------------------------------------\n     |  Readonly properties defined here:\n     |  \n     |  monkeypatch\n     |  \n     |  request\n     |  \n     |  test_tmproot\n     |  \n     |  tmpdir\n     |      Temporary directory where tests are executed.\n     |  \n     |  ----------------------------------------------------------------------\n     |  Data descriptors defined here:\n     |  \n     |  __dict__\n     |      dictionary for instance variables (if defined)\n     |  \n     |  __weakref__\n     |      list of weak references to the object (if defined)\n     |  \n     |  plugins\n     |  \n     |  ----------------------------------------------------------------------\n     |  Data and other attributes defined here:\n     |  \n     |  CLOSE_STDIN = <NotSetType.token: 0>\n     |  \n     |  TimeoutExpired = <class '_pytest.pytester.Pytester.TimeoutExpired'>\n     |  \n     |  __annotations__ = {'CLOSE_STDIN': 'Final', 'TimeoutExpired': 'Final'}\n     |  \n     |  __test__ = False\n    \n    class UsageError(builtins.Exception)\n     |  Error in pytest usage or invocation.\n     |  \n     |  Method resolution order:\n     |      UsageError\n     |      builtins.Exception\n     |      builtins.BaseException\n     |      builtins.object\n     |  \n     |  Data descriptors defined here:\n     |  \n     |  __weakref__\n     |      list of weak references to the object (if defined)\n     |  \n     |  ----------------------------------------------------------------------\n     |  Methods inherited from builtins.Exception:\n     |  \n     |  __init__(self, /, *args, **kwargs)\n     |      Initialize self.  See help(type(self)) for accurate signature.\n     |  \n     |  ----------------------------------------------------------------------\n     |  Static methods inherited from builtins.Exception:\n     |  \n     |  __new__(*args, **kwargs) from builtins.type\n     |      Create and return a new object.  See help(type) for accurate signature.\n     |  \n     |  ----------------------------------------------------------------------\n     |  Methods inherited from builtins.BaseException:\n     |  \n     |  __delattr__(self, name, /)\n     |      Implement delattr(self, name).\n     |  \n     |  __getattribute__(self, name, /)\n     |      Return getattr(self, name).\n     |  \n     |  __reduce__(...)\n     |      Helper for pickle.\n     |  \n     |  __repr__(self, /)\n     |      Return repr(self).\n     |  \n     |  __setattr__(self, name, value, /)\n     |      Implement setattr(self, name, value).\n     |  \n     |  __setstate__(...)\n     |  \n     |  __str__(self, /)\n     |      Return str(self).\n     |  \n     |  with_traceback(...)\n     |      Exception.with_traceback(tb) --\n     |      set self.__traceback__ to tb and return self.\n     |  \n     |  ----------------------------------------------------------------------\n     |  Data descriptors inherited from builtins.BaseException:\n     |  \n     |  __cause__\n     |      exception cause\n     |  \n     |  __context__\n     |      exception context\n     |  \n     |  __dict__\n     |  \n     |  __suppress_context__\n     |  \n     |  __traceback__\n     |  \n     |  args\n    \n    class WarningsRecorder(warnings.catch_warnings)\n     |  WarningsRecorder(*, _ispytest: bool = False) -> None\n     |  \n     |  A context manager to record raised warnings.\n     |  \n     |  Each recorded warning is an instance of :class:`warnings.WarningMessage`.\n     |  \n     |  Adapted from `warnings.catch_warnings`.\n     |  \n     |  .. note::\n     |      ``DeprecationWarning`` and ``PendingDeprecationWarning`` are treated\n     |      differently; see :ref:`ensuring_function_triggers`.\n     |  \n     |  Method resolution order:\n     |      WarningsRecorder\n     |      warnings.catch_warnings\n     |      builtins.object\n     |  \n     |  Methods defined here:\n     |  \n     |  __enter__(self) -> 'WarningsRecorder'\n     |      # Type ignored because it doesn't exactly warnings.catch_warnings.__enter__\n     |      # -- it returns a List but we only emulate one.\n     |  \n     |  __exit__(self, exc_type: Optional[Type[BaseException]], exc_val: Optional[BaseException], exc_tb: Optional[traceback]) -> None\n     |  \n     |  __getitem__(self, i: int) -> 'warnings.WarningMessage'\n     |      Get a recorded warning by index.\n     |  \n     |  __init__(self, *, _ispytest: bool = False) -> None\n     |      Specify whether to record warnings and if an alternative module\n     |      should be used other than sys.modules['warnings'].\n     |      \n     |      For compatibility with Python 3.0, please consider all arguments to be\n     |      keyword-only.\n     |  \n     |  __iter__(self) -> Iterator[ForwardRef('warnings.WarningMessage')]\n     |      Iterate through the recorded warnings.\n     |  \n     |  __len__(self) -> int\n     |      The number of recorded warnings.\n     |  \n     |  clear(self) -> None\n     |      Clear the list of recorded warnings.\n     |  \n     |  pop(self, cls: Type[Warning] = <class 'Warning'>) -> 'warnings.WarningMessage'\n     |      Pop the first recorded warning, raise exception if not exists.\n     |  \n     |  ----------------------------------------------------------------------\n     |  Readonly properties defined here:\n     |  \n     |  list\n     |      The list of recorded warnings.\n     |  \n     |  ----------------------------------------------------------------------\n     |  Methods inherited from warnings.catch_warnings:\n     |  \n     |  __repr__(self)\n     |      Return repr(self).\n     |  \n     |  ----------------------------------------------------------------------\n     |  Data descriptors inherited from warnings.catch_warnings:\n     |  \n     |  __dict__\n     |      dictionary for instance variables (if defined)\n     |  \n     |  __weakref__\n     |      list of weak references to the object (if defined)\n    \n    class cmdline(builtins.object)\n     |  Static methods defined here:\n     |  \n     |  main(args: Union[List[str], ForwardRef('os.PathLike[str]'), NoneType] = None, plugins: Optional[Sequence[Union[str, object]]] = None) -> Union[int, _pytest.config.ExitCode]\n     |      Perform an in-process test run.\n     |      \n     |      :param args: List of command line arguments.\n     |      :param plugins: List of plugin objects to be auto-registered during initialization.\n     |      \n     |      :returns: An exit code.\n     |  \n     |  ----------------------------------------------------------------------\n     |  Data descriptors defined here:\n     |  \n     |  __dict__\n     |      dictionary for instance variables (if defined)\n     |  \n     |  __weakref__\n     |      list of weak references to the object (if defined)\n\nFUNCTIONS\n    __getattr__(name: str) -> object\n    \n    approx(expected, rel=None, abs=None, nan_ok: bool = False) -> _pytest.python_api.ApproxBase\n        Assert that two numbers (or two ordered sequences of numbers) are equal to each other\n        within some tolerance.\n        \n        Due to the :doc:`python:tutorial/floatingpoint`, numbers that we\n        would intuitively expect to be equal are not always so::\n        \n            >>> 0.1 + 0.2 == 0.3\n            False\n        \n        This problem is commonly encountered when writing tests, e.g. when making\n        sure that floating-point values are what you expect them to be.  One way to\n        deal with this problem is to assert that two floating-point numbers are\n        equal to within some appropriate tolerance::\n        \n            >>> abs((0.1 + 0.2) - 0.3) < 1e-6\n            True\n        \n        However, comparisons like this are tedious to write and difficult to\n        understand.  Furthermore, absolute comparisons like the one above are\n        usually discouraged because there's no tolerance that works well for all\n        situations.  ``1e-6`` is good for numbers around ``1``, but too small for\n        very big numbers and too big for very small ones.  It's better to express\n        the tolerance as a fraction of the expected value, but relative comparisons\n        like that are even more difficult to write correctly and concisely.\n        \n        The ``approx`` class performs floating-point comparisons using a syntax\n        that's as intuitive as possible::\n        \n            >>> from pytest import approx\n            >>> 0.1 + 0.2 == approx(0.3)\n            True\n        \n        The same syntax also works for ordered sequences of numbers::\n        \n            >>> (0.1 + 0.2, 0.2 + 0.4) == approx((0.3, 0.6))\n            True\n        \n        ``numpy`` arrays::\n        \n            >>> import numpy as np                                                          # doctest: +SKIP\n            >>> np.array([0.1, 0.2]) + np.array([0.2, 0.4]) == approx(np.array([0.3, 0.6])) # doctest: +SKIP\n            True\n        \n        And for a ``numpy`` array against a scalar::\n        \n            >>> import numpy as np                                         # doctest: +SKIP\n            >>> np.array([0.1, 0.2]) + np.array([0.2, 0.1]) == approx(0.3) # doctest: +SKIP\n            True\n        \n        Only ordered sequences are supported, because ``approx`` needs\n        to infer the relative position of the sequences without ambiguity. This means\n        ``sets`` and other unordered sequences are not supported.\n        \n        Finally, dictionary *values* can also be compared::\n        \n            >>> {'a': 0.1 + 0.2, 'b': 0.2 + 0.4} == approx({'a': 0.3, 'b': 0.6})\n            True\n        \n        The comparison will be true if both mappings have the same keys and their\n        respective values match the expected tolerances.\n        \n        **Tolerances**\n        \n        By default, ``approx`` considers numbers within a relative tolerance of\n        ``1e-6`` (i.e. one part in a million) of its expected value to be equal.\n        This treatment would lead to surprising results if the expected value was\n        ``0.0``, because nothing but ``0.0`` itself is relatively close to ``0.0``.\n        To handle this case less surprisingly, ``approx`` also considers numbers\n        within an absolute tolerance of ``1e-12`` of its expected value to be\n        equal.  Infinity and NaN are special cases.  Infinity is only considered\n        equal to itself, regardless of the relative tolerance.  NaN is not\n        considered equal to anything by default, but you can make it be equal to\n        itself by setting the ``nan_ok`` argument to True.  (This is meant to\n        facilitate comparing arrays that use NaN to mean \"no data\".)\n        \n        Both the relative and absolute tolerances can be changed by passing\n        arguments to the ``approx`` constructor::\n        \n            >>> 1.0001 == approx(1)\n            False\n            >>> 1.0001 == approx(1, rel=1e-3)\n            True\n            >>> 1.0001 == approx(1, abs=1e-3)\n            True\n        \n        If you specify ``abs`` but not ``rel``, the comparison will not consider\n        the relative tolerance at all.  In other words, two numbers that are within\n        the default relative tolerance of ``1e-6`` will still be considered unequal\n        if they exceed the specified absolute tolerance.  If you specify both\n        ``abs`` and ``rel``, the numbers will be considered equal if either\n        tolerance is met::\n        \n            >>> 1 + 1e-8 == approx(1)\n            True\n            >>> 1 + 1e-8 == approx(1, abs=1e-12)\n            False\n            >>> 1 + 1e-8 == approx(1, rel=1e-6, abs=1e-12)\n            True\n        \n        You can also use ``approx`` to compare nonnumeric types, or dicts and\n        sequences containing nonnumeric types, in which case it falls back to\n        strict equality. This can be useful for comparing dicts and sequences that\n        can contain optional values::\n        \n            >>> {\"required\": 1.0000005, \"optional\": None} == approx({\"required\": 1, \"optional\": None})\n            True\n            >>> [None, 1.0000005] == approx([None,1])\n            True\n            >>> [\"foo\", 1.0000005] == approx([None,1])\n            False\n        \n        If you're thinking about using ``approx``, then you might want to know how\n        it compares to other good ways of comparing floating-point numbers.  All of\n        these algorithms are based on relative and absolute tolerances and should\n        agree for the most part, but they do have meaningful differences:\n        \n        - ``math.isclose(a, b, rel_tol=1e-9, abs_tol=0.0)``:  True if the relative\n          tolerance is met w.r.t. either ``a`` or ``b`` or if the absolute\n          tolerance is met.  Because the relative tolerance is calculated w.r.t.\n          both ``a`` and ``b``, this test is symmetric (i.e.  neither ``a`` nor\n          ``b`` is a \"reference value\").  You have to specify an absolute tolerance\n          if you want to compare to ``0.0`` because there is no tolerance by\n          default.  More information: :py:func:`math.isclose`.\n        \n        - ``numpy.isclose(a, b, rtol=1e-5, atol=1e-8)``: True if the difference\n          between ``a`` and ``b`` is less that the sum of the relative tolerance\n          w.r.t. ``b`` and the absolute tolerance.  Because the relative tolerance\n          is only calculated w.r.t. ``b``, this test is asymmetric and you can\n          think of ``b`` as the reference value.  Support for comparing sequences\n          is provided by :py:func:`numpy.allclose`.  More information:\n          :std:doc:`numpy:reference/generated/numpy.isclose`.\n        \n        - ``unittest.TestCase.assertAlmostEqual(a, b)``: True if ``a`` and ``b``\n          are within an absolute tolerance of ``1e-7``.  No relative tolerance is\n          considered , so this function is not appropriate for very large or very\n          small numbers.  Also, it's only available in subclasses of ``unittest.TestCase``\n          and it's ugly because it doesn't follow PEP8.  More information:\n          :py:meth:`unittest.TestCase.assertAlmostEqual`.\n        \n        - ``a == pytest.approx(b, rel=1e-6, abs=1e-12)``: True if the relative\n          tolerance is met w.r.t. ``b`` or if the absolute tolerance is met.\n          Because the relative tolerance is only calculated w.r.t. ``b``, this test\n          is asymmetric and you can think of ``b`` as the reference value.  In the\n          special case that you explicitly specify an absolute tolerance but not a\n          relative tolerance, only the absolute tolerance is considered.\n        \n        .. note::\n        \n            ``approx`` can handle numpy arrays, but we recommend the\n            specialised test helpers in :std:doc:`numpy:reference/routines.testing`\n            if you need support for comparisons, NaNs, or ULP-based tolerances.\n        \n            To match strings using regex, you can use\n            `Matches <https://github.com/asottile/re-assert#re_assertmatchespattern-str-args-kwargs>`_\n            from the\n            `re_assert package <https://github.com/asottile/re-assert>`_.\n        \n        .. warning::\n        \n           .. versionchanged:: 3.2\n        \n           In order to avoid inconsistent behavior, :py:exc:`TypeError` is\n           raised for ``>``, ``>=``, ``<`` and ``<=`` comparisons.\n           The example below illustrates the problem::\n        \n               assert approx(0.1) > 0.1 + 1e-10  # calls approx(0.1).__gt__(0.1 + 1e-10)\n               assert 0.1 + 1e-10 > approx(0.1)  # calls approx(0.1).__lt__(0.1 + 1e-10)\n        \n           In the second example one expects ``approx(0.1).__le__(0.1 + 1e-10)``\n           to be called. But instead, ``approx(0.1).__lt__(0.1 + 1e-10)`` is used to\n           comparison. This is because the call hierarchy of rich comparisons\n           follows a fixed behavior. More information: :py:meth:`object.__ge__`\n        \n        .. versionchanged:: 3.7.1\n           ``approx`` raises ``TypeError`` when it encounters a dict value or\n           sequence element of nonnumeric type.\n        \n        .. versionchanged:: 6.1.0\n           ``approx`` falls back to strict equality for nonnumeric types instead\n           of raising ``TypeError``.\n    \n    console_main() -> int\n        The CLI entry point of pytest.\n        \n        This function is not meant for programmable use; use `main()` instead.\n    \n    deprecated_call(func: Optional[Callable[..., Any]] = None, *args: Any, **kwargs: Any) -> Union[ForwardRef('WarningsRecorder'), Any]\n        Assert that code produces a ``DeprecationWarning`` or ``PendingDeprecationWarning``.\n        \n        This function can be used as a context manager::\n        \n            >>> import warnings\n            >>> def api_call_v2():\n            ...     warnings.warn('use v3 of this api', DeprecationWarning)\n            ...     return 200\n        \n            >>> import pytest\n            >>> with pytest.deprecated_call():\n            ...    assert api_call_v2() == 200\n        \n        It can also be used by passing a function and ``*args`` and ``**kwargs``,\n        in which case it will ensure calling ``func(*args, **kwargs)`` produces one of\n        the warnings types above. The return value is the return value of the function.\n        \n        In the context manager form you may use the keyword argument ``match`` to assert\n        that the warning matches a text or regex.\n        \n        The context manager produces a list of :class:`warnings.WarningMessage` objects,\n        one for each warning raised.\n    \n    exit(reason: str = '', returncode: Optional[int] = None, *, msg: Optional[str] = None) -> NoReturn\n        Exit testing process.\n        \n        :param reason:\n            The message to show as the reason for exiting pytest.  reason has a default value\n            only because `msg` is deprecated.\n        \n        :param returncode:\n            Return code to be used when exiting pytest.\n        \n        :param msg:\n            Same as ``reason``, but deprecated. Will be removed in a future version, use ``reason`` instead.\n    \n    fail(reason: str = '', pytrace: bool = True, msg: Optional[str] = None) -> NoReturn\n        Explicitly fail an executing test with the given message.\n        \n        :param reason:\n            The message to show the user as reason for the failure.\n        \n        :param pytrace:\n            If False, msg represents the full failure information and no\n            python traceback will be reported.\n        \n        :param msg:\n            Same as ``reason``, but deprecated. Will be removed in a future version, use ``reason`` instead.\n    \n    fixture(fixture_function: Optional[~FixtureFunction] = None, *, scope: 'Union[_ScopeName, Callable[[str, Config], _ScopeName]]' = 'function', params: Optional[Iterable[object]] = None, autouse: bool = False, ids: Union[Sequence[Optional[object]], Callable[[Any], Optional[object]], NoneType] = None, name: Optional[str] = None) -> Union[_pytest.fixtures.FixtureFunctionMarker, ~FixtureFunction]\n        Decorator to mark a fixture factory function.\n        \n        This decorator can be used, with or without parameters, to define a\n        fixture function.\n        \n        The name of the fixture function can later be referenced to cause its\n        invocation ahead of running tests: test modules or classes can use the\n        ``pytest.mark.usefixtures(fixturename)`` marker.\n        \n        Test functions can directly use fixture names as input arguments in which\n        case the fixture instance returned from the fixture function will be\n        injected.\n        \n        Fixtures can provide their values to test functions using ``return`` or\n        ``yield`` statements. When using ``yield`` the code block after the\n        ``yield`` statement is executed as teardown code regardless of the test\n        outcome, and must yield exactly once.\n        \n        :param scope:\n            The scope for which this fixture is shared; one of ``\"function\"``\n            (default), ``\"class\"``, ``\"module\"``, ``\"package\"`` or ``\"session\"``.\n        \n            This parameter may also be a callable which receives ``(fixture_name, config)``\n            as parameters, and must return a ``str`` with one of the values mentioned above.\n        \n            See :ref:`dynamic scope` in the docs for more information.\n        \n        :param params:\n            An optional list of parameters which will cause multiple invocations\n            of the fixture function and all of the tests using it. The current\n            parameter is available in ``request.param``.\n        \n        :param autouse:\n            If True, the fixture func is activated for all tests that can see it.\n            If False (the default), an explicit reference is needed to activate\n            the fixture.\n        \n        :param ids:\n            Sequence of ids each corresponding to the params so that they are\n            part of the test id. If no ids are provided they will be generated\n            automatically from the params.\n        \n        :param name:\n            The name of the fixture. This defaults to the name of the decorated\n            function. If a fixture is used in the same module in which it is\n            defined, the function name of the fixture will be shadowed by the\n            function arg that requests the fixture; one way to resolve this is to\n            name the decorated function ``fixture_<fixturename>`` and then use\n            ``@pytest.fixture(name='<fixturename>')``.\n    \n    freeze_includes() -> List[str]\n        Return a list of module names used by pytest that should be\n        included by cx_freeze.\n    \n    importorskip(modname: str, minversion: Optional[str] = None, reason: Optional[str] = None) -> Any\n        Import and return the requested module ``modname``, or skip the\n        current test if the module cannot be imported.\n        \n        :param modname:\n            The name of the module to import.\n        :param minversion:\n            If given, the imported module's ``__version__`` attribute must be at\n            least this minimal version, otherwise the test is still skipped.\n        :param reason:\n            If given, this reason is shown as the message when the module cannot\n            be imported.\n        \n        :returns:\n            The imported module. This should be assigned to its canonical name.\n        \n        Example::\n        \n            docutils = pytest.importorskip(\"docutils\")\n    \n    main(args: Union[List[str], ForwardRef('os.PathLike[str]'), NoneType] = None, plugins: Optional[Sequence[Union[str, object]]] = None) -> Union[int, _pytest.config.ExitCode]\n        Perform an in-process test run.\n        \n        :param args: List of command line arguments.\n        :param plugins: List of plugin objects to be auto-registered during initialization.\n        \n        :returns: An exit code.\n    \n    param(*values: object, marks: Union[_pytest.mark.structures.MarkDecorator, Collection[Union[_pytest.mark.structures.MarkDecorator, _pytest.mark.structures.Mark]]] = (), id: Optional[str] = None) -> _pytest.mark.structures.ParameterSet\n        Specify a parameter in `pytest.mark.parametrize`_ calls or\n        :ref:`parametrized fixtures <fixture-parametrize-marks>`.\n        \n        .. code-block:: python\n        \n            @pytest.mark.parametrize(\n                \"test_input,expected\",\n                [\n                    (\"3+5\", 8),\n                    pytest.param(\"6*9\", 42, marks=pytest.mark.xfail),\n                ],\n            )\n            def test_eval(test_input, expected):\n                assert eval(test_input) == expected\n        \n        :param values: Variable args of the values of the parameter set, in order.\n        :param marks: A single mark or a list of marks to be applied to this parameter set.\n        :param id: The id to attribute to this parameter set.\n    \n    raises(expected_exception: Union[Type[~E], Tuple[Type[~E], ...]], *args: Any, **kwargs: Any) -> Union[ForwardRef('RaisesContext[E]'), _pytest._code.code.ExceptionInfo[~E]]\n        Assert that a code block/function call raises an exception.\n        \n        :param typing.Type[E] | typing.Tuple[typing.Type[E], ...] expected_exception:\n            The expected exception type, or a tuple if one of multiple possible\n            exception types are expected.\n        :kwparam str | typing.Pattern[str] | None match:\n            If specified, a string containing a regular expression,\n            or a regular expression object, that is tested against the string\n            representation of the exception using :func:`re.search`.\n        \n            To match a literal string that may contain :ref:`special characters\n            <re-syntax>`, the pattern can first be escaped with :func:`re.escape`.\n        \n            (This is only used when :py:func:`pytest.raises` is used as a context manager,\n            and passed through to the function otherwise.\n            When using :py:func:`pytest.raises` as a function, you can use:\n            ``pytest.raises(Exc, func, match=\"passed on\").match(\"my pattern\")``.)\n        \n        .. currentmodule:: _pytest._code\n        \n        Use ``pytest.raises`` as a context manager, which will capture the exception of the given\n        type::\n        \n            >>> import pytest\n            >>> with pytest.raises(ZeroDivisionError):\n            ...    1/0\n        \n        If the code block does not raise the expected exception (``ZeroDivisionError`` in the example\n        above), or no exception at all, the check will fail instead.\n        \n        You can also use the keyword argument ``match`` to assert that the\n        exception matches a text or regex::\n        \n            >>> with pytest.raises(ValueError, match='must be 0 or None'):\n            ...     raise ValueError(\"value must be 0 or None\")\n        \n            >>> with pytest.raises(ValueError, match=r'must be \\d+$'):\n            ...     raise ValueError(\"value must be 42\")\n        \n        The context manager produces an :class:`ExceptionInfo` object which can be used to inspect the\n        details of the captured exception::\n        \n            >>> with pytest.raises(ValueError) as exc_info:\n            ...     raise ValueError(\"value must be 42\")\n            >>> assert exc_info.type is ValueError\n            >>> assert exc_info.value.args[0] == \"value must be 42\"\n        \n        .. note::\n        \n           When using ``pytest.raises`` as a context manager, it's worthwhile to\n           note that normal context manager rules apply and that the exception\n           raised *must* be the final line in the scope of the context manager.\n           Lines of code after that, within the scope of the context manager will\n           not be executed. For example::\n        \n               >>> value = 15\n               >>> with pytest.raises(ValueError) as exc_info:\n               ...     if value > 10:\n               ...         raise ValueError(\"value must be <= 10\")\n               ...     assert exc_info.type is ValueError  # this will not execute\n        \n           Instead, the following approach must be taken (note the difference in\n           scope)::\n        \n               >>> with pytest.raises(ValueError) as exc_info:\n               ...     if value > 10:\n               ...         raise ValueError(\"value must be <= 10\")\n               ...\n               >>> assert exc_info.type is ValueError\n        \n        **Using with** ``pytest.mark.parametrize``\n        \n        When using :ref:`pytest.mark.parametrize ref`\n        it is possible to parametrize tests such that\n        some runs raise an exception and others do not.\n        \n        See :ref:`parametrizing_conditional_raising` for an example.\n        \n        **Legacy form**\n        \n        It is possible to specify a callable by passing a to-be-called lambda::\n        \n            >>> raises(ZeroDivisionError, lambda: 1/0)\n            <ExceptionInfo ...>\n        \n        or you can specify an arbitrary callable with arguments::\n        \n            >>> def f(x): return 1/x\n            ...\n            >>> raises(ZeroDivisionError, f, 0)\n            <ExceptionInfo ...>\n            >>> raises(ZeroDivisionError, f, x=0)\n            <ExceptionInfo ...>\n        \n        The form above is fully supported but discouraged for new code because the\n        context manager form is regarded as more readable and less error-prone.\n        \n        .. note::\n            Similar to caught exception objects in Python, explicitly clearing\n            local references to returned ``ExceptionInfo`` objects can\n            help the Python interpreter speed up its garbage collection.\n        \n            Clearing those references breaks a reference cycle\n            (``ExceptionInfo`` --> caught exception --> frame stack raising\n            the exception --> current frame stack --> local variables -->\n            ``ExceptionInfo``) which makes Python keep all objects referenced\n            from that cycle (including all local variables in the current\n            frame) alive until the next cyclic garbage collection run.\n            More detailed information can be found in the official Python\n            documentation for :ref:`the try statement <python:try>`.\n    \n    register_assert_rewrite(*names: str) -> None\n        Register one or more module names to be rewritten on import.\n        \n        This function will make sure that this module or all modules inside\n        the package will get their assert statements rewritten.\n        Thus you should make sure to call this before the module is\n        actually imported, usually in your __init__.py if you are a plugin\n        using a package.\n        \n        :param names: The module names to register.\n    \n    set_trace(*args, **kwargs) -> None method of builtins.type instance\n        Invoke debugging via ``Pdb.set_trace``, dropping any IO capturing.\n    \n    skip(reason: str = '', *, allow_module_level: bool = False, msg: Optional[str] = None) -> NoReturn\n        Skip an executing test with the given message.\n        \n        This function should be called only during testing (setup, call or teardown) or\n        during collection by using the ``allow_module_level`` flag.  This function can\n        be called in doctests as well.\n        \n        :param reason:\n            The message to show the user as reason for the skip.\n        \n        :param allow_module_level:\n            Allows this function to be called at module level.\n            Raising the skip exception at module level will stop\n            the execution of the module and prevent the collection of all tests in the module,\n            even those defined before the `skip` call.\n        \n            Defaults to False.\n        \n        :param msg:\n            Same as ``reason``, but deprecated. Will be removed in a future version, use ``reason`` instead.\n        \n        .. note::\n            It is better to use the :ref:`pytest.mark.skipif ref` marker when\n            possible to declare a test to be skipped under certain conditions\n            like mismatching platforms or dependencies.\n            Similarly, use the ``# doctest: +SKIP`` directive (see :py:data:`doctest.SKIP`)\n            to skip a doctest statically.\n    \n    warns(expected_warning: Union[Type[Warning], Tuple[Type[Warning], ...]] = <class 'Warning'>, *args: Any, match: Union[str, Pattern[str], NoneType] = None, **kwargs: Any) -> Union[ForwardRef('WarningsChecker'), Any]\n        Assert that code raises a particular class of warning.\n        \n        Specifically, the parameter ``expected_warning`` can be a warning class or sequence\n        of warning classes, and the code inside the ``with`` block must issue at least one\n        warning of that class or classes.\n        \n        This helper produces a list of :class:`warnings.WarningMessage` objects, one for\n        each warning emitted (regardless of whether it is an ``expected_warning`` or not).\n        Since pytest 8.0, unmatched warnings are also re-emitted when the context closes.\n        \n        This function can be used as a context manager::\n        \n            >>> import pytest\n            >>> with pytest.warns(RuntimeWarning):\n            ...    warnings.warn(\"my warning\", RuntimeWarning)\n        \n        In the context manager form you may use the keyword argument ``match`` to assert\n        that the warning matches a text or regex::\n        \n            >>> with pytest.warns(UserWarning, match='must be 0 or None'):\n            ...     warnings.warn(\"value must be 0 or None\", UserWarning)\n        \n            >>> with pytest.warns(UserWarning, match=r'must be \\d+$'):\n            ...     warnings.warn(\"value must be 42\", UserWarning)\n        \n            >>> with pytest.warns(UserWarning):  # catch re-emitted warning\n            ...     with pytest.warns(UserWarning, match=r'must be \\d+$'):\n            ...         warnings.warn(\"this is not here\", UserWarning)\n            Traceback (most recent call last):\n              ...\n            Failed: DID NOT WARN. No warnings of type ...UserWarning... were emitted...\n        \n        **Using with** ``pytest.mark.parametrize``\n        \n        When using :ref:`pytest.mark.parametrize ref` it is possible to parametrize tests\n        such that some runs raise a warning and others do not.\n        \n        This could be achieved in the same way as with exceptions, see\n        :ref:`parametrizing_conditional_raising` for an example.\n    \n    xfail(reason: str = '') -> NoReturn\n        Imperatively xfail an executing test or setup function with the given reason.\n        \n        This function should be called only during testing (setup, call or teardown).\n        \n        :param reason:\n            The message to show the user as reason for the xfail.\n        \n        .. note::\n            It is better to use the :ref:`pytest.mark.xfail ref` marker when\n            possible to declare a test to be xfailed under certain conditions\n            like known bugs or missing features.\n    \n    yield_fixture(fixture_function=None, *args, scope='function', params=None, autouse=False, ids=None, name=None)\n        (Return a) decorator to mark a yield-fixture factory function.\n        \n        .. deprecated:: 3.0\n            Use :py:func:`pytest.fixture` directly instead.\n\nDATA\n    __all__ = ['__version__', 'approx', 'Cache', 'CallInfo', 'CaptureFixtu...\n    hookimpl = <pluggy._hooks.HookimplMarker object>\n    hookspec = <pluggy._hooks.HookspecMarker object>\n    mark = <_pytest.mark.structures.MarkGenerator object>\n    version_tuple = (8, 0, 0, 'dev46', 'g2f7415cfb.d20220101')\n\nVERSION\n    8.0.0.dev46+g2f7415cfb.d20220101\n\nFILE\n    /testbed/src/pytest/__init__.py\n\n\n________________ TestInvocationVariants.test_import_star_pytest ________________\n----------------------------- Captured stdout call -----------------------------\nrunning: /opt/miniconda3/envs/testbed/bin/python /tmp/pytest-of-root/pytest-0/test_import_star_pytest0/test_import_star_pytest.py\n     in: /tmp/pytest-of-root/pytest-0/test_import_star_pytest0\n_______________ TestInvocationVariants.test_double_pytestcmdline _______________\n----------------------------- Captured stdout call -----------------------------\nrunning: /opt/miniconda3/envs/testbed/bin/python /tmp/pytest-of-root/pytest-0/test_double_pytestcmdline0/run.py\n     in: /tmp/pytest-of-root/pytest-0/test_double_pytestcmdline0\n============================= test session starts ==============================\nplatform linux -- Python 3.9.20, pytest-8.0.0.dev46+g2f7415cfb.d20220101, pluggy-1.3.0\nrootdir: /tmp/pytest-of-root/pytest-0/test_double_pytestcmdline0\ncollected 1 item\n\ntest_double_pytestcmdline.py .                                           [100%]\n\n============================== 1 passed in 0.00s ===============================\n============================= test session starts ==============================\nplatform linux -- Python 3.9.20, pytest-8.0.0.dev46+g2f7415cfb.d20220101, pluggy-1.3.0\nrootdir: /tmp/pytest-of-root/pytest-0/test_double_pytestcmdline0\ncollected 1 item\n\ntest_double_pytestcmdline.py .                                           [100%]\n\n============================== 1 passed in 0.00s ===============================\n___________ TestInvocationVariants.test_python_minus_m_invocation_ok ___________\n----------------------------- Captured stdout call -----------------------------\nrunning: /opt/miniconda3/envs/testbed/bin/python -m pytest /tmp/pytest-of-root/pytest-0/test_python_minus_m_invocation_ok0/test_python_minus_m_invocation_ok.py\n     in: /tmp/pytest-of-root/pytest-0/test_python_minus_m_invocation_ok0\n============================= test session starts ==============================\nplatform linux -- Python 3.9.20, pytest-8.0.0.dev46+g2f7415cfb.d20220101, pluggy-1.3.0\nrootdir: /tmp/pytest-of-root/pytest-0/test_python_minus_m_invocation_ok0\ncollected 1 item\n\ntest_python_minus_m_invocation_ok.py .                                   [100%]\n\n============================== 1 passed in 0.00s ===============================\n__________ TestInvocationVariants.test_python_minus_m_invocation_fail __________\n----------------------------- Captured stdout call -----------------------------\nrunning: /opt/miniconda3/envs/testbed/bin/python -m pytest /tmp/pytest-of-root/pytest-0/test_python_minus_m_invocation_fail0/test_python_minus_m_invocation_fail.py\n     in: /tmp/pytest-of-root/pytest-0/test_python_minus_m_invocation_fail0\n============================= test session starts ==============================\nplatform linux -- Python 3.9.20, pytest-8.0.0.dev46+g2f7415cfb.d20220101, pluggy-1.3.0\nrootdir: /tmp/pytest-of-root/pytest-0/test_python_minus_m_invocation_fail0\ncollected 1 item\n\ntest_python_minus_m_invocation_fail.py F                                 [100%]\n\n=================================== FAILURES ===================================\n__________________________________ test_fail ___________________________________\n\n>   def test_fail(): 0/0\nE   ZeroDivisionError: division by zero\n\ntest_python_minus_m_invocation_fail.py:1: ZeroDivisionError\n=========================== short test summary info ============================\nFAILED test_python_minus_m_invocation_fail.py::test_fail - ZeroDivisionError:...\n============================== 1 failed in 0.01s ===============================\n______________ TestInvocationVariants.test_python_pytest_package _______________\n----------------------------- Captured stdout call -----------------------------\nrunning: /opt/miniconda3/envs/testbed/bin/python -m pytest /tmp/pytest-of-root/pytest-0/test_python_pytest_package0/test_python_pytest_package.py\n     in: /tmp/pytest-of-root/pytest-0/test_python_pytest_package0\n============================= test session starts ==============================\nplatform linux -- Python 3.9.20, pytest-8.0.0.dev46+g2f7415cfb.d20220101, pluggy-1.3.0\nrootdir: /tmp/pytest-of-root/pytest-0/test_python_pytest_package0\ncollected 1 item\n\ntest_python_pytest_package.py .                                          [100%]\n\n============================== 1 passed in 0.00s ===============================\n________________ TestInvocationVariants.test_pyargs_importerror ________________\n----------------------------- Captured stdout call -----------------------------\n============================= test session starts ==============================\nplatform linux -- Python 3.9.20, pytest-8.0.0.dev46+g2f7415cfb.d20220101, pluggy-1.3.0\nrootdir: /tmp/pytest-of-root/pytest-0/test_pyargs_importerror0\ncollected 0 items / 1 error\n\n==================================== ERRORS ====================================\n_____________________ ERROR collecting tpkg/test_hello.py ______________________\nImportError while importing test module '/tmp/pytest-of-root/pytest-0/test_pyargs_importerror0/tpkg/test_hello.py'.\nHint: make sure your test modules/packages have valid Python names.\nTraceback:\n/opt/miniconda3/envs/testbed/lib/python3.9/importlib/__init__.py:127: in import_module\n    return _bootstrap._gcd_import(name[level:], package, level)\ntpkg/test_hello.py:1: in <module>\n    raise ImportError\nE   ImportError\n=========================== short test summary info ============================\nERROR tpkg/test_hello.py\n!!!!!!!!!!!!!!!!!!!! Interrupted: 1 error during collection !!!!!!!!!!!!!!!!!!!!\n=============================== 1 error in 0.04s ===============================\n____________ TestInvocationVariants.test_pyargs_only_imported_once _____________\n----------------------------- Captured stdout call -----------------------------\n============================= test session starts ==============================\nplatform linux -- Python 3.9.20, pytest-8.0.0.dev46+g2f7415cfb.d20220101, pluggy-1.3.0\nrootdir: /tmp/pytest-of-root/pytest-0/test_pyargs_only_imported_once0\nconfiguring\nhello from test_foo\ncollected 1 item\n\nfoo/test_foo.py .\n\n============================== 1 passed in 0.01s ===============================\n________ TestInvocationVariants.test_pyargs_filename_looks_like_module _________\n----------------------------- Captured stdout call -----------------------------\n============================= test session starts ==============================\nplatform linux -- Python 3.9.20, pytest-8.0.0.dev46+g2f7415cfb.d20220101, pluggy-1.3.0\nrootdir: /tmp/pytest-of-root/pytest-0/test_pyargs_filename_looks_like_module0\ncollected 1 item\n\nt.py .                                                                   [100%]\n\n============================== 1 passed in 0.00s ===============================\n______________ TestInvocationVariants.test_cmdline_python_package ______________\n----------------------------- Captured stdout call -----------------------------\n============================= test session starts ==============================\nplatform linux -- Python 3.9.20, pytest-8.0.0.dev46+g2f7415cfb.d20220101, pluggy-1.3.0\nrootdir: /tmp/pytest-of-root/pytest-0/test_cmdline_python_package0\ncollected 2 items\n\ntpkg/test_hello.py .                                                     [ 50%]\ntpkg/test_world.py .                                                     [100%]\n\n============================== 2 passed in 0.01s ===============================\n============================= test session starts ==============================\nplatform linux -- Python 3.9.20, pytest-8.0.0.dev46+g2f7415cfb.d20220101, pluggy-1.3.0\nrootdir: /tmp/pytest-of-root/pytest-0/test_cmdline_python_package0\ncollected 1 item\n\ntpkg/test_hello.py .                                                     [100%]\n\n============================== 1 passed in 0.00s ===============================\n============================= test session starts ==============================\nplatform linux -- Python 3.9.20, pytest-8.0.0.dev46+g2f7415cfb.d20220101, pluggy-1.3.0\nrootdir: /tmp/pytest-of-root/pytest-0/test_cmdline_python_package0\ncollected 2 items\n\ntpkg/test_hello.py .                                                     [ 50%]\ntpkg/test_world.py .                                                     [100%]\n\n============================== 2 passed in 0.01s ===============================\n============================= test session starts ==============================\nplatform linux -- Python 3.9.20, pytest-8.0.0.dev46+g2f7415cfb.d20220101, pluggy-1.3.0\nrootdir: /tmp/pytest-of-root/pytest-0/test_cmdline_python_package0\ncollected 0 items\n\n============================ no tests ran in 0.00s =============================\n----------------------------- Captured stderr call -----------------------------\nERROR: module or package not found: tpkg.test_missing (missing __init__.py?)\n\n_________ TestInvocationVariants.test_cmdline_python_namespace_package _________\n----------------------------- Captured stdout call -----------------------------\n============================= test session starts ==============================\nplatform linux -- Python 3.9.20, pytest-8.0.0.dev46+g2f7415cfb.d20220101, pluggy-1.3.0 -- /opt/miniconda3/envs/testbed/bin/python\ncachedir: .pytest_cache\nrootdir: /tmp/pytest-of-root/pytest-0/test_cmdline_python_namespace_package0/world\ncollecting ... collected 4 items\n\ntest_hello.py::test_hello PASSED                                         [ 25%]\ntest_hello.py::test_other PASSED                                         [ 50%]\nns_pkg/world/test_world.py::test_world PASSED                            [ 75%]\nns_pkg/world/test_world.py::test_other PASSED                            [100%]\n\n============================== 4 passed in 0.07s ===============================\n============================= test session starts ==============================\nplatform linux -- Python 3.9.20, pytest-8.0.0.dev46+g2f7415cfb.d20220101, pluggy-1.3.0 -- /opt/miniconda3/envs/testbed/bin/python\ncachedir: .pytest_cache\nrootdir: /tmp/pytest-of-root/pytest-0/test_cmdline_python_namespace_package0\ncollecting ... collected 1 item\n\nworld/ns_pkg/world/test_world.py::test_other PASSED                      [100%]\n\n=============================== warnings summary ===============================\nworld/ns_pkg/__init__.py:1\n  /tmp/pytest-of-root/pytest-0/test_cmdline_python_namespace_package0/world/ns_pkg/__init__.py:1: DeprecationWarning: pkg_resources is deprecated as an API. See https://setuptools.pypa.io/en/latest/pkg_resources.html\n    __import__('pkg_resources').declare_namespace(__name__)\n\nworld/ns_pkg/__init__.py:1\n  /tmp/pytest-of-root/pytest-0/test_cmdline_python_namespace_package0/world/ns_pkg/__init__.py:1: DeprecationWarning: Deprecated call to `pkg_resources.declare_namespace('ns_pkg')`.\n  Implementing implicit namespace packages (as specified in PEP 420) is preferred to `pkg_resources.declare_namespace`. See https://setuptools.pypa.io/en/latest/references/keywords.html#keyword-namespace-packages\n    __import__('pkg_resources').declare_namespace(__name__)\n\n-- Docs: https://docs.pytest.org/en/stable/how-to/capture-warnings.html\n======================== 1 passed, 2 warnings in 0.04s =========================\n__________ TestInvocationVariants.test_invoke_test_and_doctestmodules __________\n----------------------------- Captured stdout call -----------------------------\n============================= test session starts ==============================\nplatform linux -- Python 3.9.20, pytest-8.0.0.dev46+g2f7415cfb.d20220101, pluggy-1.3.0\nrootdir: /tmp/pytest-of-root/pytest-0/test_invoke_test_and_doctestmodules0\ncollected 1 item\n\ntest_invoke_test_and_doctestmodules.py .                                 [100%]\n\n============================== 1 passed in 0.01s ===============================\n__________ TestInvocationVariants.test_cmdline_python_package_symlink __________\n----------------------------- Captured stdout call -----------------------------\n============================= test session starts ==============================\nplatform linux -- Python 3.9.20, pytest-8.0.0.dev46+g2f7415cfb.d20220101, pluggy-1.3.0 -- /opt/miniconda3/envs/testbed/bin/python\ncachedir: .pytest_cache\nrootdir: /tmp/pytest-of-root/pytest-0/test_cmdline_python_package_symlink0\ncollecting ... collected 2 items\n\nsymlink_root/lib/foo/bar/test_bar.py::test_bar PASSED                    [ 50%]\nsymlink_root/lib/foo/bar/test_bar.py::test_other PASSED                  [100%]\n\n============================== 2 passed in 0.01s ===============================\n________ TestInvocationVariants.test_cmdline_python_package_not_exists _________\n----------------------------- Captured stdout call -----------------------------\n============================= test session starts ==============================\nplatform linux -- Python 3.9.20, pytest-8.0.0.dev46+g2f7415cfb.d20220101, pluggy-1.3.0\nrootdir: /tmp/pytest-of-root/pytest-0/test_cmdline_python_package_not_exists0\ncollected 0 items\n\n============================ no tests ran in 0.00s =============================\n----------------------------- Captured stderr call -----------------------------\nERROR: module or package not found: tpkgwhatv (missing __init__.py?)\n\n____________________ TestInvocationVariants.test_doctest_id ____________________\n----------------------------- Captured stdout call -----------------------------\n============================= test session starts ==============================\nplatform linux -- Python 3.9.20, pytest-8.0.0.dev46+g2f7415cfb.d20220101, pluggy-1.3.0\nrootdir: /tmp/pytest-of-root/pytest-0/test_doctest_id0\ncollected 1 item\n\ntest_doctest_id.txt F                                                    [100%]\n\n=================================== FAILURES ===================================\n________________________ [doctest] test_doctest_id.txt _________________________\n001 >>> x=3\n002 >>> x\nExpected:\n    4\nGot:\n    3\n\n/tmp/pytest-of-root/pytest-0/test_doctest_id0/test_doctest_id.txt:2: DocTestFailure\n=========================== short test summary info ============================\nFAILED test_doctest_id.txt::test_doctest_id.txt\n============================== 1 failed in 0.01s ===============================\n============================= test session starts ==============================\nplatform linux -- Python 3.9.20, pytest-8.0.0.dev46+g2f7415cfb.d20220101, pluggy-1.3.0\nrootdir: /tmp/pytest-of-root/pytest-0/test_doctest_id0\ncollected 1 item\n\ntest_doctest_id.txt F                                                    [100%]\n\n=================================== FAILURES ===================================\n________________________ [doctest] test_doctest_id.txt _________________________\n001 >>> x=3\n002 >>> x\nExpected:\n    4\nGot:\n    3\n\n/tmp/pytest-of-root/pytest-0/test_doctest_id0/test_doctest_id.txt:2: DocTestFailure\n=========================== short test summary info ============================\nFAILED test_doctest_id.txt::test_doctest_id.txt\n============================== 1 failed in 0.00s ===============================\n___________________________ TestDurations.test_calls ___________________________\n----------------------------- Captured stdout call -----------------------------\n============================= test session starts ==============================\nplatform linux -- Python 3.9.20, pytest-8.0.0.dev46+g2f7415cfb.d20220101, pluggy-1.3.0\nrootdir: /tmp/pytest-of-root/pytest-0/test_calls0\ncollected 4 items\n\ntest_calls.py ....                                                       [100%]\n\n============================= slowest 10 durations =============================\n0.02s call     test_calls.py::test_3\n0.01s call     test_calls.py::test_2\n\n(8 durations < 0.005s hidden.  Use -vv to show these durations.)\n============================== 4 passed in 0.03s ===============================\n_______________________ TestDurations.test_calls_show_2 ________________________\n----------------------------- Captured stdout call -----------------------------\n============================= test session starts ==============================\nplatform linux -- Python 3.9.20, pytest-8.0.0.dev46+g2f7415cfb.d20220101, pluggy-1.3.0\nrootdir: /tmp/pytest-of-root/pytest-0/test_calls_show_20\ncollected 4 items\n\ntest_calls_show_2.py ....                                                [100%]\n\n============================= slowest 2 durations ==============================\n0.02s call     test_calls_show_2.py::test_3\n0.01s call     test_calls_show_2.py::test_2\n============================== 4 passed in 0.03s ===============================\n_______________________ TestDurations.test_calls_showall _______________________\n----------------------------- Captured stdout call -----------------------------\n============================= test session starts ==============================\nplatform linux -- Python 3.9.20, pytest-8.0.0.dev46+g2f7415cfb.d20220101, pluggy-1.3.0\nrootdir: /tmp/pytest-of-root/pytest-0/test_calls_showall0\ncollected 4 items\n\ntest_calls_showall.py ....                                               [100%]\n\n============================== slowest durations ===============================\n0.02s call     test_calls_showall.py::test_3\n0.01s call     test_calls_showall.py::test_2\n\n(10 durations < 0.005s hidden.  Use -vv to show these durations.)\n============================== 4 passed in 0.03s ===============================\n___________________ TestDurations.test_calls_showall_verbose ___________________\n----------------------------- Captured stdout call -----------------------------\n============================= test session starts ==============================\nplatform linux -- Python 3.9.20, pytest-8.0.0.dev46+g2f7415cfb.d20220101, pluggy-1.3.0 -- /opt/miniconda3/envs/testbed/bin/python\ncachedir: .pytest_cache\nrootdir: /tmp/pytest-of-root/pytest-0/test_calls_showall_verbose0\ncollecting ... collected 4 items\n\ntest_calls_showall_verbose.py::test_something PASSED                     [ 25%]\ntest_calls_showall_verbose.py::test_2 PASSED                             [ 50%]\ntest_calls_showall_verbose.py::test_1 PASSED                             [ 75%]\ntest_calls_showall_verbose.py::test_3 PASSED                             [100%]\n\n============================== slowest durations ===============================\n0.02s call     test_calls_showall_verbose.py::test_3\n0.01s call     test_calls_showall_verbose.py::test_2\n0.00s call     test_calls_showall_verbose.py::test_1\n0.00s setup    test_calls_showall_verbose.py::test_something\n0.00s teardown test_calls_showall_verbose.py::test_something\n0.00s setup    test_calls_showall_verbose.py::test_2\n0.00s teardown test_calls_showall_verbose.py::test_2\n0.00s setup    test_calls_showall_verbose.py::test_1\n0.00s teardown test_calls_showall_verbose.py::test_1\n0.00s setup    test_calls_showall_verbose.py::test_3\n0.00s teardown test_calls_showall_verbose.py::test_3\n0.00s call     test_calls_showall_verbose.py::test_something\n============================== 4 passed in 0.03s ===============================\n______________________ TestDurations.test_with_deselected ______________________\n----------------------------- Captured stdout call -----------------------------\n============================= test session starts ==============================\nplatform linux -- Python 3.9.20, pytest-8.0.0.dev46+g2f7415cfb.d20220101, pluggy-1.3.0\nrootdir: /tmp/pytest-of-root/pytest-0/test_with_deselected0\ncollected 4 items / 3 deselected / 1 selected\n\ntest_with_deselected.py .                                                [100%]\n\n============================= slowest 2 durations ==============================\n0.02s call     test_with_deselected.py::test_3\n\n(1 durations < 0.005s hidden.  Use -vv to show these durations.)\n======================= 1 passed, 3 deselected in 0.02s ========================\n__________________ TestDurations.test_with_failing_collection __________________\n----------------------------- Captured stdout call -----------------------------\n============================= test session starts ==============================\nplatform linux -- Python 3.9.20, pytest-8.0.0.dev46+g2f7415cfb.d20220101, pluggy-1.3.0\nrootdir: /tmp/pytest-of-root/pytest-0/test_with_failing_collection0\ncollected 4 items / 1 error / 3 deselected / 1 selected\n\n==================================== ERRORS ====================================\n____________________ ERROR collecting test_collecterror.py _____________________\n/testbed/src/_pytest/runner.py:341: in from_call\n    result: Optional[TResult] = func()\n/testbed/src/_pytest/runner.py:372: in <lambda>\n    call = CallInfo.from_call(lambda: list(collector.collect()), \"collect\")\n/testbed/src/_pytest/python.py:531: in collect\n    self._inject_setup_module_fixture()\n/testbed/src/_pytest/python.py:545: in _inject_setup_module_fixture\n    self.obj, (\"setUpModule\", \"setup_module\")\n/testbed/src/_pytest/python.py:310: in obj\n    self._obj = obj = self._getobj()\n/testbed/src/_pytest/python.py:528: in _getobj\n    return self._importtestmodule()\n/testbed/src/_pytest/python.py:617: in _importtestmodule\n    mod = import_path(self.path, mode=importmode, root=self.config.rootpath)\n/testbed/src/_pytest/pathlib.py:567: in import_path\n    importlib.import_module(module_name)\n/opt/miniconda3/envs/testbed/lib/python3.9/importlib/__init__.py:127: in import_module\n    return _bootstrap._gcd_import(name[level:], package, level)\n<frozen importlib._bootstrap>:1030: in _gcd_import\n    ???\n<frozen importlib._bootstrap>:1007: in _find_and_load\n    ???\n<frozen importlib._bootstrap>:986: in _find_and_load_unlocked\n    ???\n<frozen importlib._bootstrap>:680: in _load_unlocked\n    ???\n/testbed/src/_pytest/assertion/rewrite.py:167: in exec_module\n    exec(co, module.__dict__)\ntest_collecterror.py:1: in <module>\n    xyz\nE   NameError: name 'xyz' is not defined\n=========================== short test summary info ============================\nERROR test_collecterror.py - NameError: name 'xyz' is not defined\n!!!!!!!!!!!!!!!!!!!! Interrupted: 1 error during collection !!!!!!!!!!!!!!!!!!!!\n======================== 3 deselected, 1 error in 0.00s ========================\n_________________________ TestDurations.test_with_not __________________________\n----------------------------- Captured stdout call -----------------------------\n============================= test session starts ==============================\nplatform linux -- Python 3.9.20, pytest-8.0.0.dev46+g2f7415cfb.d20220101, pluggy-1.3.0\nrootdir: /tmp/pytest-of-root/pytest-0/test_with_not0\ncollected 4 items / 1 deselected / 3 selected\n\ntest_with_not.py ...                                                     [100%]\n\n======================= 3 passed, 1 deselected in 0.03s ========================\n_________________ TestDurationsWithFixture.test_setup_function _________________\n----------------------------- Captured stdout call -----------------------------\n============================= test session starts ==============================\nplatform linux -- Python 3.9.20, pytest-8.0.0.dev46+g2f7415cfb.d20220101, pluggy-1.3.0\nrootdir: /tmp/pytest-of-root/pytest-0/test_setup_function0\ncollected 1 item\n\ntest_setup_function.py .                                                 [100%]\n\n============================= slowest 10 durations =============================\n5.00s call     test_setup_function.py::test_1\n2.00s setup    test_setup_function.py::test_1\n\n(1 durations < 0.005s hidden.  Use -vv to show these durations.)\n============================== 1 passed in 7.00s ===============================\n_____________________________ test_zipimport_hook ______________________________\n----------------------------- Captured stdout call -----------------------------\nrunning: /opt/miniconda3/envs/testbed/bin/python /tmp/pytest-of-root/pytest-0/test_zipimport_hook0/foo.zip\n     in: /tmp/pytest-of-root/pytest-0/test_zipimport_hook0\n============================= test session starts ==============================\nplatform linux -- Python 3.9.20, pytest-8.0.0.dev46+g2f7415cfb.d20220101, pluggy-1.3.0\nrootdir: /tmp/pytest-of-root/pytest-0/test_zipimport_hook0\ncollected 0 items\n\n============================ no tests ran in 0.00s =============================\n----------------------------- Captured stderr call -----------------------------\nERROR: module or package not found: foo (missing __init__.py?)\n\n_______________________ test_import_plugin_unicode_name ________________________\n----------------------------- Captured stdout call -----------------------------\n============================= test session starts ==============================\nplatform linux -- Python 3.9.20, pytest-8.0.0.dev46+g2f7415cfb.d20220101, pluggy-1.3.0\nrootdir: /tmp/pytest-of-root/pytest-0/test_import_plugin_unicode_name0\ncollected 1 item\n\ntest_import_plugin_unicode_name.py .                                     [100%]\n\n============================== 1 passed in 0.00s ===============================\n________________________ test_pytest_plugins_as_module _________________________\n----------------------------- Captured stdout call -----------------------------\n============================= test session starts ==============================\nplatform linux -- Python 3.9.20, pytest-8.0.0.dev46+g2f7415cfb.d20220101, pluggy-1.3.0\nrootdir: /tmp/pytest-of-root/pytest-0/test_pytest_plugins_as_module0\ncollected 1 item\n\ntest_foo.py .                                                            [100%]\n\n============================== 1 passed in 0.00s ===============================\n_________________________ test_deferred_hook_checking __________________________\n----------------------------- Captured stdout call -----------------------------\n============================= test session starts ==============================\nplatform linux -- Python 3.9.20, pytest-8.0.0.dev46+g2f7415cfb.d20220101, pluggy-1.3.0\nrootdir: /tmp/pytest-of-root/pytest-0/test_deferred_hook_checking0\ncollected 1 item\n\ntest_foo.py .                                                            [100%]\n\n============================== 1 passed in 0.00s ===============================\n______________________ test_fixture_order_respects_scope _______________________\n----------------------------- Captured stdout call -----------------------------\n============================= test session starts ==============================\nplatform linux -- Python 3.9.20, pytest-8.0.0.dev46+g2f7415cfb.d20220101, pluggy-1.3.0\nrootdir: /tmp/pytest-of-root/pytest-0/test_fixture_order_respects_scope0\ncollected 1 item\n\ntest_fixture_order_respects_scope.py .                                   [100%]\n\n============================== 1 passed in 0.00s ===============================\n________________________ test_fixture_mock_integration _________________________\n----------------------------- Captured stdout call -----------------------------\n============================= test session starts ==============================\nplatform linux -- Python 3.9.20, pytest-8.0.0.dev46+g2f7415cfb.d20220101, pluggy-1.3.0\nrootdir: /tmp/pytest-of-root/pytest-0/test_fixture_mock_integration0\ncollected 1 item\n\nfixture_mock_integration.py .                                            [100%]\n\n============================== 1 passed in 0.01s ===============================\n____________________________ test_usage_error_code _____________________________\n----------------------------- Captured stderr call -----------------------------\nERROR: usage: pytest [options] [file_or_dir] [file_or_dir] [...]\npytest: error: unrecognized arguments: -unknown-option-\n  inifile: None\n  rootdir: /tmp/pytest-of-root/pytest-0/test_usage_error_code0\n\n_________________________ test_warn_on_async_function __________________________\n----------------------------- Captured stdout call -----------------------------\n============================= test session starts ==============================\nplatform linux -- Python 3.9.20, pytest-8.0.0.dev46+g2f7415cfb.d20220101, pluggy-1.3.0\nrootdir: /tmp/pytest-of-root/pytest-0/test_warn_on_async_function0\ncollected 3 items\n\ntest_async.py sss                                                        [100%]\n\n=============================== warnings summary ===============================\ntest_async.py::test_1\ntest_async.py::test_2\ntest_async.py::test_3\n  /testbed/src/_pytest/python.py:183: PytestUnhandledCoroutineWarning: async def functions are not natively supported and have been skipped.\n  You need to install a suitable plugin for your async framework, for example:\n    - anyio\n    - pytest-asyncio\n    - pytest-tornasync\n    - pytest-trio\n    - pytest-twisted\n    warnings.warn(PytestUnhandledCoroutineWarning(msg.format(nodeid)))\n\n-- Docs: https://docs.pytest.org/en/stable/how-to/capture-warnings.html\n======================== 3 skipped, 3 warnings in 0.01s ========================\n_______________________ test_warn_on_async_gen_function ________________________\n----------------------------- Captured stdout call -----------------------------\n============================= test session starts ==============================\nplatform linux -- Python 3.9.20, pytest-8.0.0.dev46+g2f7415cfb.d20220101, pluggy-1.3.0\nrootdir: /tmp/pytest-of-root/pytest-0/test_warn_on_async_gen_function0\ncollected 3 items\n\ntest_async.py sss                                                        [100%]\n\n=============================== warnings summary ===============================\ntest_async.py::test_1\ntest_async.py::test_2\ntest_async.py::test_3\n  /testbed/src/_pytest/python.py:183: PytestUnhandledCoroutineWarning: async def functions are not natively supported and have been skipped.\n  You need to install a suitable plugin for your async framework, for example:\n    - anyio\n    - pytest-asyncio\n    - pytest-tornasync\n    - pytest-trio\n    - pytest-twisted\n    warnings.warn(PytestUnhandledCoroutineWarning(msg.format(nodeid)))\n\n-- Docs: https://docs.pytest.org/en/stable/how-to/capture-warnings.html\n======================== 3 skipped, 3 warnings in 0.01s ========================\n____________________ test_function_return_non_none_warning _____________________\n----------------------------- Captured stdout call -----------------------------\n============================= test session starts ==============================\nplatform linux -- Python 3.9.20, pytest-8.0.0.dev46+g2f7415cfb.d20220101, pluggy-1.3.0\nrootdir: /tmp/pytest-of-root/pytest-0/test_function_return_non_none_warning0\ncollected 1 item\n\ntest_function_return_non_none_warning.py F                               [100%]\n\n=================================== FAILURES ===================================\n__________________________________ test_stuff __________________________________\n\ncls = <class '_pytest.runner.CallInfo'>\nfunc = <function call_runtest_hook.<locals>.<lambda> at 0x7f51301b98b0>\nwhen = 'call'\nreraise = (<class '_pytest.outcomes.Exit'>, <class 'KeyboardInterrupt'>)\n\n    @classmethod\n    def from_call(\n        cls,\n        func: \"Callable[[], TResult]\",\n        when: \"Literal['collect', 'setup', 'call', 'teardown']\",\n        reraise: Optional[\n            Union[Type[BaseException], Tuple[Type[BaseException], ...]]\n        ] = None,\n    ) -> \"CallInfo[TResult]\":\n        \"\"\"Call func, wrapping the result in a CallInfo.\n    \n        :param func:\n            The function to call. Called without arguments.\n        :param when:\n            The phase in which the function is called.\n        :param reraise:\n            Exception or exceptions that shall propagate if raised by the\n            function, instead of being wrapped in the CallInfo.\n        \"\"\"\n        excinfo = None\n        start = timing.time()\n        precise_start = timing.perf_counter()\n        try:\n>           result: Optional[TResult] = func()\n\n/testbed/src/_pytest/runner.py:341: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n/testbed/src/_pytest/runner.py:262: in <lambda>\n    lambda: ihook(item=item, **kwds), when=when, reraise=reraise\n/opt/miniconda3/envs/testbed/lib/python3.9/site-packages/pluggy/_hooks.py:493: in __call__\n    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)\n/opt/miniconda3/envs/testbed/lib/python3.9/site-packages/pluggy/_manager.py:115: in _hookexec\n    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)\n/opt/miniconda3/envs/testbed/lib/python3.9/site-packages/pluggy/_manager.py:457: in traced_hookexec\n    return outcome.get_result()\n/opt/miniconda3/envs/testbed/lib/python3.9/site-packages/pluggy/_manager.py:454: in <lambda>\n    lambda: oldcall(hook_name, hook_impls, caller_kwargs, firstresult)\n/testbed/src/_pytest/runner.py:177: in pytest_runtest_call\n    raise e\n/testbed/src/_pytest/runner.py:169: in pytest_runtest_call\n    item.runtest()\n/testbed/src/_pytest/python.py:1790: in runtest\n    self.ihook.pytest_pyfunc_call(pyfuncitem=self)\n/opt/miniconda3/envs/testbed/lib/python3.9/site-packages/pluggy/_hooks.py:493: in __call__\n    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)\n/opt/miniconda3/envs/testbed/lib/python3.9/site-packages/pluggy/_manager.py:115: in _hookexec\n    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)\n/opt/miniconda3/envs/testbed/lib/python3.9/site-packages/pluggy/_manager.py:457: in traced_hookexec\n    return outcome.get_result()\n/opt/miniconda3/envs/testbed/lib/python3.9/site-packages/pluggy/_manager.py:454: in <lambda>\n    lambda: oldcall(hook_name, hook_impls, caller_kwargs, firstresult)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\npyfuncitem = <Function test_stuff>\n\n    @hookimpl(trylast=True)\n    def pytest_pyfunc_call(pyfuncitem: \"Function\") -> Optional[object]:\n        testfunction = pyfuncitem.obj\n        if is_async_function(testfunction):\n            async_warn_and_skip(pyfuncitem.nodeid)\n        funcargs = pyfuncitem.funcargs\n        testargs = {arg: funcargs[arg] for arg in pyfuncitem._fixtureinfo.argnames}\n        result = testfunction(**testargs)\n        if hasattr(result, \"__await__\") or hasattr(result, \"__aiter__\"):\n            async_warn_and_skip(pyfuncitem.nodeid)\n        elif result is not None:\n>           warnings.warn(\n                PytestReturnNotNoneWarning(\n                    f\"Expected None, but {pyfuncitem.nodeid} returned {result!r}, which will be an error in a \"\n                    \"future version of pytest.  Did you mean to use `assert` instead of `return`?\"\n                )\n            )\nE           pytest.PytestReturnNotNoneWarning: Expected None, but test_function_return_non_none_warning.py::test_stuff returned 'something', which will be an error in a future version of pytest.  Did you mean to use `assert` instead of `return`?\n\n/testbed/src/_pytest/python.py:198: PytestReturnNotNoneWarning\n=========================== short test summary info ============================\nFAILED test_function_return_non_none_warning.py::test_stuff - pytest.PytestRe...\n============================== 1 failed in 0.08s ===============================\n___________________________ test_fixture_values_leak ___________________________\n----------------------------- Captured stdout call -----------------------------\nrunning: /opt/miniconda3/envs/testbed/bin/python -mpytest --basetemp=/tmp/pytest-of-root/pytest-0/test_fixture_values_leak0/runpytest-0\n     in: /tmp/pytest-of-root/pytest-0/test_fixture_values_leak0\n============================= test session starts ==============================\nplatform linux -- Python 3.9.20, pytest-8.0.0.dev46+g2f7415cfb.d20220101, pluggy-1.3.0\nrootdir: /tmp/pytest-of-root/pytest-0/test_fixture_values_leak0\ncollected 2 items\n\ntest_fixture_values_leak.py ..                                           [100%]\n\n============================== 2 passed in 0.01s ===============================\n_______________________ test_frame_leak_on_failing_test ________________________\n----------------------------- Captured stdout call -----------------------------\nrunning: /opt/miniconda3/envs/testbed/bin/python -mpytest --basetemp=/tmp/pytest-of-root/pytest-0/test_frame_leak_on_failing_test0/runpytest-0\n     in: /tmp/pytest-of-root/pytest-0/test_frame_leak_on_failing_test0\n============================= test session starts ==============================\nplatform linux -- Python 3.9.20, pytest-8.0.0.dev46+g2f7415cfb.d20220101, pluggy-1.3.0\nrootdir: /tmp/pytest-of-root/pytest-0/test_frame_leak_on_failing_test0\ncollected 2 items\n\ntest_frame_leak_on_failing_test.py F.                                    [100%]\n\n=================================== FAILURES ===================================\n____________________________________ test1 _____________________________________\n\n    def test1():\n        obj = Obj()\n        global ref\n        ref = weakref.ref(obj)\n>       assert 0\nE       assert 0\n\ntest_frame_leak_on_failing_test.py:13: AssertionError\n=========================== short test summary info ============================\nFAILED test_frame_leak_on_failing_test.py::test1 - assert 0\n========================= 1 failed, 1 passed in 0.02s ==========================\n__________________________ test_pdb_can_be_rewritten ___________________________\n----------------------------- Captured stdout call -----------------------------\nrunning: /opt/miniconda3/envs/testbed/bin/python -mpytest --basetemp=/tmp/pytest-of-root/pytest-0/test_pdb_can_be_rewritten0/runpytest-0 -p no:debugging -vv\n     in: /tmp/pytest-of-root/pytest-0/test_pdb_can_be_rewritten0\n============================= test session starts ==============================\nplatform linux -- Python 3.9.20, pytest-8.0.0.dev46+g2f7415cfb.d20220101, pluggy-1.3.0 -- /opt/miniconda3/envs/testbed/bin/python\ncachedir: .pytest_cache\nrootdir: /tmp/pytest-of-root/pytest-0/test_pdb_can_be_rewritten0\ncollecting ... collected 1 item\n\ntest_pdb.py::test FAILED                                                 [100%]\n\n=================================== FAILURES ===================================\n_____________________________________ test _____________________________________\n\n    def test():\n        import pdb\n>       assert pdb.check()\n\ntest_pdb.py:3: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\n    def check():\n>       assert 1 == 2\nE       assert 1 == 2\n\npdb.py:2: AssertionError\n=========================== short test summary info ============================\nFAILED test_pdb.py::test - assert 1 == 2\n============================== 1 failed in 0.02s ===============================\n___________________ test_tee_stdio_captures_and_live_prints ____________________\n----------------------------- Captured stdout call -----------------------------\nrunning: /opt/miniconda3/envs/testbed/bin/python -mpytest --basetemp=/tmp/pytest-of-root/pytest-0/test_tee_stdio_captures_and_live_prints0/runpytest-0 /tmp/pytest-of-root/pytest-0/test_tee_stdio_captures_and_live_prints0/test_tee_stdio_captures_and_live_prints.py --capture=tee-sys --junitxml=output.xml -o junit_logging=all\n     in: /tmp/pytest-of-root/pytest-0/test_tee_stdio_captures_and_live_prints0\n============================= test session starts ==============================\nplatform linux -- Python 3.9.20, pytest-8.0.0.dev46+g2f7415cfb.d20220101, pluggy-1.3.0\nrootdir: /tmp/pytest-of-root/pytest-0/test_tee_stdio_captures_and_live_prints0\ncollected 1 item\n\ntest_tee_stdio_captures_and_live_prints.py @this is stdout@\n.                             [100%]\n\n- generated xml file: /tmp/pytest-of-root/pytest-0/test_tee_stdio_captures_and_live_prints0/output.xml -\n============================== 1 passed in 0.01s ===============================\n----------------------------- Captured stderr call -----------------------------\n@this is stderr@\n________________ test_doctest_and_normal_imports_with_importlib ________________\n----------------------------- Captured stdout call -----------------------------\nrunning: /opt/miniconda3/envs/testbed/bin/python -mpytest --basetemp=/tmp/pytest-of-root/pytest-0/test_doctest_and_normal_imports_with_importlib0/runpytest-0\n     in: /tmp/pytest-of-root/pytest-0/test_doctest_and_normal_imports_with_importlib0\n============================= test session starts ==============================\nplatform linux -- Python 3.9.20, pytest-8.0.0.dev46+g2f7415cfb.d20220101, pluggy-1.3.0\nrootdir: /tmp/pytest-of-root/pytest-0/test_doctest_and_normal_imports_with_importlib0\nconfigfile: tox.ini\ncollected 1 item\n\ntests/test_commands.py .                                                 [100%]\n\n============================== 1 passed in 0.01s ===============================\n=========================== short test summary info ============================\nPASSED testing/acceptance_test.py::TestGeneralUsage::test_docstring_on_hookspec\nPASSED testing/acceptance_test.py::TestInvocationVariants::test_invoke_with_invalid_type\nPASSED testing/acceptance_test.py::TestInvocationVariants::test_invoke_plugin_api\nPASSED testing/acceptance_test.py::TestInvocationVariants::test_core_backward_compatibility\nPASSED testing/acceptance_test.py::TestInvocationVariants::test_has_plugin\nPASSED testing/test_pathlib.py::TestFNMatcherPort::test_matching[*.py-foo.py]\nPASSED testing/test_pathlib.py::TestFNMatcherPort::test_matching[*.py-bar/foo.py]\nPASSED testing/test_pathlib.py::TestFNMatcherPort::test_matching[test_*.py-foo/test_foo.py]\nPASSED testing/test_pathlib.py::TestFNMatcherPort::test_matching[tests/*.py-tests/foo.py]\nPASSED testing/test_pathlib.py::TestFNMatcherPort::test_matching[/c/*.py-/c/foo.py]\nPASSED testing/test_pathlib.py::TestFNMatcherPort::test_matching[/c/foo/*.py-/c/foo/foo.py]\nPASSED testing/test_pathlib.py::TestFNMatcherPort::test_matching[tests/**/test*.py-tests/foo/test_foo.py]\nPASSED testing/test_pathlib.py::TestFNMatcherPort::test_matching[tests/**/doc/test*.py-tests/foo/bar/doc/test_foo.py]\nPASSED testing/test_pathlib.py::TestFNMatcherPort::test_matching[tests/**/doc/**/test*.py-tests/foo/doc/bar/test_foo.py]\nPASSED testing/test_pathlib.py::TestFNMatcherPort::test_matching_abspath\nPASSED testing/test_pathlib.py::TestFNMatcherPort::test_not_matching[*.py-foo.pyc]\nPASSED testing/test_pathlib.py::TestFNMatcherPort::test_not_matching[*.py-foo/foo.pyc]\nPASSED testing/test_pathlib.py::TestFNMatcherPort::test_not_matching[tests/*.py-foo/foo.py]\nPASSED testing/test_pathlib.py::TestFNMatcherPort::test_not_matching[/c/*.py-/d/foo.py]\nPASSED testing/test_pathlib.py::TestFNMatcherPort::test_not_matching[/c/foo/*.py-/d/foo/foo.py]\nPASSED testing/test_pathlib.py::TestFNMatcherPort::test_not_matching[tests/**/test*.py-tests/foo.py]\nPASSED testing/test_pathlib.py::TestFNMatcherPort::test_not_matching[tests/**/test*.py-foo/test_foo.py]\nPASSED testing/test_pathlib.py::TestFNMatcherPort::test_not_matching[tests/**/doc/test*.py-tests/foo/bar/doc/foo.py]\nPASSED testing/test_pathlib.py::TestFNMatcherPort::test_not_matching[tests/**/doc/test*.py-tests/foo/bar/test_foo.py]\nPASSED testing/test_pathlib.py::TestImportPath::test_smoke_test\nPASSED testing/test_pathlib.py::TestImportPath::test_import_path_missing_file\nPASSED testing/test_pathlib.py::TestImportPath::test_renamed_dir_creates_mismatch\nPASSED testing/test_pathlib.py::TestImportPath::test_messy_name\nPASSED testing/test_pathlib.py::TestImportPath::test_dir\nPASSED testing/test_pathlib.py::TestImportPath::test_a\nPASSED testing/test_pathlib.py::TestImportPath::test_b\nPASSED testing/test_pathlib.py::TestImportPath::test_c\nPASSED testing/test_pathlib.py::TestImportPath::test_d\nPASSED testing/test_pathlib.py::TestImportPath::test_import_after\nPASSED testing/test_pathlib.py::TestImportPath::test_check_filepath_consistency\nPASSED testing/test_pathlib.py::TestImportPath::test_issue131_on__init__\nPASSED testing/test_pathlib.py::TestImportPath::test_ensuresyspath_append\nPASSED testing/test_pathlib.py::TestImportPath::test_invalid_path\nPASSED testing/test_pathlib.py::TestImportPath::test_importmode_importlib\nPASSED testing/test_pathlib.py::TestImportPath::test_remembers_previous_imports\nPASSED testing/test_pathlib.py::TestImportPath::test_no_meta_path_found\nPASSED testing/test_pathlib.py::test_resolve_package_path\nPASSED testing/test_pathlib.py::test_package_unimportable\nPASSED testing/test_pathlib.py::test_access_denied_during_cleanup\nPASSED testing/test_pathlib.py::test_long_path_during_cleanup\nPASSED testing/test_pathlib.py::test_get_extended_length_path_str\nPASSED testing/test_pathlib.py::test_suppress_error_removing_lock\nPASSED testing/test_pathlib.py::test_bestrelpath\nPASSED testing/test_pathlib.py::test_commonpath\nPASSED testing/test_pathlib.py::test_visit_ignores_errors\nPASSED testing/test_pathlib.py::TestImportLibMode::test_importmode_importlib_with_dataclass\nPASSED testing/test_pathlib.py::TestImportLibMode::test_importmode_importlib_with_pickle\nPASSED testing/test_pathlib.py::TestImportLibMode::test_importmode_importlib_with_pickle_separate_modules\nPASSED testing/test_pathlib.py::TestImportLibMode::test_module_name_from_path\nPASSED testing/test_pathlib.py::TestImportLibMode::test_insert_missing_modules\nPASSED testing/test_pathlib.py::TestImportLibMode::test_parent_contains_child_module_attribute\nPASSED testing/acceptance_test.py::TestGeneralUsage::test_config_error\nPASSED testing/acceptance_test.py::TestGeneralUsage::test_root_conftest_syntax_error\nPASSED testing/acceptance_test.py::TestGeneralUsage::test_early_hook_error_issue38_1\nPASSED testing/acceptance_test.py::TestGeneralUsage::test_early_hook_configure_error_issue38\nPASSED testing/acceptance_test.py::TestGeneralUsage::test_file_not_found\nPASSED testing/acceptance_test.py::TestGeneralUsage::test_file_not_found_unconfigure_issue143\nPASSED testing/acceptance_test.py::TestGeneralUsage::test_config_preparse_plugin_option\nPASSED testing/acceptance_test.py::TestGeneralUsage::test_early_load_setuptools_name[True]\nPASSED testing/acceptance_test.py::TestGeneralUsage::test_early_load_setuptools_name[False]\nPASSED testing/acceptance_test.py::TestGeneralUsage::test_assertion_rewrite[prepend]\nPASSED testing/acceptance_test.py::TestGeneralUsage::test_assertion_rewrite[append]\nPASSED testing/acceptance_test.py::TestGeneralUsage::test_assertion_rewrite[importlib]\nPASSED testing/acceptance_test.py::TestGeneralUsage::test_nested_import_error\nPASSED testing/acceptance_test.py::TestGeneralUsage::test_not_collectable_arguments\nPASSED testing/acceptance_test.py::TestGeneralUsage::test_better_reporting_on_conftest_load_failure\nPASSED testing/acceptance_test.py::TestGeneralUsage::test_early_skip\nPASSED testing/acceptance_test.py::TestGeneralUsage::test_issue88_initial_file_multinodes\nPASSED testing/acceptance_test.py::TestGeneralUsage::test_issue93_initialnode_importing_capturing\nPASSED testing/acceptance_test.py::TestGeneralUsage::test_conftest_printing_shows_if_error\nPASSED testing/acceptance_test.py::TestGeneralUsage::test_issue109_sibling_conftests_not_loaded\nPASSED testing/acceptance_test.py::TestGeneralUsage::test_directory_skipped\nPASSED testing/acceptance_test.py::TestGeneralUsage::test_multiple_items_per_collector_byid\nPASSED testing/acceptance_test.py::TestGeneralUsage::test_skip_on_generated_funcarg_id\nPASSED testing/acceptance_test.py::TestGeneralUsage::test_direct_addressing_selects\nPASSED testing/acceptance_test.py::TestGeneralUsage::test_direct_addressing_notfound\nPASSED testing/acceptance_test.py::TestGeneralUsage::test_initialization_error_issue49\nPASSED testing/acceptance_test.py::TestGeneralUsage::test_issue134_report_error_when_collecting_member[test_fun.py::test_a]\nPASSED testing/acceptance_test.py::TestGeneralUsage::test_report_all_failed_collections_initargs\nPASSED testing/acceptance_test.py::TestGeneralUsage::test_namespace_import_doesnt_confuse_import_hook\nPASSED testing/acceptance_test.py::TestGeneralUsage::test_unknown_option\nPASSED testing/acceptance_test.py::TestGeneralUsage::test_getsourcelines_error_issue553\nPASSED testing/acceptance_test.py::TestGeneralUsage::test_plugins_given_as_strings\nPASSED testing/acceptance_test.py::TestGeneralUsage::test_parametrized_with_bytes_regex\nPASSED testing/acceptance_test.py::TestGeneralUsage::test_parametrized_with_null_bytes\nPASSED testing/acceptance_test.py::TestInvocationVariants::test_earlyinit\nPASSED testing/acceptance_test.py::TestInvocationVariants::test_pydoc\nPASSED testing/acceptance_test.py::TestInvocationVariants::test_import_star_pytest\nPASSED testing/acceptance_test.py::TestInvocationVariants::test_double_pytestcmdline\nPASSED testing/acceptance_test.py::TestInvocationVariants::test_python_minus_m_invocation_ok\nPASSED testing/acceptance_test.py::TestInvocationVariants::test_python_minus_m_invocation_fail\nPASSED testing/acceptance_test.py::TestInvocationVariants::test_python_pytest_package\nPASSED testing/acceptance_test.py::TestInvocationVariants::test_invoke_with_path\nPASSED testing/acceptance_test.py::TestInvocationVariants::test_pyargs_importerror\nPASSED testing/acceptance_test.py::TestInvocationVariants::test_pyargs_only_imported_once\nPASSED testing/acceptance_test.py::TestInvocationVariants::test_pyargs_filename_looks_like_module\nPASSED testing/acceptance_test.py::TestInvocationVariants::test_cmdline_python_package\nPASSED testing/acceptance_test.py::TestInvocationVariants::test_cmdline_python_namespace_package\nPASSED testing/acceptance_test.py::TestInvocationVariants::test_invoke_test_and_doctestmodules\nPASSED testing/acceptance_test.py::TestInvocationVariants::test_cmdline_python_package_symlink\nPASSED testing/acceptance_test.py::TestInvocationVariants::test_cmdline_python_package_not_exists\nPASSED testing/acceptance_test.py::TestInvocationVariants::test_doctest_id\nPASSED testing/acceptance_test.py::TestDurations::test_calls\nPASSED testing/acceptance_test.py::TestDurations::test_calls_show_2\nPASSED testing/acceptance_test.py::TestDurations::test_calls_showall\nPASSED testing/acceptance_test.py::TestDurations::test_calls_showall_verbose\nPASSED testing/acceptance_test.py::TestDurations::test_with_deselected\nPASSED testing/acceptance_test.py::TestDurations::test_with_failing_collection\nPASSED testing/acceptance_test.py::TestDurations::test_with_not\nPASSED testing/acceptance_test.py::TestDurationsWithFixture::test_setup_function\nPASSED testing/acceptance_test.py::test_zipimport_hook\nPASSED testing/acceptance_test.py::test_import_plugin_unicode_name\nPASSED testing/acceptance_test.py::test_pytest_plugins_as_module\nPASSED testing/acceptance_test.py::test_deferred_hook_checking\nPASSED testing/acceptance_test.py::test_fixture_order_respects_scope\nPASSED testing/acceptance_test.py::test_fixture_mock_integration\nPASSED testing/acceptance_test.py::test_usage_error_code\nPASSED testing/acceptance_test.py::test_warn_on_async_function\nPASSED testing/acceptance_test.py::test_warn_on_async_gen_function\nPASSED testing/acceptance_test.py::test_no_brokenpipeerror_message\nPASSED testing/acceptance_test.py::test_function_return_non_none_warning\nPASSED testing/acceptance_test.py::test_fixture_values_leak\nPASSED testing/acceptance_test.py::test_frame_leak_on_failing_test\nPASSED testing/acceptance_test.py::test_pdb_can_be_rewritten\nPASSED testing/acceptance_test.py::test_tee_stdio_captures_and_live_prints\nPASSED testing/acceptance_test.py::test_doctest_and_normal_imports_with_importlib\nSKIPPED [1] testing/test_pathlib.py:455: Windows only\nXFAIL testing/acceptance_test.py::TestInvocationVariants::test_noclass_discovery_if_not_testcase - decide: feature or bug\n================== 131 passed, 1 skipped, 1 xfailed in 5.47s ===================\n", {"hello": "ERROR:", "file": "ERROR:", "test_assertion_rewrite.py::test_this": "FAILED", "test_nested_import_error.py": "ERROR", "found": "ERROR:", "not": "ERROR:", "test_fun.py": "ERROR", "test_a.py": "ERROR", "test_b.py": "ERROR", "usage:": "ERROR:", "test_getsourcelines_error_issue553.py::test_foo": "ERROR", "test_python_minus_m_invocation_fail.py::test_fail": "FAILED", "tpkg/test_hello.py": "ERROR", "module": "ERROR:", "test_doctest_id.txt::test_doctest_id.txt": "FAILED", "test_collecterror.py": "ERROR", "test_function_return_non_none_warning.py::test_stuff": "FAILED", "test_frame_leak_on_failing_test.py::test1": "FAILED", "test_pdb.py::test": "FAILED", "testing/acceptance_test.py::TestGeneralUsage::test_docstring_on_hookspec": "PASSED", "testing/acceptance_test.py::TestInvocationVariants::test_invoke_with_invalid_type": "PASSED", "testing/acceptance_test.py::TestInvocationVariants::test_invoke_plugin_api": "PASSED", "testing/acceptance_test.py::TestInvocationVariants::test_core_backward_compatibility": "PASSED", "testing/acceptance_test.py::TestInvocationVariants::test_has_plugin": "PASSED", "testing/test_pathlib.py::TestFNMatcherPort::test_matching[*.py-foo.py]": "PASSED", "testing/test_pathlib.py::TestFNMatcherPort::test_matching[*.py-bar/foo.py]": "PASSED", "testing/test_pathlib.py::TestFNMatcherPort::test_matching[test_*.py-foo/test_foo.py]": "PASSED", "testing/test_pathlib.py::TestFNMatcherPort::test_matching[tests/*.py-tests/foo.py]": "PASSED", "testing/test_pathlib.py::TestFNMatcherPort::test_matching[/c/*.py-/c/foo.py]": "PASSED", "testing/test_pathlib.py::TestFNMatcherPort::test_matching[/c/foo/*.py-/c/foo/foo.py]": "PASSED", "testing/test_pathlib.py::TestFNMatcherPort::test_matching[tests/**/test*.py-tests/foo/test_foo.py]": "PASSED", "testing/test_pathlib.py::TestFNMatcherPort::test_matching[tests/**/doc/test*.py-tests/foo/bar/doc/test_foo.py]": "PASSED", "testing/test_pathlib.py::TestFNMatcherPort::test_matching[tests/**/doc/**/test*.py-tests/foo/doc/bar/test_foo.py]": "PASSED", "testing/test_pathlib.py::TestFNMatcherPort::test_matching_abspath": "PASSED", "testing/test_pathlib.py::TestFNMatcherPort::test_not_matching[*.py-foo.pyc]": "PASSED", "testing/test_pathlib.py::TestFNMatcherPort::test_not_matching[*.py-foo/foo.pyc]": "PASSED", "testing/test_pathlib.py::TestFNMatcherPort::test_not_matching[tests/*.py-foo/foo.py]": "PASSED", "testing/test_pathlib.py::TestFNMatcherPort::test_not_matching[/c/*.py-/d/foo.py]": "PASSED", "testing/test_pathlib.py::TestFNMatcherPort::test_not_matching[/c/foo/*.py-/d/foo/foo.py]": "PASSED", "testing/test_pathlib.py::TestFNMatcherPort::test_not_matching[tests/**/test*.py-tests/foo.py]": "PASSED", "testing/test_pathlib.py::TestFNMatcherPort::test_not_matching[tests/**/test*.py-foo/test_foo.py]": "PASSED", "testing/test_pathlib.py::TestFNMatcherPort::test_not_matching[tests/**/doc/test*.py-tests/foo/bar/doc/foo.py]": "PASSED", "testing/test_pathlib.py::TestFNMatcherPort::test_not_matching[tests/**/doc/test*.py-tests/foo/bar/test_foo.py]": "PASSED", "testing/test_pathlib.py::TestImportPath::test_smoke_test": "PASSED", "testing/test_pathlib.py::TestImportPath::test_import_path_missing_file": "PASSED", "testing/test_pathlib.py::TestImportPath::test_renamed_dir_creates_mismatch": "PASSED", "testing/test_pathlib.py::TestImportPath::test_messy_name": "PASSED", "testing/test_pathlib.py::TestImportPath::test_dir": "PASSED", "testing/test_pathlib.py::TestImportPath::test_a": "PASSED", "testing/test_pathlib.py::TestImportPath::test_b": "PASSED", "testing/test_pathlib.py::TestImportPath::test_c": "PASSED", "testing/test_pathlib.py::TestImportPath::test_d": "PASSED", "testing/test_pathlib.py::TestImportPath::test_import_after": "PASSED", "testing/test_pathlib.py::TestImportPath::test_check_filepath_consistency": "PASSED", "testing/test_pathlib.py::TestImportPath::test_issue131_on__init__": "PASSED", "testing/test_pathlib.py::TestImportPath::test_ensuresyspath_append": "PASSED", "testing/test_pathlib.py::TestImportPath::test_invalid_path": "PASSED", "testing/test_pathlib.py::TestImportPath::test_importmode_importlib": "PASSED", "testing/test_pathlib.py::TestImportPath::test_remembers_previous_imports": "PASSED", "testing/test_pathlib.py::TestImportPath::test_no_meta_path_found": "PASSED", "testing/test_pathlib.py::test_resolve_package_path": "PASSED", "testing/test_pathlib.py::test_package_unimportable": "PASSED", "testing/test_pathlib.py::test_access_denied_during_cleanup": "PASSED", "testing/test_pathlib.py::test_long_path_during_cleanup": "PASSED", "testing/test_pathlib.py::test_get_extended_length_path_str": "PASSED", "testing/test_pathlib.py::test_suppress_error_removing_lock": "PASSED", "testing/test_pathlib.py::test_bestrelpath": "PASSED", "testing/test_pathlib.py::test_commonpath": "PASSED", "testing/test_pathlib.py::test_visit_ignores_errors": "PASSED", "testing/test_pathlib.py::TestImportLibMode::test_importmode_importlib_with_dataclass": "PASSED", "testing/test_pathlib.py::TestImportLibMode::test_importmode_importlib_with_pickle": "PASSED", "testing/test_pathlib.py::TestImportLibMode::test_importmode_importlib_with_pickle_separate_modules": "PASSED", "testing/test_pathlib.py::TestImportLibMode::test_module_name_from_path": "PASSED", "testing/test_pathlib.py::TestImportLibMode::test_insert_missing_modules": "PASSED", "testing/test_pathlib.py::TestImportLibMode::test_parent_contains_child_module_attribute": "PASSED", "testing/acceptance_test.py::TestGeneralUsage::test_config_error": "PASSED", "testing/acceptance_test.py::TestGeneralUsage::test_root_conftest_syntax_error": "PASSED", "testing/acceptance_test.py::TestGeneralUsage::test_early_hook_error_issue38_1": "PASSED", "testing/acceptance_test.py::TestGeneralUsage::test_early_hook_configure_error_issue38": "PASSED", "testing/acceptance_test.py::TestGeneralUsage::test_file_not_found": "PASSED", "testing/acceptance_test.py::TestGeneralUsage::test_file_not_found_unconfigure_issue143": "PASSED", "testing/acceptance_test.py::TestGeneralUsage::test_config_preparse_plugin_option": "PASSED", "testing/acceptance_test.py::TestGeneralUsage::test_early_load_setuptools_name[True]": "PASSED", "testing/acceptance_test.py::TestGeneralUsage::test_early_load_setuptools_name[False]": "PASSED", "testing/acceptance_test.py::TestGeneralUsage::test_assertion_rewrite[prepend]": "PASSED", "testing/acceptance_test.py::TestGeneralUsage::test_assertion_rewrite[append]": "PASSED", "testing/acceptance_test.py::TestGeneralUsage::test_assertion_rewrite[importlib]": "PASSED", "testing/acceptance_test.py::TestGeneralUsage::test_nested_import_error": "PASSED", "testing/acceptance_test.py::TestGeneralUsage::test_not_collectable_arguments": "PASSED", "testing/acceptance_test.py::TestGeneralUsage::test_better_reporting_on_conftest_load_failure": "PASSED", "testing/acceptance_test.py::TestGeneralUsage::test_early_skip": "PASSED", "testing/acceptance_test.py::TestGeneralUsage::test_issue88_initial_file_multinodes": "PASSED", "testing/acceptance_test.py::TestGeneralUsage::test_issue93_initialnode_importing_capturing": "PASSED", "testing/acceptance_test.py::TestGeneralUsage::test_conftest_printing_shows_if_error": "PASSED", "testing/acceptance_test.py::TestGeneralUsage::test_issue109_sibling_conftests_not_loaded": "PASSED", "testing/acceptance_test.py::TestGeneralUsage::test_directory_skipped": "PASSED", "testing/acceptance_test.py::TestGeneralUsage::test_multiple_items_per_collector_byid": "PASSED", "testing/acceptance_test.py::TestGeneralUsage::test_skip_on_generated_funcarg_id": "PASSED", "testing/acceptance_test.py::TestGeneralUsage::test_direct_addressing_selects": "PASSED", "testing/acceptance_test.py::TestGeneralUsage::test_direct_addressing_notfound": "PASSED", "testing/acceptance_test.py::TestGeneralUsage::test_initialization_error_issue49": "PASSED", "testing/acceptance_test.py::TestGeneralUsage::test_issue134_report_error_when_collecting_member[test_fun.py::test_a]": "PASSED", "testing/acceptance_test.py::TestGeneralUsage::test_report_all_failed_collections_initargs": "PASSED", "testing/acceptance_test.py::TestGeneralUsage::test_namespace_import_doesnt_confuse_import_hook": "PASSED", "testing/acceptance_test.py::TestGeneralUsage::test_unknown_option": "PASSED", "testing/acceptance_test.py::TestGeneralUsage::test_getsourcelines_error_issue553": "PASSED", "testing/acceptance_test.py::TestGeneralUsage::test_plugins_given_as_strings": "PASSED", "testing/acceptance_test.py::TestGeneralUsage::test_parametrized_with_bytes_regex": "PASSED", "testing/acceptance_test.py::TestGeneralUsage::test_parametrized_with_null_bytes": "PASSED", "testing/acceptance_test.py::TestInvocationVariants::test_earlyinit": "PASSED", "testing/acceptance_test.py::TestInvocationVariants::test_pydoc": "PASSED", "testing/acceptance_test.py::TestInvocationVariants::test_import_star_pytest": "PASSED", "testing/acceptance_test.py::TestInvocationVariants::test_double_pytestcmdline": "PASSED", "testing/acceptance_test.py::TestInvocationVariants::test_python_minus_m_invocation_ok": "PASSED", "testing/acceptance_test.py::TestInvocationVariants::test_python_minus_m_invocation_fail": "PASSED", "testing/acceptance_test.py::TestInvocationVariants::test_python_pytest_package": "PASSED", "testing/acceptance_test.py::TestInvocationVariants::test_invoke_with_path": "PASSED", "testing/acceptance_test.py::TestInvocationVariants::test_pyargs_importerror": "PASSED", "testing/acceptance_test.py::TestInvocationVariants::test_pyargs_only_imported_once": "PASSED", "testing/acceptance_test.py::TestInvocationVariants::test_pyargs_filename_looks_like_module": "PASSED", "testing/acceptance_test.py::TestInvocationVariants::test_cmdline_python_package": "PASSED", "testing/acceptance_test.py::TestInvocationVariants::test_cmdline_python_namespace_package": "PASSED", "testing/acceptance_test.py::TestInvocationVariants::test_invoke_test_and_doctestmodules": "PASSED", "testing/acceptance_test.py::TestInvocationVariants::test_cmdline_python_package_symlink": "PASSED", "testing/acceptance_test.py::TestInvocationVariants::test_cmdline_python_package_not_exists": "PASSED", "testing/acceptance_test.py::TestInvocationVariants::test_doctest_id": "PASSED", "testing/acceptance_test.py::TestDurations::test_calls": "PASSED", "testing/acceptance_test.py::TestDurations::test_calls_show_2": "PASSED", "testing/acceptance_test.py::TestDurations::test_calls_showall": "PASSED", "testing/acceptance_test.py::TestDurations::test_calls_showall_verbose": "PASSED", "testing/acceptance_test.py::TestDurations::test_with_deselected": "PASSED", "testing/acceptance_test.py::TestDurations::test_with_failing_collection": "PASSED", "testing/acceptance_test.py::TestDurations::test_with_not": "PASSED", "testing/acceptance_test.py::TestDurationsWithFixture::test_setup_function": "PASSED", "testing/acceptance_test.py::test_zipimport_hook": "PASSED", "testing/acceptance_test.py::test_import_plugin_unicode_name": "PASSED", "testing/acceptance_test.py::test_pytest_plugins_as_module": "PASSED", "testing/acceptance_test.py::test_deferred_hook_checking": "PASSED", "testing/acceptance_test.py::test_fixture_order_respects_scope": "PASSED", "testing/acceptance_test.py::test_fixture_mock_integration": "PASSED", "testing/acceptance_test.py::test_usage_error_code": "PASSED", "testing/acceptance_test.py::test_warn_on_async_function": "PASSED", "testing/acceptance_test.py::test_warn_on_async_gen_function": "PASSED", "testing/acceptance_test.py::test_no_brokenpipeerror_message": "PASSED", "testing/acceptance_test.py::test_function_return_non_none_warning": "PASSED", "testing/acceptance_test.py::test_fixture_values_leak": "PASSED", "testing/acceptance_test.py::test_frame_leak_on_failing_test": "PASSED", "testing/acceptance_test.py::test_pdb_can_be_rewritten": "PASSED", "testing/acceptance_test.py::test_tee_stdio_captures_and_live_prints": "PASSED", "testing/acceptance_test.py::test_doctest_and_normal_imports_with_importlib": "PASSED", "[1]": "SKIPPED"}]