[{"repo": "django/django", "instance_id": "django__django-13220", "base_commit": "16218c20606d8cd89c5393970c83da04598a3e04", "patch": "diff --git a/django/core/exceptions.py b/django/core/exceptions.py\n--- a/django/core/exceptions.py\n+++ b/django/core/exceptions.py\n@@ -1,6 +1,9 @@\n \"\"\"\n Global Django exception and warning classes.\n \"\"\"\n+import operator\n+\n+from django.utils.hashable import make_hashable\n \n \n class FieldDoesNotExist(Exception):\n@@ -182,6 +185,23 @@ def __str__(self):\n     def __repr__(self):\n         return 'ValidationError(%s)' % self\n \n+    def __eq__(self, other):\n+        if not isinstance(other, ValidationError):\n+            return NotImplemented\n+        return hash(self) == hash(other)\n+\n+    def __hash__(self):\n+        # Ignore params and messages ordering.\n+        if hasattr(self, 'message'):\n+            return hash((\n+                self.message,\n+                self.code,\n+                tuple(sorted(make_hashable(self.params))) if self.params else None,\n+            ))\n+        if hasattr(self, 'error_dict'):\n+            return hash(tuple(sorted(make_hashable(self.error_dict))))\n+        return hash(tuple(sorted(self.error_list, key=operator.attrgetter('message'))))\n+\n \n class EmptyResultSet(Exception):\n     \"\"\"A database query predicate is impossible.\"\"\"\n", "test_patch": "diff --git a/tests/test_exceptions/test_validation_error.py b/tests/test_exceptions/test_validation_error.py\n--- a/tests/test_exceptions/test_validation_error.py\n+++ b/tests/test_exceptions/test_validation_error.py\n@@ -1,4 +1,5 @@\n import unittest\n+from unittest import mock\n \n from django.core.exceptions import ValidationError\n \n@@ -14,3 +15,271 @@ def test_messages_concatenates_error_dict_values(self):\n         message_dict['field2'] = ['E3', 'E4']\n         exception = ValidationError(message_dict)\n         self.assertEqual(sorted(exception.messages), ['E1', 'E2', 'E3', 'E4'])\n+\n+    def test_eq(self):\n+        error1 = ValidationError('message')\n+        error2 = ValidationError('message', code='my_code1')\n+        error3 = ValidationError('message', code='my_code2')\n+        error4 = ValidationError(\n+            'error %(parm1)s %(parm2)s',\n+            code='my_code1',\n+            params={'parm1': 'val1', 'parm2': 'val2'},\n+        )\n+        error5 = ValidationError({'field1': 'message', 'field2': 'other'})\n+        error6 = ValidationError({'field1': 'message'})\n+        error7 = ValidationError([\n+            ValidationError({'field1': 'field error', 'field2': 'other'}),\n+            'message',\n+        ])\n+\n+        self.assertEqual(error1, ValidationError('message'))\n+        self.assertNotEqual(error1, ValidationError('message2'))\n+        self.assertNotEqual(error1, error2)\n+        self.assertNotEqual(error1, error4)\n+        self.assertNotEqual(error1, error5)\n+        self.assertNotEqual(error1, error6)\n+        self.assertNotEqual(error1, error7)\n+        self.assertEqual(error1, mock.ANY)\n+        self.assertEqual(error2, ValidationError('message', code='my_code1'))\n+        self.assertNotEqual(error2, ValidationError('other', code='my_code1'))\n+        self.assertNotEqual(error2, error3)\n+        self.assertNotEqual(error2, error4)\n+        self.assertNotEqual(error2, error5)\n+        self.assertNotEqual(error2, error6)\n+        self.assertNotEqual(error2, error7)\n+\n+        self.assertEqual(error4, ValidationError(\n+            'error %(parm1)s %(parm2)s',\n+            code='my_code1',\n+            params={'parm1': 'val1', 'parm2': 'val2'},\n+        ))\n+        self.assertNotEqual(error4, ValidationError(\n+            'error %(parm1)s %(parm2)s',\n+            code='my_code2',\n+            params={'parm1': 'val1', 'parm2': 'val2'},\n+        ))\n+        self.assertNotEqual(error4, ValidationError(\n+            'error %(parm1)s %(parm2)s',\n+            code='my_code1',\n+            params={'parm2': 'val2'},\n+        ))\n+        self.assertNotEqual(error4, ValidationError(\n+            'error %(parm1)s %(parm2)s',\n+            code='my_code1',\n+            params={'parm2': 'val1', 'parm1': 'val2'},\n+        ))\n+        self.assertNotEqual(error4, ValidationError(\n+            'error val1 val2',\n+            code='my_code1',\n+        ))\n+        # params ordering is ignored.\n+        self.assertEqual(error4, ValidationError(\n+            'error %(parm1)s %(parm2)s',\n+            code='my_code1',\n+            params={'parm2': 'val2', 'parm1': 'val1'},\n+        ))\n+\n+        self.assertEqual(\n+            error5,\n+            ValidationError({'field1': 'message', 'field2': 'other'}),\n+        )\n+        self.assertNotEqual(\n+            error5,\n+            ValidationError({'field1': 'message', 'field2': 'other2'}),\n+        )\n+        self.assertNotEqual(\n+            error5,\n+            ValidationError({'field1': 'message', 'field3': 'other'}),\n+        )\n+        self.assertNotEqual(error5, error6)\n+        # fields ordering is ignored.\n+        self.assertEqual(\n+            error5,\n+            ValidationError({'field2': 'other', 'field1': 'message'}),\n+        )\n+\n+        self.assertNotEqual(error7, ValidationError(error7.error_list[1:]))\n+        self.assertNotEqual(\n+            ValidationError(['message']),\n+            ValidationError([ValidationError('message', code='my_code')]),\n+        )\n+        # messages ordering is ignored.\n+        self.assertEqual(\n+            error7,\n+            ValidationError(list(reversed(error7.error_list))),\n+        )\n+\n+        self.assertNotEqual(error4, ValidationError([error4]))\n+        self.assertNotEqual(ValidationError([error4]), error4)\n+        self.assertNotEqual(error4, ValidationError({'field1': error4}))\n+        self.assertNotEqual(ValidationError({'field1': error4}), error4)\n+\n+    def test_eq_nested(self):\n+        error_dict = {\n+            'field1': ValidationError(\n+                'error %(parm1)s %(parm2)s',\n+                code='my_code',\n+                params={'parm1': 'val1', 'parm2': 'val2'},\n+            ),\n+            'field2': 'other',\n+        }\n+        error = ValidationError(error_dict)\n+        self.assertEqual(error, ValidationError(dict(error_dict)))\n+        self.assertEqual(error, ValidationError({\n+            'field1': ValidationError(\n+                'error %(parm1)s %(parm2)s',\n+                code='my_code',\n+                params={'parm2': 'val2', 'parm1': 'val1'},\n+            ),\n+            'field2': 'other',\n+        }))\n+        self.assertNotEqual(error, ValidationError(\n+            {**error_dict, 'field2': 'message'},\n+        ))\n+        self.assertNotEqual(error, ValidationError({\n+            'field1': ValidationError(\n+                'error %(parm1)s val2',\n+                code='my_code',\n+                params={'parm1': 'val1'},\n+            ),\n+            'field2': 'other',\n+        }))\n+\n+    def test_hash(self):\n+        error1 = ValidationError('message')\n+        error2 = ValidationError('message', code='my_code1')\n+        error3 = ValidationError('message', code='my_code2')\n+        error4 = ValidationError(\n+            'error %(parm1)s %(parm2)s',\n+            code='my_code1',\n+            params={'parm1': 'val1', 'parm2': 'val2'},\n+        )\n+        error5 = ValidationError({'field1': 'message', 'field2': 'other'})\n+        error6 = ValidationError({'field1': 'message'})\n+        error7 = ValidationError([\n+            ValidationError({'field1': 'field error', 'field2': 'other'}),\n+            'message',\n+        ])\n+\n+        self.assertEqual(hash(error1), hash(ValidationError('message')))\n+        self.assertNotEqual(hash(error1), hash(ValidationError('message2')))\n+        self.assertNotEqual(hash(error1), hash(error2))\n+        self.assertNotEqual(hash(error1), hash(error4))\n+        self.assertNotEqual(hash(error1), hash(error5))\n+        self.assertNotEqual(hash(error1), hash(error6))\n+        self.assertNotEqual(hash(error1), hash(error7))\n+        self.assertEqual(\n+            hash(error2),\n+            hash(ValidationError('message', code='my_code1')),\n+        )\n+        self.assertNotEqual(\n+            hash(error2),\n+            hash(ValidationError('other', code='my_code1')),\n+        )\n+        self.assertNotEqual(hash(error2), hash(error3))\n+        self.assertNotEqual(hash(error2), hash(error4))\n+        self.assertNotEqual(hash(error2), hash(error5))\n+        self.assertNotEqual(hash(error2), hash(error6))\n+        self.assertNotEqual(hash(error2), hash(error7))\n+\n+        self.assertEqual(hash(error4), hash(ValidationError(\n+            'error %(parm1)s %(parm2)s',\n+            code='my_code1',\n+            params={'parm1': 'val1', 'parm2': 'val2'},\n+        )))\n+        self.assertNotEqual(hash(error4), hash(ValidationError(\n+            'error %(parm1)s %(parm2)s',\n+            code='my_code2',\n+            params={'parm1': 'val1', 'parm2': 'val2'},\n+        )))\n+        self.assertNotEqual(hash(error4), hash(ValidationError(\n+            'error %(parm1)s %(parm2)s',\n+            code='my_code1',\n+            params={'parm2': 'val2'},\n+        )))\n+        self.assertNotEqual(hash(error4), hash(ValidationError(\n+            'error %(parm1)s %(parm2)s',\n+            code='my_code1',\n+            params={'parm2': 'val1', 'parm1': 'val2'},\n+        )))\n+        self.assertNotEqual(hash(error4), hash(ValidationError(\n+            'error val1 val2',\n+            code='my_code1',\n+        )))\n+        # params ordering is ignored.\n+        self.assertEqual(hash(error4), hash(ValidationError(\n+            'error %(parm1)s %(parm2)s',\n+            code='my_code1',\n+            params={'parm2': 'val2', 'parm1': 'val1'},\n+        )))\n+\n+        self.assertEqual(\n+            hash(error5),\n+            hash(ValidationError({'field1': 'message', 'field2': 'other'})),\n+        )\n+        self.assertNotEqual(\n+            hash(error5),\n+            hash(ValidationError({'field1': 'message', 'field2': 'other2'})),\n+        )\n+        self.assertNotEqual(\n+            hash(error5),\n+            hash(ValidationError({'field1': 'message', 'field3': 'other'})),\n+        )\n+        self.assertNotEqual(error5, error6)\n+        # fields ordering is ignored.\n+        self.assertEqual(\n+            hash(error5),\n+            hash(ValidationError({'field2': 'other', 'field1': 'message'})),\n+        )\n+\n+        self.assertNotEqual(\n+            hash(error7),\n+            hash(ValidationError(error7.error_list[1:])),\n+        )\n+        self.assertNotEqual(\n+            hash(ValidationError(['message'])),\n+            hash(ValidationError([ValidationError('message', code='my_code')])),\n+        )\n+        # messages ordering is ignored.\n+        self.assertEqual(\n+            hash(error7),\n+            hash(ValidationError(list(reversed(error7.error_list)))),\n+        )\n+\n+        self.assertNotEqual(hash(error4), hash(ValidationError([error4])))\n+        self.assertNotEqual(hash(ValidationError([error4])), hash(error4))\n+        self.assertNotEqual(\n+            hash(error4),\n+            hash(ValidationError({'field1': error4})),\n+        )\n+\n+    def test_hash_nested(self):\n+        error_dict = {\n+            'field1': ValidationError(\n+                'error %(parm1)s %(parm2)s',\n+                code='my_code',\n+                params={'parm2': 'val2', 'parm1': 'val1'},\n+            ),\n+            'field2': 'other',\n+        }\n+        error = ValidationError(error_dict)\n+        self.assertEqual(hash(error), hash(ValidationError(dict(error_dict))))\n+        self.assertEqual(hash(error), hash(ValidationError({\n+            'field1': ValidationError(\n+                'error %(parm1)s %(parm2)s',\n+                code='my_code',\n+                params={'parm1': 'val1', 'parm2': 'val2'},\n+            ),\n+            'field2': 'other',\n+        })))\n+        self.assertNotEqual(hash(error), hash(ValidationError(\n+            {**error_dict, 'field2': 'message'},\n+        )))\n+        self.assertNotEqual(hash(error), hash(ValidationError({\n+            'field1': ValidationError(\n+                'error %(parm1)s val2',\n+                code='my_code',\n+                params={'parm1': 'val1'},\n+            ),\n+            'field2': 'other',\n+        })))\n", "problem_statement": "Allow ValidationErrors to equal each other when created identically\nDescription\n\t \n\t\t(last modified by kamni)\n\t \nCurrently ValidationErrors (django.core.exceptions.ValidationError) that have identical messages don't equal each other, which is counter-intuitive, and can make certain kinds of testing more complicated. Please add an __eq__ method that allows two ValidationErrors to be compared. \nIdeally, this would be more than just a simple self.messages == other.messages. It would be most helpful if the comparison were independent of the order in which errors were raised in a field or in non_field_errors.\n", "hints_text": "I probably wouldn't want to limit the comparison to an error's message but rather to its full set of attributes (message, code, params). While params is always pushed into message when iterating over the errors in an ValidationError, I believe it can be beneficial to know if the params that were put inside are the same.\n\u200bPR", "created_at": "2020-07-21T19:54:16Z", "version": "3.2", "FAIL_TO_PASS": "[\"test_eq (test_exceptions.test_validation_error.TestValidationError)\", \"test_eq_nested (test_exceptions.test_validation_error.TestValidationError)\", \"test_hash (test_exceptions.test_validation_error.TestValidationError)\", \"test_hash_nested (test_exceptions.test_validation_error.TestValidationError)\"]", "PASS_TO_PASS": "[\"test_messages_concatenates_error_dict_values (test_exceptions.test_validation_error.TestValidationError)\"]", "environment_setup_commit": "65dfb06a1ab56c238cc80f5e1c31f61210c4577d"}, "Generating locales (this might take a while)...\n  en_US.UTF-8... done\nGeneration complete.\nOn branch main\nChanges not staged for commit:\n  (use \"git add <file>...\" to update what will be committed)\n  (use \"git restore <file>...\" to discard changes in working directory)\n\tmodified:   django/core/exceptions.py\n\nno changes added to commit (use \"git add\" and/or \"git commit -a\")\ncommit 16218c20606d8cd89c5393970c83da04598a3e04\nAuthor: Florian Demmer <fdemmer@gmail.com>\nDate:   Wed Jul 29 10:33:20 2020 +0200\n\n    Fixed #27395 -- Added sitemap 'alternates' generation.\n    \n    Updated the sitemap generator and default template to optionally\n    include link elements with hreflang attribute to alternate language\n    URLs.\n\ndiff --git a/AUTHORS b/AUTHORS\nindex d7f47d63d7..204a5c45eb 100644\n--- a/AUTHORS\n+++ b/AUTHORS\n@@ -305,6 +305,7 @@ answer newbie questions, and generally made Django that much better:\n     Fl\u00e1vio Juvenal da Silva Junior <flavio@vinta.com.br>\n     flavio.curella@gmail.com\n     Florian Apolloner <florian@apolloner.eu>\n+    Florian Demmer <fdemmer@gmail.com>\n     Florian Moussous <florian.moussous@gmail.com>\n     Fran Hr\u017eenjak <fran.hrzenjak@gmail.com>\n     Francisco Albarran Cristobal <pahko.xd@gmail.com>\ndiff --git a/django/contrib/sitemaps/__init__.py b/django/contrib/sitemaps/__init__.py\nindex 54720324a2..b13507a11e 100644\n--- a/django/contrib/sitemaps/__init__.py\n+++ b/django/contrib/sitemaps/__init__.py\n@@ -60,32 +60,71 @@ class Sitemap:\n     # with which the sitemap was requested.\n     protocol = None\n \n-    def __get(self, name, obj, default=None):\n+    # Enables generating URLs for all languages.\n+    i18n = False\n+\n+    # Override list of languages to use.\n+    languages = None\n+\n+    # Enables generating alternate/hreflang links.\n+    alternates = False\n+\n+    # Add an alternate/hreflang link with value 'x-default'.\n+    x_default = False\n+\n+    def _get(self, name, item, default=None):\n         try:\n             attr = getattr(self, name)\n         except AttributeError:\n             return default\n         if callable(attr):\n-            return attr(obj)\n+            if self.i18n:\n+                # Split the (item, lang_code) tuples again for the location,\n+                # priority, lastmod and changefreq method calls.\n+                item, lang_code = item\n+            return attr(item)\n         return attr\n \n-    def items(self):\n-        return []\n-\n-    def location(self, obj):\n-        return obj.get_absolute_url()\n+    def _languages(self):\n+        if self.languages is not None:\n+            return self.languages\n+        return [lang_code for lang_code, _ in settings.LANGUAGES]\n+\n+    def _items(self):\n+        if self.i18n:\n+            # Create (item, lang_code) tuples for all items and languages.\n+            # This is necessary to paginate with all languages already considered.\n+            items = [\n+                (item, lang_code)\n+                for lang_code in self._languages()\n+                for item in self.items()\n+            ]\n+            return items\n+        return self.items()\n+\n+    def _location(self, item, force_lang_code=None):\n+        if self.i18n:\n+            obj, lang_code = item\n+            # Activate language from item-tuple or forced one before calling location.\n+            with translation.override(force_lang_code or lang_code):\n+                return self._get('location', item)\n+        return self._get('location', item)\n \n     @property\n     def paginator(self):\n-        return paginator.Paginator(self.items(), self.limit)\n+        return paginator.Paginator(self._items(), self.limit)\n \n-    def get_urls(self, page=1, site=None, protocol=None):\n+    def items(self):\n+        return []\n+\n+    def location(self, item):\n+        return item.get_absolute_url()\n+\n+    def get_protocol(self, protocol=None):\n         # Determine protocol\n-        if self.protocol is not None:\n-            protocol = self.protocol\n-        if protocol is None:\n-            protocol = 'http'\n+        return self.protocol or protocol or 'http'\n \n+    def get_domain(self, site=None):\n         # Determine domain\n         if site is None:\n             if django_apps.is_installed('django.contrib.sites'):\n@@ -99,43 +138,61 @@ class Sitemap:\n                     \"To use sitemaps, either enable the sites framework or pass \"\n                     \"a Site/RequestSite object in your view.\"\n                 )\n-        domain = site.domain\n-\n-        if getattr(self, 'i18n', False):\n-            urls = []\n-            current_lang_code = translation.get_language()\n-            for lang_code, lang_name in settings.LANGUAGES:\n-                translation.activate(lang_code)\n-                urls += self._urls(page, protocol, domain)\n-            translation.activate(current_lang_code)\n-        else:\n-            urls = self._urls(page, protocol, domain)\n+        return site.domain\n \n-        return urls\n+    def get_urls(self, page=1, site=None, protocol=None):\n+        protocol = self.get_protocol(protocol)\n+        domain = self.get_domain(site)\n+        return self._urls(page, protocol, domain)\n \n     def _urls(self, page, protocol, domain):\n         urls = []\n         latest_lastmod = None\n         all_items_lastmod = True  # track if all items have a lastmod\n-        for item in self.paginator.page(page).object_list:\n-            loc = \"%s://%s%s\" % (protocol, domain, self.__get('location', item))\n-            priority = self.__get('priority', item)\n-            lastmod = self.__get('lastmod', item)\n+\n+        paginator_page = self.paginator.page(page)\n+        for item in paginator_page.object_list:\n+            loc = f'{protocol}://{domain}{self._location(item)}'\n+            priority = self._get('priority', item)\n+            lastmod = self._get('lastmod', item)\n+\n             if all_items_lastmod:\n                 all_items_lastmod = lastmod is not None\n                 if (all_items_lastmod and\n                         (latest_lastmod is None or lastmod > latest_lastmod)):\n                     latest_lastmod = lastmod\n+\n             url_info = {\n                 'item': item,\n                 'location': loc,\n                 'lastmod': lastmod,\n-                'changefreq': self.__get('changefreq', item),\n+                'changefreq': self._get('changefreq', item),\n                 'priority': str(priority if priority is not None else ''),\n             }\n+\n+            if self.i18n and self.alternates:\n+                alternates = []\n+                for lang_code in self._languages():\n+                    loc = f'{protocol}://{domain}{self._location(item, lang_code)}'\n+                    alternates.append({\n+                        'location': loc,\n+                        'lang_code': lang_code,\n+                    })\n+                if self.x_default:\n+                    lang_code = settings.LANGUAGE_CODE\n+                    loc = f'{protocol}://{domain}{self._location(item, lang_code)}'\n+                    loc = loc.replace(f'/{lang_code}/', '/', 1)\n+                    alternates.append({\n+                        'location': loc,\n+                        'lang_code': 'x-default',\n+                    })\n+                url_info['alternates'] = alternates\n+\n             urls.append(url_info)\n+\n         if all_items_lastmod and latest_lastmod:\n             self.latest_lastmod = latest_lastmod\n+\n         return urls\n \n \n@@ -146,9 +203,9 @@ class GenericSitemap(Sitemap):\n     def __init__(self, info_dict, priority=None, changefreq=None, protocol=None):\n         self.queryset = info_dict['queryset']\n         self.date_field = info_dict.get('date_field')\n-        self.priority = priority\n-        self.changefreq = changefreq\n-        self.protocol = protocol\n+        self.priority = self.priority or priority\n+        self.changefreq = self.changefreq or changefreq\n+        self.protocol = self.protocol or protocol\n \n     def items(self):\n         # Make sure to return a clone; we don't want premature evaluation.\ndiff --git a/django/contrib/sitemaps/templates/sitemap.xml b/django/contrib/sitemaps/templates/sitemap.xml\nindex b13b830b9c..67b166ac36 100644\n--- a/django/contrib/sitemaps/templates/sitemap.xml\n+++ b/django/contrib/sitemaps/templates/sitemap.xml\n@@ -7,7 +7,10 @@\n     {% if url.lastmod %}<lastmod>{{ url.lastmod|date:\"Y-m-d\" }}</lastmod>{% endif %}\n     {% if url.changefreq %}<changefreq>{{ url.changefreq }}</changefreq>{% endif %}\n     {% if url.priority %}<priority>{{ url.priority }}</priority>{% endif %}\n-   </url>\n+    {% for alternate in url.alternates %}\n+    <xhtml:link rel=\"alternate\" hreflang=\"{{ alternate.lang_code }}\" href=\"{{ alternate.location }}\"/>\n+    {% endfor %}\n+  </url>\n {% endfor %}\n {% endspaceless %}\n </urlset>\ndiff --git a/docs/ref/contrib/sitemaps.txt b/docs/ref/contrib/sitemaps.txt\nindex 8f89f6f899..936567411e 100644\n--- a/docs/ref/contrib/sitemaps.txt\n+++ b/docs/ref/contrib/sitemaps.txt\n@@ -252,6 +252,40 @@ Note:\n         be generated using all of your :setting:`LANGUAGES`. The default is\n         ``False``.\n \n+    .. attribute:: Sitemap.languages\n+\n+        .. versionadded:: 3.2\n+\n+        **Optional.**\n+\n+        A :term:`sequence` of :term:`language codes<language code>` to use for\n+        generating alternate links when :attr:`~Sitemap.i18n` is enabled.\n+        Defaults to :setting:`LANGUAGES`.\n+\n+    .. attribute:: Sitemap.alternates\n+\n+        .. versionadded:: 3.2\n+\n+        **Optional.**\n+\n+        A boolean attribute. When used in conjunction with\n+        :attr:`~Sitemap.i18n` generated URLs will each have a list of alternate\n+        links pointing to other language versions using the `hreflang\n+        attribute`_. The default is ``False``.\n+\n+        .. _hreflang attribute: https://support.google.com/webmasters/answer/189077\n+\n+    .. attribute:: Sitemap.x_default\n+\n+        .. versionadded:: 3.2\n+\n+        **Optional.**\n+\n+        A boolean attribute. When ``True`` the alternate links generated by\n+        :attr:`~Sitemap.alternates` will contain a ``hreflang=\"x-default\"``\n+        fallback entry with a value of :setting:`LANGUAGE_CODE`. The default is\n+        ``False``.\n+\n Shortcuts\n =========\n \n@@ -438,12 +472,22 @@ The variable ``urlset`` is a list of URLs that should appear in the\n sitemap. Each URL exposes attributes as defined in the\n :class:`~django.contrib.sitemaps.Sitemap` class:\n \n+- ``alternates``\n - ``changefreq``\n - ``item``\n - ``lastmod``\n - ``location``\n - ``priority``\n \n+The ``alternates`` attribute is available when :attr:`~Sitemap.i18n` and\n+:attr:`~Sitemap.alternates` are enabled. It is a list of other language\n+versions, including the optional :attr:`~Sitemap.x_default` fallback, for each\n+URL. Each alternate is a dictionary with ``location`` and ``lang_code`` keys.\n+\n+.. versionchanged:: 3.2\n+\n+    The ``alternates`` attribute was added.\n+\n The ``item`` attribute has been added for each URL to allow more flexible\n customization of the templates, such as `Google news sitemaps`_. Assuming\n Sitemap's :attr:`~Sitemap.items()` would return a list of items with\ndiff --git a/docs/releases/3.2.txt b/docs/releases/3.2.txt\nindex fe4b309cb5..10468ac655 100644\n--- a/docs/releases/3.2.txt\n+++ b/docs/releases/3.2.txt\n@@ -125,7 +125,11 @@ Minor features\n :mod:`django.contrib.sitemaps`\n ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n \n-* ...\n+* The new :class:`~django.contrib.sitemaps.Sitemap` attributes\n+  :attr:`~django.contrib.sitemaps.Sitemap.alternates`,\n+  :attr:`~django.contrib.sitemaps.Sitemap.languages` and\n+  :attr:`~django.contrib.sitemaps.Sitemap.x_default` allow\n+  generating sitemap *alternates* to localized versions of your pages.\n \n :mod:`django.contrib.sites`\n ~~~~~~~~~~~~~~~~~~~~~~~~~~~\ndiff --git a/tests/sitemaps_tests/test_http.py b/tests/sitemaps_tests/test_http.py\nindex 3d4e1d84dc..3281774cc5 100644\n--- a/tests/sitemaps_tests/test_http.py\n+++ b/tests/sitemaps_tests/test_http.py\n@@ -253,8 +253,10 @@ class HTTPSitemapTests(SitemapTestsBase):\n         self.assertEqual(response.status_code, 200)\n \n     @override_settings(LANGUAGES=(('en', 'English'), ('pt', 'Portuguese')))\n-    def test_simple_i18nsitemap_index(self):\n-        \"A simple i18n sitemap index can be rendered\"\n+    def test_simple_i18n_sitemap_index(self):\n+        \"\"\"\n+        A simple i18n sitemap index can be rendered.\n+        \"\"\"\n         response = self.client.get('/simple/i18n.xml')\n         expected_content = \"\"\"<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n <urlset xmlns=\"http://www.sitemaps.org/schemas/sitemap/0.9\" xmlns:xhtml=\"http://www.w3.org/1999/xhtml\">\n@@ -263,6 +265,80 @@ class HTTPSitemapTests(SitemapTestsBase):\n \"\"\".format(self.base_url, self.i18n_model.pk)\n         self.assertXMLEqual(response.content.decode(), expected_content)\n \n+    @override_settings(LANGUAGES=(('en', 'English'), ('pt', 'Portuguese')))\n+    def test_alternate_i18n_sitemap_index(self):\n+        \"\"\"\n+        A i18n sitemap with alternate/hreflang links can be rendered.\n+        \"\"\"\n+        response = self.client.get('/alternates/i18n.xml')\n+        url, pk = self.base_url, self.i18n_model.pk\n+        expected_urls = f\"\"\"\n+<url><loc>{url}/en/i18n/testmodel/{pk}/</loc><changefreq>never</changefreq><priority>0.5</priority>\n+<xhtml:link rel=\"alternate\" hreflang=\"en\" href=\"{url}/en/i18n/testmodel/{pk}/\"/>\n+<xhtml:link rel=\"alternate\" hreflang=\"pt\" href=\"{url}/pt/i18n/testmodel/{pk}/\"/>\n+</url>\n+<url><loc>{url}/pt/i18n/testmodel/{pk}/</loc><changefreq>never</changefreq><priority>0.5</priority>\n+<xhtml:link rel=\"alternate\" hreflang=\"en\" href=\"{url}/en/i18n/testmodel/{pk}/\"/>\n+<xhtml:link rel=\"alternate\" hreflang=\"pt\" href=\"{url}/pt/i18n/testmodel/{pk}/\"/>\n+</url>\n+\"\"\".replace('\\n', '')\n+        expected_content = f\"\"\"<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<urlset xmlns=\"http://www.sitemaps.org/schemas/sitemap/0.9\" xmlns:xhtml=\"http://www.w3.org/1999/xhtml\">\n+{expected_urls}\n+</urlset>\n+\"\"\"\n+        self.assertXMLEqual(response.content.decode(), expected_content)\n+\n+    @override_settings(LANGUAGES=(('en', 'English'), ('pt', 'Portuguese'), ('es', 'Spanish')))\n+    def test_alternate_i18n_sitemap_limited(self):\n+        \"\"\"\n+        A i18n sitemap index with limited languages can be rendered.\n+        \"\"\"\n+        response = self.client.get('/limited/i18n.xml')\n+        url, pk = self.base_url, self.i18n_model.pk\n+        expected_urls = f\"\"\"\n+<url><loc>{url}/en/i18n/testmodel/{pk}/</loc><changefreq>never</changefreq><priority>0.5</priority>\n+<xhtml:link rel=\"alternate\" hreflang=\"en\" href=\"{url}/en/i18n/testmodel/{pk}/\"/>\n+<xhtml:link rel=\"alternate\" hreflang=\"es\" href=\"{url}/es/i18n/testmodel/{pk}/\"/>\n+</url>\n+<url><loc>{url}/es/i18n/testmodel/{pk}/</loc><changefreq>never</changefreq><priority>0.5</priority>\n+<xhtml:link rel=\"alternate\" hreflang=\"en\" href=\"{url}/en/i18n/testmodel/{pk}/\"/>\n+<xhtml:link rel=\"alternate\" hreflang=\"es\" href=\"{url}/es/i18n/testmodel/{pk}/\"/>\n+</url>\n+\"\"\".replace('\\n', '')\n+        expected_content = f\"\"\"<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<urlset xmlns=\"http://www.sitemaps.org/schemas/sitemap/0.9\" xmlns:xhtml=\"http://www.w3.org/1999/xhtml\">\n+{expected_urls}\n+</urlset>\n+\"\"\"\n+        self.assertXMLEqual(response.content.decode(), expected_content)\n+\n+    @override_settings(LANGUAGES=(('en', 'English'), ('pt', 'Portuguese')))\n+    def test_alternate_i18n_sitemap_xdefault(self):\n+        \"\"\"\n+        A i18n sitemap index with x-default can be rendered.\n+        \"\"\"\n+        response = self.client.get('/x-default/i18n.xml')\n+        url, pk = self.base_url, self.i18n_model.pk\n+        expected_urls = f\"\"\"\n+<url><loc>{url}/en/i18n/testmodel/{pk}/</loc><changefreq>never</changefreq><priority>0.5</priority>\n+<xhtml:link rel=\"alternate\" hreflang=\"en\" href=\"{url}/en/i18n/testmodel/{pk}/\"/>\n+<xhtml:link rel=\"alternate\" hreflang=\"pt\" href=\"{url}/pt/i18n/testmodel/{pk}/\"/>\n+<xhtml:link rel=\"alternate\" hreflang=\"x-default\" href=\"{url}/i18n/testmodel/{pk}/\"/>\n+</url>\n+<url><loc>{url}/pt/i18n/testmodel/{pk}/</loc><changefreq>never</changefreq><priority>0.5</priority>\n+<xhtml:link rel=\"alternate\" hreflang=\"en\" href=\"{url}/en/i18n/testmodel/{pk}/\"/>\n+<xhtml:link rel=\"alternate\" hreflang=\"pt\" href=\"{url}/pt/i18n/testmodel/{pk}/\"/>\n+<xhtml:link rel=\"alternate\" hreflang=\"x-default\" href=\"{url}/i18n/testmodel/{pk}/\"/>\n+</url>\n+\"\"\".replace('\\n', '')\n+        expected_content = f\"\"\"<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<urlset xmlns=\"http://www.sitemaps.org/schemas/sitemap/0.9\" xmlns:xhtml=\"http://www.w3.org/1999/xhtml\">\n+{expected_urls}\n+</urlset>\n+\"\"\"\n+        self.assertXMLEqual(response.content.decode(), expected_content)\n+\n     def test_sitemap_without_entries(self):\n         response = self.client.get('/sitemap-without-entries/sitemap.xml')\n         expected_content = \"\"\"<?xml version=\"1.0\" encoding=\"UTF-8\"?>\ndiff --git a/tests/sitemaps_tests/urls/http.py b/tests/sitemaps_tests/urls/http.py\nindex 495f60fb1a..e4cba4c42f 100644\n--- a/tests/sitemaps_tests/urls/http.py\n+++ b/tests/sitemaps_tests/urls/http.py\n@@ -34,6 +34,18 @@ class SimpleI18nSitemap(Sitemap):\n         return I18nTestModel.objects.order_by('pk').all()\n \n \n+class AlternatesI18nSitemap(SimpleI18nSitemap):\n+    alternates = True\n+\n+\n+class LimitedI18nSitemap(AlternatesI18nSitemap):\n+    languages = ['en', 'es']\n+\n+\n+class XDefaultI18nSitemap(AlternatesI18nSitemap):\n+    x_default = True\n+\n+\n class EmptySitemap(Sitemap):\n     changefreq = \"never\"\n     priority = 0.5\n@@ -77,8 +89,20 @@ simple_sitemaps = {\n     'simple': SimpleSitemap,\n }\n \n-simple_i18nsitemaps = {\n-    'simple': SimpleI18nSitemap,\n+simple_i18n_sitemaps = {\n+    'i18n': SimpleI18nSitemap,\n+}\n+\n+alternates_i18n_sitemaps = {\n+    'i18n-alternates': AlternatesI18nSitemap,\n+}\n+\n+limited_i18n_sitemaps = {\n+    'i18n-limited': LimitedI18nSitemap,\n+}\n+\n+xdefault_i18n_sitemaps = {\n+    'i18n-xdefault': XDefaultI18nSitemap,\n }\n \n simple_sitemaps_not_callable = {\n@@ -97,7 +121,7 @@ fixed_lastmod_sitemaps = {\n     'fixed-lastmod': FixedLastmodSitemap,\n }\n \n-fixed_lastmod__mixed_sitemaps = {\n+fixed_lastmod_mixed_sitemaps = {\n     'fixed-lastmod-mixed': FixedLastmodMixedSitemap,\n }\n \n@@ -151,7 +175,19 @@ urlpatterns = [\n         name='django.contrib.sitemaps.views.sitemap'),\n     path(\n         'simple/i18n.xml', views.sitemap,\n-        {'sitemaps': simple_i18nsitemaps},\n+        {'sitemaps': simple_i18n_sitemaps},\n+        name='django.contrib.sitemaps.views.sitemap'),\n+    path(\n+        'alternates/i18n.xml', views.sitemap,\n+        {'sitemaps': alternates_i18n_sitemaps},\n+        name='django.contrib.sitemaps.views.sitemap'),\n+    path(\n+        'limited/i18n.xml', views.sitemap,\n+        {'sitemaps': limited_i18n_sitemaps},\n+        name='django.contrib.sitemaps.views.sitemap'),\n+    path(\n+        'x-default/i18n.xml', views.sitemap,\n+        {'sitemaps': xdefault_i18n_sitemaps},\n         name='django.contrib.sitemaps.views.sitemap'),\n     path(\n         'simple/custom-sitemap.xml', views.sitemap,\n@@ -167,7 +203,7 @@ urlpatterns = [\n         name='django.contrib.sitemaps.views.sitemap'),\n     path(\n         'lastmod-mixed/sitemap.xml', views.sitemap,\n-        {'sitemaps': fixed_lastmod__mixed_sitemaps},\n+        {'sitemaps': fixed_lastmod_mixed_sitemaps},\n         name='django.contrib.sitemaps.views.sitemap'),\n     path(\n         'lastmod/date-sitemap.xml', views.sitemap,\ndiff --git a/django/core/exceptions.py b/django/core/exceptions.py\nindex dc084b8692..2b3e55fe49 100644\n--- a/django/core/exceptions.py\n+++ b/django/core/exceptions.py\n@@ -1,6 +1,9 @@\n \"\"\"\n Global Django exception and warning classes.\n \"\"\"\n+import operator\n+\n+from django.utils.hashable import make_hashable\n \n \n class FieldDoesNotExist(Exception):\n@@ -182,6 +185,23 @@ class ValidationError(Exception):\n     def __repr__(self):\n         return 'ValidationError(%s)' % self\n \n+    def __eq__(self, other):\n+        if not isinstance(other, ValidationError):\n+            return NotImplemented\n+        return hash(self) == hash(other)\n+\n+    def __hash__(self):\n+        # Ignore params and messages ordering.\n+        if hasattr(self, 'message'):\n+            return hash((\n+                self.message,\n+                self.code,\n+                tuple(sorted(make_hashable(self.params))) if self.params else None,\n+            ))\n+        if hasattr(self, 'error_dict'):\n+            return hash(tuple(sorted(make_hashable(self.error_dict))))\n+        return hash(tuple(sorted(self.error_list, key=operator.attrgetter('message'))))\n+\n \n class EmptyResultSet(Exception):\n     \"\"\"A database query predicate is impossible.\"\"\"\nObtaining file:///testbed\nRequirement already satisfied: asgiref>=3.2.10 in /opt/miniconda3/envs/testbed/lib/python3.6/site-packages (from Django==3.2) (3.4.1)\nRequirement already satisfied: pytz in /opt/miniconda3/envs/testbed/lib/python3.6/site-packages (from Django==3.2) (2024.2)\nRequirement already satisfied: sqlparse>=0.2.2 in /opt/miniconda3/envs/testbed/lib/python3.6/site-packages (from Django==3.2) (0.4.4)\nRequirement already satisfied: typing-extensions in /opt/miniconda3/envs/testbed/lib/python3.6/site-packages (from asgiref>=3.2.10->Django==3.2) (4.1.1)\nInstalling collected packages: Django\n  Attempting uninstall: Django\n    Found existing installation: Django 3.2\n    Uninstalling Django-3.2:\n      Successfully uninstalled Django-3.2\n  Running setup.py develop for Django\nSuccessfully installed Django-3.2\nTesting against Django installed in '/testbed/django'\nImporting application test_exceptions\nSkipping setup of unused database(s): default, other.\nSystem check identified no issues (0 silenced).\n", {}]